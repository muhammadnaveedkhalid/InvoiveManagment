/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/extsprintf";
exports.ids = ["vendor-chunks/extsprintf"];
exports.modules = {

/***/ "(ssr)/./node_modules/extsprintf/lib/extsprintf.js":
/*!***************************************************!*\
  !*** ./node_modules/extsprintf/lib/extsprintf.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * extsprintf.js: extended POSIX-style sprintf\n */ var mod_assert = __webpack_require__(/*! assert */ \"assert\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\n/*\n * Public interface\n */ exports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */ function jsSprintf(fmt) {\n    var regex = [\n        \"([^%]*)\",\n        /* normal text */ \"%\",\n        /* start of format */ \"(['\\\\-+ #0]*?)\",\n        /* flags (optional) */ \"([1-9]\\\\d*)?\",\n        /* width (optional) */ \"(\\\\.([1-9]\\\\d*))?\",\n        /* precision (optional) */ \"[lhjztL]*?\",\n        /* length mods (ignored) */ \"([diouxXfFeEgGaAcCsSp%jr])\" /* conversion */ \n    ].join(\"\");\n    var re = new RegExp(regex);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var flags, width, precision, conversion;\n    var left, pad, sign, arg, match;\n    var ret = \"\";\n    var argn = 1;\n    mod_assert.equal(\"string\", typeof fmt);\n    while((match = re.exec(fmt)) !== null){\n        ret += match[1];\n        fmt = fmt.substring(match[0].length);\n        flags = match[2] || \"\";\n        width = match[3] || 0;\n        precision = match[4] || \"\";\n        conversion = match[6];\n        left = false;\n        sign = false;\n        pad = \" \";\n        if (conversion == \"%\") {\n            ret += \"%\";\n            continue;\n        }\n        if (args.length === 0) throw new Error(\"too few args to sprintf\");\n        arg = args.shift();\n        argn++;\n        if (flags.match(/[\\' #]/)) throw new Error(\"unsupported flags: \" + flags);\n        if (precision.length > 0) throw new Error(\"non-zero precision not supported\");\n        if (flags.match(/-/)) left = true;\n        if (flags.match(/0/)) pad = \"0\";\n        if (flags.match(/\\+/)) sign = true;\n        switch(conversion){\n            case \"s\":\n                if (arg === undefined || arg === null) throw new Error(\"argument \" + argn + \": attempted to print undefined or null \" + \"as a string\");\n                ret += doPad(pad, width, left, arg.toString());\n                break;\n            case \"d\":\n                arg = Math.floor(arg);\n            /*jsl:fallthru*/ case \"f\":\n                sign = sign && arg > 0 ? \"+\" : \"\";\n                ret += sign + doPad(pad, width, left, arg.toString());\n                break;\n            case \"x\":\n                ret += doPad(pad, width, left, arg.toString(16));\n                break;\n            case \"j\":\n                /* non-standard */ if (width === 0) width = 10;\n                ret += mod_util.inspect(arg, false, width);\n                break;\n            case \"r\":\n                /* non-standard */ ret += dumpException(arg);\n                break;\n            default:\n                throw new Error(\"unsupported conversion: \" + conversion);\n        }\n    }\n    ret += fmt;\n    return ret;\n}\nfunction jsPrintf() {\n    var args = Array.prototype.slice.call(arguments);\n    args.unshift(process.stdout);\n    jsFprintf.apply(null, args);\n}\nfunction jsFprintf(stream) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return stream.write(jsSprintf.apply(this, args));\n}\nfunction doPad(chr, width, left, str) {\n    var ret = str;\n    while(ret.length < width){\n        if (left) ret += chr;\n        else ret = chr + ret;\n    }\n    return ret;\n}\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */ function dumpException(ex) {\n    var ret;\n    if (!(ex instanceof Error)) throw new Error(jsSprintf(\"invalid type for %%r: %j\", ex));\n    /* Note that V8 prepends \"ex.stack\" with ex.toString(). */ ret = \"EXCEPTION: \" + ex.constructor.name + \": \" + ex.stack;\n    if (ex.cause && typeof ex.cause === \"function\") {\n        var cex = ex.cause();\n        if (cex) {\n            ret += \"\\nCaused by: \" + dumpException(cex);\n        }\n    }\n    return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXh0c3ByaW50Zi9saWIvZXh0c3ByaW50Zi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCOztDQUVDLEdBQ0RFLGVBQWUsR0FBR0U7QUFDbEJGLGNBQWMsR0FBR0k7QUFDakJKLGVBQWUsR0FBR007QUFFbEI7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0QsU0FBU0osVUFBVUssR0FBRztJQUVyQixJQUFJQyxRQUFRO1FBQ1I7UUFBYyxlQUFlLEdBQzdCO1FBQVEsbUJBQW1CLEdBQzNCO1FBQXFCLG9CQUFvQixHQUN6QztRQUFrQixvQkFBb0IsR0FDdEM7UUFBc0Isd0JBQXdCLEdBQzlDO1FBQWdCLHlCQUF5QixHQUN6Qyw2QkFBNkIsY0FBYztLQUM5QyxDQUFDQyxJQUFJLENBQUM7SUFFUCxJQUFJQyxLQUFLLElBQUlDLE9BQU9IO0lBQ3BCLElBQUlJLE9BQU9DLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNDLFdBQVc7SUFDakQsSUFBSUMsT0FBT0MsT0FBT0MsV0FBV0M7SUFDN0IsSUFBSUMsTUFBTUMsS0FBS0MsTUFBTUMsS0FBS0M7SUFDMUIsSUFBSUMsTUFBTTtJQUNWLElBQUlDLE9BQU87SUFFWC9CLFdBQVdnQyxLQUFLLENBQUMsVUFBVSxPQUFRdEI7SUFFbkMsTUFBTyxDQUFDbUIsUUFBUWhCLEdBQUdvQixJQUFJLENBQUN2QixJQUFHLE1BQU8sS0FBTTtRQUN2Q29CLE9BQU9ELEtBQUssQ0FBQyxFQUFFO1FBQ2ZuQixNQUFNQSxJQUFJd0IsU0FBUyxDQUFDTCxLQUFLLENBQUMsRUFBRSxDQUFDTSxNQUFNO1FBRW5DZCxRQUFRUSxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3BCUCxRQUFRTyxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3BCTixZQUFZTSxLQUFLLENBQUMsRUFBRSxJ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QmMsY0FBY2M7UUFDeEM7SUFDRDtJQUVBLE9BQVE1QjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2ljZS1hcHAvLi9ub2RlX21vZHVsZXMvZXh0c3ByaW50Zi9saWIvZXh0c3ByaW50Zi5qcz84MzRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBleHRzcHJpbnRmLmpzOiBleHRlbmRlZCBQT1NJWC1zdHlsZSBzcHJpbnRmXG4gKi9cblxudmFyIG1vZF9hc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBtb2RfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLypcbiAqIFB1YmxpYyBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0cy5zcHJpbnRmID0ganNTcHJpbnRmO1xuZXhwb3J0cy5wcmludGYgPSBqc1ByaW50ZjtcbmV4cG9ydHMuZnByaW50ZiA9IGpzRnByaW50ZjtcblxuLypcbiAqIFN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiBzW25dcHJpbnRmKDNjKS4gIFdlIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB0aHJvdyBhblxuICogZXhjZXB0aW9uIHdoZW4gZ2l2ZW4gYSBmb3JtYXQgc3RyaW5nIHdlIGRvbid0IHVuZGVyc3RhbmQsIHJhdGhlciB0aGFuXG4gKiBpZ25vcmluZyBpdCwgc28gdGhhdCB3ZSB3b24ndCBicmVhayBleGlzdGluZyBwcm9ncmFtcyBpZi93aGVuIHdlIGdvIGltcGxlbWVudFxuICogdGhlIHJlc3Qgb2YgdGhpcy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBzdXBwb3J0cyBzcGVjaWZ5aW5nXG4gKlx0LSBmaWVsZCBhbGlnbm1lbnQgKCctJyBmbGFnKSxcbiAqIFx0LSB6ZXJvLXBhZCAoJzAnIGZsYWcpXG4gKlx0LSBhbHdheXMgc2hvdyBudW1lcmljIHNpZ24gKCcrJyBmbGFnKSxcbiAqXHQtIGZpZWxkIHdpZHRoXG4gKlx0LSBjb252ZXJzaW9ucyBmb3Igc3RyaW5ncywgZGVjaW1hbCBpbnRlZ2VycywgYW5kIGZsb2F0cyAobnVtYmVycykuXG4gKlx0LSBhcmd1bWVudCBzaXplIHNwZWNpZmllcnMuICBUaGVzZSBhcmUgYWxsIGFjY2VwdGVkIGJ1dCBpZ25vcmVkLCBzaW5jZVxuICpcdCAgSmF2YXNjcmlwdCBoYXMgbm8gbm90aW9uIG9mIHRoZSBwaHlzaWNhbCBzaXplIG9mIGFuIGFyZ3VtZW50LlxuICpcbiAqIEV2ZXJ5dGhpbmcgZWxzZSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQsIG1vc3Qgbm90YWJseSBwcmVjaXNpb24sIHVuc2lnbmVkXG4gKiBudW1iZXJzLCBub24tZGVjaW1hbCBudW1iZXJzLCBhbmQgY2hhcmFjdGVycy5cbiAqL1xuZnVuY3Rpb24ganNTcHJpbnRmKGZtdClcbntcblx0dmFyIHJlZ2V4ID0gW1xuXHQgICAgJyhbXiVdKiknLFx0XHRcdFx0Lyogbm9ybWFsIHRleHQgKi9cblx0ICAgICclJyxcdFx0XHRcdC8qIHN0YXJ0IG9mIGZvcm1hdCAqL1xuXHQgICAgJyhbXFwnXFxcXC0rICMwXSo/KScsXHRcdFx0LyogZmxhZ3MgKG9wdGlvbmFsKSAqL1xuXHQgICAgJyhbMS05XVxcXFxkKik/JyxcdFx0XHQvKiB3aWR0aCAob3B0aW9uYWwpICovXG5cdCAgICAnKFxcXFwuKFsxLTldXFxcXGQqKSk/JyxcdFx0LyogcHJlY2lzaW9uIChvcHRpb25hbCkgKi9cblx0ICAgICdbbGhqenRMXSo/JyxcdFx0XHQvKiBsZW5ndGggbW9kcyAoaWdub3JlZCkgKi9cblx0ICAgICcoW2Rpb3V4WGZGZUVnR2FBY0NzU3AlanJdKSdcdC8qIGNvbnZlcnNpb24gKi9cblx0XS5qb2luKCcnKTtcblxuXHR2YXIgcmUgPSBuZXcgUmVnRXhwKHJlZ2V4KTtcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHR2YXIgZmxhZ3MsIHdpZHRoLCBwcmVjaXNpb24sIGNvbnZlcnNpb247XG5cdHZhciBsZWZ0LCBwYWQsIHNpZ24sIGFyZywgbWF0Y2g7XG5cdHZhciByZXQgPSAnJztcblx0dmFyIGFyZ24gPSAxO1xuXG5cdG1vZF9hc3NlcnQuZXF1YWwoJ3N0cmluZycsIHR5cGVvZiAoZm10KSk7XG5cblx0d2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm10KSkgIT09IG51bGwpIHtcblx0XHRyZXQgKz0gbWF0Y2hbMV07XG5cdFx0Zm10ID0gZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuXG5cdFx0ZmxhZ3MgPSBtYXRjaFsyXSB8fCAnJztcblx0XHR3aWR0aCA9IG1hdGNoWzNdIHx8IDA7XG5cdFx0cHJlY2lzaW9uID0gbWF0Y2hbNF0gfHwgJyc7XG5cdFx0Y29udmVyc2lvbiA9IG1hdGNoWzZdO1xuXHRcdGxlZnQgPSBmYWxzZTtcblx0XHRzaWduID0gZmFsc2U7XG5cdFx0cGFkID0gJyAnO1xuXG5cdFx0aWYgKGNvbnZlcnNpb24gPT0gJyUnKSB7XG5cdFx0XHRyZXQgKz0gJyUnO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndG9vIGZldyBhcmdzIHRvIHNwcmludGYnKSk7XG5cblx0XHRhcmcgPSBhcmdzLnNoaWZ0KCk7XG5cdFx0YXJnbisrO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC9bXFwnICNdLykpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKFxuXHRcdFx0ICAgICd1bnN1cHBvcnRlZCBmbGFnczogJyArIGZsYWdzKSk7XG5cblx0XHRpZiAocHJlY2lzaW9uLmxlbmd0aCA+IDApXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKFxuXHRcdFx0ICAgICdub24temVybyBwcmVjaXNpb24gbm90IHN1cHBvcnRlZCcpKTtcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvLS8pKVxuXHRcdFx0bGVmdCA9IHRydWU7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goLzAvKSlcblx0XHRcdHBhZCA9ICcwJztcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvXFwrLykpXG5cdFx0XHRzaWduID0gdHJ1ZTtcblxuXHRcdHN3aXRjaCAoY29udmVyc2lvbikge1xuXHRcdGNhc2UgJ3MnOlxuXHRcdFx0aWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IGFyZyA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignYXJndW1lbnQgJyArIGFyZ24gK1xuXHRcdFx0XHQgICAgJzogYXR0ZW1wdGVkIHRvIHByaW50IHVuZGVmaW5lZCBvciBudWxsICcgK1xuXHRcdFx0XHQgICAgJ2FzIGEgc3RyaW5nJykpO1xuXHRcdFx0cmV0ICs9IGRvUGFkKHBhZCwgd2lkdGgsIGxlZnQsIGFyZy50b1N0cmluZygpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnZCc6XG5cdFx0XHRhcmcgPSBNYXRoLmZsb29yKGFyZyk7XG5cdFx0XHQvKmpzbDpmYWxsdGhydSovXG5cdFx0Y2FzZSAnZic6XG5cdFx0XHRzaWduID0gc2lnbiAmJiBhcmcgPiAwID8gJysnIDogJyc7XG5cdFx0XHRyZXQgKz0gc2lnbiArIGRvUGFkKHBhZCwgd2lkdGgsIGxlZnQsXG5cdFx0XHQgICAgYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICd4Jzpcblx0XHRcdHJldCArPSBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LCBhcmcudG9TdHJpbmcoMTYpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnaic6IC8qIG5vbi1zdGFuZGFyZCAqL1xuXHRcdFx0aWYgKHdpZHRoID09PSAwKVxuXHRcdFx0XHR3aWR0aCA9IDEwO1xuXHRcdFx0cmV0ICs9IG1vZF91dGlsLmluc3BlY3QoYXJnLCBmYWxzZSwgd2lkdGgpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdyJzogLyogbm9uLXN0YW5kYXJkICovXG5cdFx0XHRyZXQgKz0gZHVtcEV4Y2VwdGlvbihhcmcpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgY29udmVyc2lvbjogJyArXG5cdFx0XHQgICAgY29udmVyc2lvbikpO1xuXHRcdH1cblx0fVxuXG5cdHJldCArPSBmbXQ7XG5cdHJldHVybiAocmV0KTtcbn1cblxuZnVuY3Rpb24ganNQcmludGYoKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0YXJncy51bnNoaWZ0KHByb2Nlc3Muc3Rkb3V0KTtcblx0anNGcHJpbnRmLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc0ZwcmludGYoc3RyZWFtKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0cmV0dXJuIChzdHJlYW0ud3JpdGUoanNTcHJpbnRmLmFwcGx5KHRoaXMsIGFyZ3MpKSk7XG59XG5cbmZ1bmN0aW9uIGRvUGFkKGNociwgd2lkdGgsIGxlZnQsIHN0cilcbntcblx0dmFyIHJldCA9IHN0cjtcblxuXHR3aGlsZSAocmV0Lmxlbmd0aCA8IHdpZHRoKSB7XG5cdFx0aWYgKGxlZnQpXG5cdFx0XHRyZXQgKz0gY2hyO1xuXHRcdGVsc2Vcblx0XHRcdHJldCA9IGNociArIHJldDtcblx0fVxuXG5cdHJldHVybiAocmV0KTtcbn1cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gZHVtcHMgbG9uZyBzdGFjayB0cmFjZXMgZm9yIGV4Y2VwdGlvbnMgaGF2aW5nIGEgY2F1c2UoKSBtZXRob2QuXG4gKiBTZWUgbm9kZS12ZXJyb3IgZm9yIGFuIGV4YW1wbGUuXG4gKi9cbmZ1bmN0aW9uIGR1bXBFeGNlcHRpb24oZXgpXG57XG5cdHZhciByZXQ7XG5cblx0aWYgKCEoZXggaW5zdGFuY2VvZiBFcnJvcikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcihqc1NwcmludGYoJ2ludmFsaWQgdHlwZSBmb3IgJSVyOiAlaicsIGV4KSkpO1xuXG5cdC8qIE5vdGUgdGhhdCBWOCBwcmVwZW5kcyBcImV4LnN0YWNrXCIgd2l0aCBleC50b1N0cmluZygpLiAqL1xuXHRyZXQgPSAnRVhDRVBUSU9OOiAnICsgZXguY29uc3RydWN0b3IubmFtZSArICc6ICcgKyBleC5zdGFjaztcblxuXHRpZiAoZXguY2F1c2UgJiYgdHlwZW9mIChleC5jYXVzZSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgY2V4ID0gZXguY2F1c2UoKTtcblx0XHRpZiAoY2V4KSB7XG5cdFx0XHRyZXQgKz0gJ1xcbkNhdXNlZCBieTogJyArIGR1bXBFeGNlcHRpb24oY2V4KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59XG4iXSwibmFtZXMiOlsibW9kX2Fzc2VydCIsInJlcXVpcmUiLCJtb2RfdXRpbCIsImV4cG9ydHMiLCJzcHJpbnRmIiwianNTcHJpbnRmIiwicHJpbnRmIiwianNQcmludGYiLCJmcHJpbnRmIiwianNGcHJpbnRmIiwiZm10IiwicmVnZXgiLCJqb2luIiwicmUiLCJSZWdFeHAiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJmbGFncyIsIndpZHRoIiwicHJlY2lzaW9uIiwiY29udmVyc2lvbiIsImxlZnQiLCJwYWQiLCJzaWduIiwiYXJnIiwibWF0Y2giLCJyZXQiLCJhcmduIiwiZXF1YWwiLCJleGVjIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiRXJyb3IiLCJzaGlmdCIsInVuZGVmaW5lZCIsImRvUGFkIiwidG9TdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJpbnNwZWN0IiwiZHVtcEV4Y2VwdGlvbiIsInVuc2hpZnQiLCJwcm9jZXNzIiwic3Rkb3V0IiwiYXBwbHkiLCJzdHJlYW0iLCJ3cml0ZSIsImNociIsInN0ciIsImV4IiwiY29uc3RydWN0b3IiLCJuYW1lIiwic3RhY2siLCJjYXVzZSIsImNleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/extsprintf/lib/extsprintf.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/extsprintf/lib/extsprintf.js":
/*!***************************************************!*\
  !*** ./node_modules/extsprintf/lib/extsprintf.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * extsprintf.js: extended POSIX-style sprintf\n */ var mod_assert = __webpack_require__(/*! assert */ \"assert\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\n/*\n * Public interface\n */ exports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */ function jsSprintf(fmt) {\n    var regex = [\n        \"([^%]*)\",\n        /* normal text */ \"%\",\n        /* start of format */ \"(['\\\\-+ #0]*?)\",\n        /* flags (optional) */ \"([1-9]\\\\d*)?\",\n        /* width (optional) */ \"(\\\\.([1-9]\\\\d*))?\",\n        /* precision (optional) */ \"[lhjztL]*?\",\n        /* length mods (ignored) */ \"([diouxXfFeEgGaAcCsSp%jr])\" /* conversion */ \n    ].join(\"\");\n    var re = new RegExp(regex);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var flags, width, precision, conversion;\n    var left, pad, sign, arg, match;\n    var ret = \"\";\n    var argn = 1;\n    mod_assert.equal(\"string\", typeof fmt);\n    while((match = re.exec(fmt)) !== null){\n        ret += match[1];\n        fmt = fmt.substring(match[0].length);\n        flags = match[2] || \"\";\n        width = match[3] || 0;\n        precision = match[4] || \"\";\n        conversion = match[6];\n        left = false;\n        sign = false;\n        pad = \" \";\n        if (conversion == \"%\") {\n            ret += \"%\";\n            continue;\n        }\n        if (args.length === 0) throw new Error(\"too few args to sprintf\");\n        arg = args.shift();\n        argn++;\n        if (flags.match(/[\\' #]/)) throw new Error(\"unsupported flags: \" + flags);\n        if (precision.length > 0) throw new Error(\"non-zero precision not supported\");\n        if (flags.match(/-/)) left = true;\n        if (flags.match(/0/)) pad = \"0\";\n        if (flags.match(/\\+/)) sign = true;\n        switch(conversion){\n            case \"s\":\n                if (arg === undefined || arg === null) throw new Error(\"argument \" + argn + \": attempted to print undefined or null \" + \"as a string\");\n                ret += doPad(pad, width, left, arg.toString());\n                break;\n            case \"d\":\n                arg = Math.floor(arg);\n            /*jsl:fallthru*/ case \"f\":\n                sign = sign && arg > 0 ? \"+\" : \"\";\n                ret += sign + doPad(pad, width, left, arg.toString());\n                break;\n            case \"x\":\n                ret += doPad(pad, width, left, arg.toString(16));\n                break;\n            case \"j\":\n                /* non-standard */ if (width === 0) width = 10;\n                ret += mod_util.inspect(arg, false, width);\n                break;\n            case \"r\":\n                /* non-standard */ ret += dumpException(arg);\n                break;\n            default:\n                throw new Error(\"unsupported conversion: \" + conversion);\n        }\n    }\n    ret += fmt;\n    return ret;\n}\nfunction jsPrintf() {\n    var args = Array.prototype.slice.call(arguments);\n    args.unshift(process.stdout);\n    jsFprintf.apply(null, args);\n}\nfunction jsFprintf(stream) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return stream.write(jsSprintf.apply(this, args));\n}\nfunction doPad(chr, width, left, str) {\n    var ret = str;\n    while(ret.length < width){\n        if (left) ret += chr;\n        else ret = chr + ret;\n    }\n    return ret;\n}\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */ function dumpException(ex) {\n    var ret;\n    if (!(ex instanceof Error)) throw new Error(jsSprintf(\"invalid type for %%r: %j\", ex));\n    /* Note that V8 prepends \"ex.stack\" with ex.toString(). */ ret = \"EXCEPTION: \" + ex.constructor.name + \": \" + ex.stack;\n    if (ex.cause && typeof ex.cause === \"function\") {\n        var cex = ex.cause();\n        if (cex) {\n            ret += \"\\nCaused by: \" + dumpException(cex);\n        }\n    }\n    return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXh0c3ByaW50Zi9saWIvZXh0c3ByaW50Zi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCOztDQUVDLEdBQ0RFLGVBQWUsR0FBR0U7QUFDbEJGLGNBQWMsR0FBR0k7QUFDakJKLGVBQWUsR0FBR007QUFFbEI7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0QsU0FBU0osVUFBVUssR0FBRztJQUVyQixJQUFJQyxRQUFRO1FBQ1I7UUFBYyxlQUFlLEdBQzdCO1FBQVEsbUJBQW1CLEdBQzNCO1FBQXFCLG9CQUFvQixHQUN6QztRQUFrQixvQkFBb0IsR0FDdEM7UUFBc0Isd0JBQXdCLEdBQzlDO1FBQWdCLHlCQUF5QixHQUN6Qyw2QkFBNkIsY0FBYztLQUM5QyxDQUFDQyxJQUFJLENBQUM7SUFFUCxJQUFJQyxLQUFLLElBQUlDLE9BQU9IO0lBQ3BCLElBQUlJLE9BQU9DLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNDLFdBQVc7SUFDakQsSUFBSUMsT0FBT0MsT0FBT0MsV0FBV0M7SUFDN0IsSUFBSUMsTUFBTUMsS0FBS0MsTUFBTUMsS0FBS0M7SUFDMUIsSUFBSUMsTUFBTTtJQUNWLElBQUlDLE9BQU87SUFFWC9CLFdBQVdnQyxLQUFLLENBQUMsVUFBVSxPQUFRdEI7SUFFbkMsTUFBTyxDQUFDbUIsUUFBUWhCLEdBQUdvQixJQUFJLENBQUN2QixJQUFHLE1BQU8sS0FBTTtRQUN2Q29CLE9BQU9ELEtBQUssQ0FBQyxFQUFFO1FBQ2ZuQixNQUFNQSxJQUFJd0IsU0FBUyxDQUFDTCxLQUFLLENBQUMsRUFBRSxDQUFDTSxNQUFNO1FBRW5DZCxRQUFRUSxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3BCUCxRQUFRTyxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3BCTixZQUFZTSxLQUFLLENBQUMsRUFBRSxJ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QmMsY0FBY2M7UUFDeEM7SUFDRDtJQUVBLE9BQVE1QjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2ljZS1hcHAvLi9ub2RlX21vZHVsZXMvZXh0c3ByaW50Zi9saWIvZXh0c3ByaW50Zi5qcz84MzRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBleHRzcHJpbnRmLmpzOiBleHRlbmRlZCBQT1NJWC1zdHlsZSBzcHJpbnRmXG4gKi9cblxudmFyIG1vZF9hc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBtb2RfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLypcbiAqIFB1YmxpYyBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0cy5zcHJpbnRmID0ganNTcHJpbnRmO1xuZXhwb3J0cy5wcmludGYgPSBqc1ByaW50ZjtcbmV4cG9ydHMuZnByaW50ZiA9IGpzRnByaW50ZjtcblxuLypcbiAqIFN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiBzW25dcHJpbnRmKDNjKS4gIFdlIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB0aHJvdyBhblxuICogZXhjZXB0aW9uIHdoZW4gZ2l2ZW4gYSBmb3JtYXQgc3RyaW5nIHdlIGRvbid0IHVuZGVyc3RhbmQsIHJhdGhlciB0aGFuXG4gKiBpZ25vcmluZyBpdCwgc28gdGhhdCB3ZSB3b24ndCBicmVhayBleGlzdGluZyBwcm9ncmFtcyBpZi93aGVuIHdlIGdvIGltcGxlbWVudFxuICogdGhlIHJlc3Qgb2YgdGhpcy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBzdXBwb3J0cyBzcGVjaWZ5aW5nXG4gKlx0LSBmaWVsZCBhbGlnbm1lbnQgKCctJyBmbGFnKSxcbiAqIFx0LSB6ZXJvLXBhZCAoJzAnIGZsYWcpXG4gKlx0LSBhbHdheXMgc2hvdyBudW1lcmljIHNpZ24gKCcrJyBmbGFnKSxcbiAqXHQtIGZpZWxkIHdpZHRoXG4gKlx0LSBjb252ZXJzaW9ucyBmb3Igc3RyaW5ncywgZGVjaW1hbCBpbnRlZ2VycywgYW5kIGZsb2F0cyAobnVtYmVycykuXG4gKlx0LSBhcmd1bWVudCBzaXplIHNwZWNpZmllcnMuICBUaGVzZSBhcmUgYWxsIGFjY2VwdGVkIGJ1dCBpZ25vcmVkLCBzaW5jZVxuICpcdCAgSmF2YXNjcmlwdCBoYXMgbm8gbm90aW9uIG9mIHRoZSBwaHlzaWNhbCBzaXplIG9mIGFuIGFyZ3VtZW50LlxuICpcbiAqIEV2ZXJ5dGhpbmcgZWxzZSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQsIG1vc3Qgbm90YWJseSBwcmVjaXNpb24sIHVuc2lnbmVkXG4gKiBudW1iZXJzLCBub24tZGVjaW1hbCBudW1iZXJzLCBhbmQgY2hhcmFjdGVycy5cbiAqL1xuZnVuY3Rpb24ganNTcHJpbnRmKGZtdClcbntcblx0dmFyIHJlZ2V4ID0gW1xuXHQgICAgJyhbXiVdKiknLFx0XHRcdFx0Lyogbm9ybWFsIHRleHQgKi9cblx0ICAgICclJyxcdFx0XHRcdC8qIHN0YXJ0IG9mIGZvcm1hdCAqL1xuXHQgICAgJyhbXFwnXFxcXC0rICMwXSo/KScsXHRcdFx0LyogZmxhZ3MgKG9wdGlvbmFsKSAqL1xuXHQgICAgJyhbMS05XVxcXFxkKik/JyxcdFx0XHQvKiB3aWR0aCAob3B0aW9uYWwpICovXG5cdCAgICAnKFxcXFwuKFsxLTldXFxcXGQqKSk/JyxcdFx0LyogcHJlY2lzaW9uIChvcHRpb25hbCkgKi9cblx0ICAgICdbbGhqenRMXSo/JyxcdFx0XHQvKiBsZW5ndGggbW9kcyAoaWdub3JlZCkgKi9cblx0ICAgICcoW2Rpb3V4WGZGZUVnR2FBY0NzU3AlanJdKSdcdC8qIGNvbnZlcnNpb24gKi9cblx0XS5qb2luKCcnKTtcblxuXHR2YXIgcmUgPSBuZXcgUmVnRXhwKHJlZ2V4KTtcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHR2YXIgZmxhZ3MsIHdpZHRoLCBwcmVjaXNpb24sIGNvbnZlcnNpb247XG5cdHZhciBsZWZ0LCBwYWQsIHNpZ24sIGFyZywgbWF0Y2g7XG5cdHZhciByZXQgPSAnJztcblx0dmFyIGFyZ24gPSAxO1xuXG5cdG1vZF9hc3NlcnQuZXF1YWwoJ3N0cmluZycsIHR5cGVvZiAoZm10KSk7XG5cblx0d2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm10KSkgIT09IG51bGwpIHtcblx0XHRyZXQgKz0gbWF0Y2hbMV07XG5cdFx0Zm10ID0gZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuXG5cdFx0ZmxhZ3MgPSBtYXRjaFsyXSB8fCAnJztcblx0XHR3aWR0aCA9IG1hdGNoWzNdIHx8IDA7XG5cdFx0cHJlY2lzaW9uID0gbWF0Y2hbNF0gfHwgJyc7XG5cdFx0Y29udmVyc2lvbiA9IG1hdGNoWzZdO1xuXHRcdGxlZnQgPSBmYWxzZTtcblx0XHRzaWduID0gZmFsc2U7XG5cdFx0cGFkID0gJyAnO1xuXG5cdFx0aWYgKGNvbnZlcnNpb24gPT0gJyUnKSB7XG5cdFx0XHRyZXQgKz0gJyUnO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndG9vIGZldyBhcmdzIHRvIHNwcmludGYnKSk7XG5cblx0XHRhcmcgPSBhcmdzLnNoaWZ0KCk7XG5cdFx0YXJnbisrO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC9bXFwnICNdLykpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKFxuXHRcdFx0ICAgICd1bnN1cHBvcnRlZCBmbGFnczogJyArIGZsYWdzKSk7XG5cblx0XHRpZiAocHJlY2lzaW9uLmxlbmd0aCA+IDApXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKFxuXHRcdFx0ICAgICdub24temVybyBwcmVjaXNpb24gbm90IHN1cHBvcnRlZCcpKTtcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvLS8pKVxuXHRcdFx0bGVmdCA9IHRydWU7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goLzAvKSlcblx0XHRcdHBhZCA9ICcwJztcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvXFwrLykpXG5cdFx0XHRzaWduID0gdHJ1ZTtcblxuXHRcdHN3aXRjaCAoY29udmVyc2lvbikge1xuXHRcdGNhc2UgJ3MnOlxuXHRcdFx0aWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IGFyZyA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignYXJndW1lbnQgJyArIGFyZ24gK1xuXHRcdFx0XHQgICAgJzogYXR0ZW1wdGVkIHRvIHByaW50IHVuZGVmaW5lZCBvciBudWxsICcgK1xuXHRcdFx0XHQgICAgJ2FzIGEgc3RyaW5nJykpO1xuXHRcdFx0cmV0ICs9IGRvUGFkKHBhZCwgd2lkdGgsIGxlZnQsIGFyZy50b1N0cmluZygpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnZCc6XG5cdFx0XHRhcmcgPSBNYXRoLmZsb29yKGFyZyk7XG5cdFx0XHQvKmpzbDpmYWxsdGhydSovXG5cdFx0Y2FzZSAnZic6XG5cdFx0XHRzaWduID0gc2lnbiAmJiBhcmcgPiAwID8gJysnIDogJyc7XG5cdFx0XHRyZXQgKz0gc2lnbiArIGRvUGFkKHBhZCwgd2lkdGgsIGxlZnQsXG5cdFx0XHQgICAgYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICd4Jzpcblx0XHRcdHJldCArPSBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LCBhcmcudG9TdHJpbmcoMTYpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnaic6IC8qIG5vbi1zdGFuZGFyZCAqL1xuXHRcdFx0aWYgKHdpZHRoID09PSAwKVxuXHRcdFx0XHR3aWR0aCA9IDEwO1xuXHRcdFx0cmV0ICs9IG1vZF91dGlsLmluc3BlY3QoYXJnLCBmYWxzZSwgd2lkdGgpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdyJzogLyogbm9uLXN0YW5kYXJkICovXG5cdFx0XHRyZXQgKz0gZHVtcEV4Y2VwdGlvbihhcmcpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgY29udmVyc2lvbjogJyArXG5cdFx0XHQgICAgY29udmVyc2lvbikpO1xuXHRcdH1cblx0fVxuXG5cdHJldCArPSBmbXQ7XG5cdHJldHVybiAocmV0KTtcbn1cblxuZnVuY3Rpb24ganNQcmludGYoKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0YXJncy51bnNoaWZ0KHByb2Nlc3Muc3Rkb3V0KTtcblx0anNGcHJpbnRmLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc0ZwcmludGYoc3RyZWFtKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0cmV0dXJuIChzdHJlYW0ud3JpdGUoanNTcHJpbnRmLmFwcGx5KHRoaXMsIGFyZ3MpKSk7XG59XG5cbmZ1bmN0aW9uIGRvUGFkKGNociwgd2lkdGgsIGxlZnQsIHN0cilcbntcblx0dmFyIHJldCA9IHN0cjtcblxuXHR3aGlsZSAocmV0Lmxlbmd0aCA8IHdpZHRoKSB7XG5cdFx0aWYgKGxlZnQpXG5cdFx0XHRyZXQgKz0gY2hyO1xuXHRcdGVsc2Vcblx0XHRcdHJldCA9IGNociArIHJldDtcblx0fVxuXG5cdHJldHVybiAocmV0KTtcbn1cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gZHVtcHMgbG9uZyBzdGFjayB0cmFjZXMgZm9yIGV4Y2VwdGlvbnMgaGF2aW5nIGEgY2F1c2UoKSBtZXRob2QuXG4gKiBTZWUgbm9kZS12ZXJyb3IgZm9yIGFuIGV4YW1wbGUuXG4gKi9cbmZ1bmN0aW9uIGR1bXBFeGNlcHRpb24oZXgpXG57XG5cdHZhciByZXQ7XG5cblx0aWYgKCEoZXggaW5zdGFuY2VvZiBFcnJvcikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcihqc1NwcmludGYoJ2ludmFsaWQgdHlwZSBmb3IgJSVyOiAlaicsIGV4KSkpO1xuXG5cdC8qIE5vdGUgdGhhdCBWOCBwcmVwZW5kcyBcImV4LnN0YWNrXCIgd2l0aCBleC50b1N0cmluZygpLiAqL1xuXHRyZXQgPSAnRVhDRVBUSU9OOiAnICsgZXguY29uc3RydWN0b3IubmFtZSArICc6ICcgKyBleC5zdGFjaztcblxuXHRpZiAoZXguY2F1c2UgJiYgdHlwZW9mIChleC5jYXVzZSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgY2V4ID0gZXguY2F1c2UoKTtcblx0XHRpZiAoY2V4KSB7XG5cdFx0XHRyZXQgKz0gJ1xcbkNhdXNlZCBieTogJyArIGR1bXBFeGNlcHRpb24oY2V4KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59XG4iXSwibmFtZXMiOlsibW9kX2Fzc2VydCIsInJlcXVpcmUiLCJtb2RfdXRpbCIsImV4cG9ydHMiLCJzcHJpbnRmIiwianNTcHJpbnRmIiwicHJpbnRmIiwianNQcmludGYiLCJmcHJpbnRmIiwianNGcHJpbnRmIiwiZm10IiwicmVnZXgiLCJqb2luIiwicmUiLCJSZWdFeHAiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJmbGFncyIsIndpZHRoIiwicHJlY2lzaW9uIiwiY29udmVyc2lvbiIsImxlZnQiLCJwYWQiLCJzaWduIiwiYXJnIiwibWF0Y2giLCJyZXQiLCJhcmduIiwiZXF1YWwiLCJleGVjIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiRXJyb3IiLCJzaGlmdCIsInVuZGVmaW5lZCIsImRvUGFkIiwidG9TdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJpbnNwZWN0IiwiZHVtcEV4Y2VwdGlvbiIsInVuc2hpZnQiLCJwcm9jZXNzIiwic3Rkb3V0IiwiYXBwbHkiLCJzdHJlYW0iLCJ3cml0ZSIsImNociIsInN0ciIsImV4IiwiY29uc3RydWN0b3IiLCJuYW1lIiwic3RhY2siLCJjYXVzZSIsImNleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/extsprintf/lib/extsprintf.js\n");

/***/ })

};
;