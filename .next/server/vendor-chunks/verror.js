"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/verror";
exports.ids = ["vendor-chunks/verror"];
exports.modules = {

/***/ "(ssr)/./node_modules/verror/lib/verror.js":
/*!*******************************************!*\
  !*** ./node_modules/verror/lib/verror.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * verror.js: richer JavaScript errors\n */ \nvar mod_assertplus = __webpack_require__(/*! assert-plus */ \"(ssr)/./node_modules/assert-plus/assert.js\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\nvar mod_extsprintf = __webpack_require__(/*! extsprintf */ \"(ssr)/./node_modules/extsprintf/lib/extsprintf.js\");\nvar mod_isError = (__webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\").isError);\nvar sprintf = mod_extsprintf.sprintf;\n/*\n * Public interface\n */ /* So you can 'var VError = require('verror')' */ module.exports = VError;\n/* For compatibility */ VError.VError = VError;\n/* Other exported classes */ VError.SError = SError;\nVError.WError = WError;\nVError.MultiError = MultiError;\n/*\n * Common function used to parse constructor arguments for VError, WError, and\n * SError.  Named arguments to this function:\n *\n *     strict\t\tforce strict interpretation of sprintf arguments, even\n *     \t\t\tif the options in \"argv\" don't say so\n *\n *     argv\t\terror's constructor arguments, which are to be\n *     \t\t\tinterpreted as described in README.md.  For quick\n *     \t\t\treference, \"argv\" has one of the following forms:\n *\n *          [ sprintf_args... ]           (argv[0] is a string)\n *          [ cause, sprintf_args... ]    (argv[0] is an Error)\n *          [ options, sprintf_args... ]  (argv[0] is an object)\n *\n * This function normalizes these forms, producing an object with the following\n * properties:\n *\n *    options           equivalent to \"options\" in third form.  This will never\n *    \t\t\tbe a direct reference to what the caller passed in\n *    \t\t\t(i.e., it may be a shallow copy), so it can be freely\n *    \t\t\tmodified.\n *\n *    shortmessage      result of sprintf(sprintf_args), taking options.strict\n *    \t\t\tinto account as described in README.md.\n */ function parseConstructorArguments(args) {\n    var argv, options, sprintf_args, shortmessage, k;\n    mod_assertplus.object(args, \"args\");\n    mod_assertplus.bool(args.strict, \"args.strict\");\n    mod_assertplus.array(args.argv, \"args.argv\");\n    argv = args.argv;\n    /*\n\t * First, figure out which form of invocation we've been given.\n\t */ if (argv.length === 0) {\n        options = {};\n        sprintf_args = [];\n    } else if (mod_isError(argv[0])) {\n        options = {\n            \"cause\": argv[0]\n        };\n        sprintf_args = argv.slice(1);\n    } else if (typeof argv[0] === \"object\") {\n        options = {};\n        for(k in argv[0]){\n            options[k] = argv[0][k];\n        }\n        sprintf_args = argv.slice(1);\n    } else {\n        mod_assertplus.string(argv[0], \"first argument to VError, SError, or WError \" + \"constructor must be a string, object, or Error\");\n        options = {};\n        sprintf_args = argv;\n    }\n    /*\n\t * Now construct the error's message.\n\t *\n\t * extsprintf (which we invoke here with our caller's arguments in order\n\t * to construct this Error's message) is strict in its interpretation of\n\t * values to be processed by the \"%s\" specifier.  The value passed to\n\t * extsprintf must actually be a string or something convertible to a\n\t * String using .toString().  Passing other values (notably \"null\" and\n\t * \"undefined\") is considered a programmer error.  The assumption is\n\t * that if you actually want to print the string \"null\" or \"undefined\",\n\t * then that's easy to do that when you're calling extsprintf; on the\n\t * other hand, if you did NOT want that (i.e., there's actually a bug\n\t * where the program assumes some variable is non-null and tries to\n\t * print it, which might happen when constructing a packet or file in\n\t * some specific format), then it's better to stop immediately than\n\t * produce bogus output.\n\t *\n\t * However, sometimes the bug is only in the code calling VError, and a\n\t * programmer might prefer to have the error message contain \"null\" or\n\t * \"undefined\" rather than have the bug in the error path crash the\n\t * program (making the first bug harder to identify).  For that reason,\n\t * by default VError converts \"null\" or \"undefined\" arguments to their\n\t * string representations and passes those to extsprintf.  Programmers\n\t * desiring the strict behavior can use the SError class or pass the\n\t * \"strict\" option to the VError constructor.\n\t */ mod_assertplus.object(options);\n    if (!options.strict && !args.strict) {\n        sprintf_args = sprintf_args.map(function(a) {\n            return a === null ? \"null\" : a === undefined ? \"undefined\" : a;\n        });\n    }\n    if (sprintf_args.length === 0) {\n        shortmessage = \"\";\n    } else {\n        shortmessage = sprintf.apply(null, sprintf_args);\n    }\n    return {\n        \"options\": options,\n        \"shortmessage\": shortmessage\n    };\n}\n/*\n * See README.md for reference documentation.\n */ function VError() {\n    var args, obj, parsed, cause, ctor, message, k;\n    args = Array.prototype.slice.call(arguments, 0);\n    /*\n\t * This is a regrettable pattern, but JavaScript's built-in Error class\n\t * is defined to work this way, so we allow the constructor to be called\n\t * without \"new\".\n\t */ if (!(this instanceof VError)) {\n        obj = Object.create(VError.prototype);\n        VError.apply(obj, arguments);\n        return obj;\n    }\n    /*\n\t * For convenience and backwards compatibility, we support several\n\t * different calling forms.  Normalize them here.\n\t */ parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": false\n    });\n    /*\n\t * If we've been given a name, apply it now.\n\t */ if (parsed.options.name) {\n        mod_assertplus.string(parsed.options.name, 'error\\'s \"name\" must be a string');\n        this.name = parsed.options.name;\n    }\n    /*\n\t * For debugging, we keep track of the original short message (attached\n\t * this Error particularly) separately from the complete message (which\n\t * includes the messages of our cause chain).\n\t */ this.jse_shortmsg = parsed.shortmessage;\n    message = parsed.shortmessage;\n    /*\n\t * If we've been given a cause, record a reference to it and update our\n\t * message appropriately.\n\t */ cause = parsed.options.cause;\n    if (cause) {\n        mod_assertplus.ok(mod_isError(cause), \"cause is not an Error\");\n        this.jse_cause = cause;\n        if (!parsed.options.skipCauseMessage) {\n            message += \": \" + cause.message;\n        }\n    }\n    /*\n\t * If we've been given an object with properties, shallow-copy that\n\t * here.  We don't want to use a deep copy in case there are non-plain\n\t * objects here, but we don't want to use the original object in case\n\t * the caller modifies it later.\n\t */ this.jse_info = {};\n    if (parsed.options.info) {\n        for(k in parsed.options.info){\n            this.jse_info[k] = parsed.options.info[k];\n        }\n    }\n    this.message = message;\n    Error.call(this, message);\n    if (Error.captureStackTrace) {\n        ctor = parsed.options.constructorOpt || this.constructor;\n        Error.captureStackTrace(this, ctor);\n    }\n    return this;\n}\nmod_util.inherits(VError, Error);\nVError.prototype.name = \"VError\";\nVError.prototype.toString = function ve_toString() {\n    var str = this.hasOwnProperty(\"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n    if (this.message) str += \": \" + this.message;\n    return str;\n};\n/*\n * This method is provided for compatibility.  New callers should use\n * VError.cause() instead.  That method also uses the saner `null` return value\n * when there is no cause.\n */ VError.prototype.cause = function ve_cause() {\n    var cause = VError.cause(this);\n    return cause === null ? undefined : cause;\n};\n/*\n * Static methods\n *\n * These class-level methods are provided so that callers can use them on\n * instances of Errors that are not VErrors.  New interfaces should be provided\n * only using static methods to eliminate the class of programming mistake where\n * people fail to check whether the Error object has the corresponding methods.\n */ VError.cause = function(err) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    return mod_isError(err.jse_cause) ? err.jse_cause : null;\n};\nVError.info = function(err) {\n    var rv, cause, k;\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    cause = VError.cause(err);\n    if (cause !== null) {\n        rv = VError.info(cause);\n    } else {\n        rv = {};\n    }\n    if (typeof err.jse_info == \"object\" && err.jse_info !== null) {\n        for(k in err.jse_info){\n            rv[k] = err.jse_info[k];\n        }\n    }\n    return rv;\n};\nVError.findCauseByName = function(err, name) {\n    var cause;\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    mod_assertplus.string(name, \"name\");\n    mod_assertplus.ok(name.length > 0, \"name cannot be empty\");\n    for(cause = err; cause !== null; cause = VError.cause(cause)){\n        mod_assertplus.ok(mod_isError(cause));\n        if (cause.name == name) {\n            return cause;\n        }\n    }\n    return null;\n};\nVError.hasCauseWithName = function(err, name) {\n    return VError.findCauseByName(err, name) !== null;\n};\nVError.fullStack = function(err) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    var cause = VError.cause(err);\n    if (cause) {\n        return err.stack + \"\\ncaused by: \" + VError.fullStack(cause);\n    }\n    return err.stack;\n};\nVError.errorFromList = function(errors) {\n    mod_assertplus.arrayOfObject(errors, \"errors\");\n    if (errors.length === 0) {\n        return null;\n    }\n    errors.forEach(function(e) {\n        mod_assertplus.ok(mod_isError(e));\n    });\n    if (errors.length == 1) {\n        return errors[0];\n    }\n    return new MultiError(errors);\n};\nVError.errorForEach = function(err, func) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    mod_assertplus.func(func, \"func\");\n    if (err instanceof MultiError) {\n        err.errors().forEach(function iterError(e) {\n            func(e);\n        });\n    } else {\n        func(err);\n    }\n};\n/*\n * SError is like VError, but stricter about types.  You cannot pass \"null\" or\n * \"undefined\" as string arguments to the formatter.\n */ function SError() {\n    var args, obj, parsed, options;\n    args = Array.prototype.slice.call(arguments, 0);\n    if (!(this instanceof SError)) {\n        obj = Object.create(SError.prototype);\n        SError.apply(obj, arguments);\n        return obj;\n    }\n    parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": true\n    });\n    options = parsed.options;\n    VError.call(this, options, \"%s\", parsed.shortmessage);\n    return this;\n}\n/*\n * We don't bother setting SError.prototype.name because once constructed,\n * SErrors are just like VErrors.\n */ mod_util.inherits(SError, VError);\n/*\n * Represents a collection of errors for the purpose of consumers that generally\n * only deal with one error.  Callers can extract the individual errors\n * contained in this object, but may also just treat it as a normal single\n * error, in which case a summary message will be printed.\n */ function MultiError(errors) {\n    mod_assertplus.array(errors, \"list of errors\");\n    mod_assertplus.ok(errors.length > 0, \"must be at least one error\");\n    this.ase_errors = errors;\n    VError.call(this, {\n        \"cause\": errors[0]\n    }, \"first of %d error%s\", errors.length, errors.length == 1 ? \"\" : \"s\");\n}\nmod_util.inherits(MultiError, VError);\nMultiError.prototype.name = \"MultiError\";\nMultiError.prototype.errors = function me_errors() {\n    return this.ase_errors.slice(0);\n};\n/*\n * See README.md for reference details.\n */ function WError() {\n    var args, obj, parsed, options;\n    args = Array.prototype.slice.call(arguments, 0);\n    if (!(this instanceof WError)) {\n        obj = Object.create(WError.prototype);\n        WError.apply(obj, args);\n        return obj;\n    }\n    parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": false\n    });\n    options = parsed.options;\n    options[\"skipCauseMessage\"] = true;\n    VError.call(this, options, \"%s\", parsed.shortmessage);\n    return this;\n}\nmod_util.inherits(WError, VError);\nWError.prototype.name = \"WError\";\nWError.prototype.toString = function we_toString() {\n    var str = this.hasOwnProperty(\"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n    if (this.message) str += \": \" + this.message;\n    if (this.jse_cause && this.jse_cause.message) str += \"; caused by \" + this.jse_cause.toString();\n    return str;\n};\n/*\n * For purely historical reasons, WError's cause() function allows you to set\n * the cause.\n */ WError.prototype.cause = function we_cause(c) {\n    if (mod_isError(c)) this.jse_cause = c;\n    return this.jse_cause;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmVycm9yL2xpYi92ZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7QUFFRCxJQUFJQSxpQkFBaUJDLG1CQUFPQSxDQUFDO0FBQzdCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCLElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUcsY0FBY0gsa0dBQStCO0FBQ2pELElBQUlLLFVBQVVILGVBQWVHLE9BQU87QUFFcEM7O0NBRUMsR0FFRCwrQ0FBK0MsR0FDL0NDLE9BQU9DLE9BQU8sR0FBR0M7QUFDakIscUJBQXFCLEdBQ3JCQSxPQUFPQSxNQUFNLEdBQUdBO0FBQ2hCLDBCQUEwQixHQUMxQkEsT0FBT0MsTUFBTSxHQUFHQTtBQUNoQkQsT0FBT0UsTUFBTSxHQUFHQTtBQUNoQkYsT0FBT0csVUFBVSxHQUFHQTtBQUVwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELFNBQVNDLDBCQUEwQkMsSUFBSTtJQUV0QyxJQUFJQyxNQUFNQyxTQUFTQyxjQUFjQyxjQUFjQztJQUUvQ25CLGVBQWVvQixNQUFNLENBQUNOLE1BQU07SUFDNUJkLGVBQWVxQixJQUFJLENBQUNQLEtBQUtRLE1BQU0sRUFBRTtJQUNqQ3RCLGVBQWV1QixLQUFLLENBQUNULEtBQUtDLElBQUksRUFBRTtJQUNoQ0EsT0FBT0QsS0FBS0MsSUFBSTtJQUVoQjs7RUFFQyxHQUNELElBQUlBLEtBQUtTLE1BQU0sS0FBSyxHQUFHO1FBQ3RCUixVQUFVLENBQUM7UUFDWEMsZUFBZSxFQUFFO0lBQ2xCLE9BQU8sSUFBSWIsWUFBWVcsSUFBSSxDQUFDLEVBQUUsR0FBRztRQUNoQ0MsVUFBVTtZQUFFLFNBQVNELElBQUksQ0FBQyxFQUFFO1FBQUM7UUFDN0JFLGVBQWVGLEtBQUtVLEtBQUssQ0FBQztJQUMzQixPQUFPLElBQUksT0FBUVYsSUFBSSxDQUFDLEVBQUUsS0FBTSxVQUFVO1FBQ3pDQyxVQUFVLENBQUM7UUFDWCxJ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UUFBUSxHQUFHLFNBQVNxQjtJQUVwQyxJQUFJbkIsTUFBTyxJQUFJLENBQUNDLGNBQWMsQ0FBQyxXQUFXLElBQUksQ0FBQ2YsSUFBSSxJQUNsRCxJQUFJLENBQUNVLFdBQVcsQ0FBQ1YsSUFBSSxJQUFJLElBQUksQ0FBQ1UsV0FBVyxDQUFDZixTQUFTLENBQUNLLElBQUk7SUFDekQsSUFBSSxJQUFJLENBQUNQLE9BQU8sRUFDZnFCLE9BQU8sT0FBTyxJQUFJLENBQUNyQixPQUFPO0lBQzNCLElBQUksSUFBSSxDQUFDVSxTQUFTLElBQUksSUFBSSxDQUFDQSxTQUFTLENBQUNWLE9BQU8sRUFDM0NxQixPQUFPLGlCQUFpQixJQUFJLENBQUNYLFNBQVMsQ0FBQ1MsUUFBUTtJQUVoRCxPQUFRRTtBQUNUO0FBRUE7OztDQUdDLEdBQ0Q3QyxPQUFPMEIsU0FBUyxDQUFDSixLQUFLLEdBQUcsU0FBUzJDLFNBQVNDLENBQUM7SUFFM0MsSUFBSXpFLFlBQVl5RSxJQUNmLElBQUksQ0FBQ2hDLFNBQVMsR0FBR2dDO0lBRWxCLE9BQVEsSUFBSSxDQUFDaEMsU0FBUztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL3ZlcnJvci9saWIvdmVycm9yLmpzP2YwYTYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIHZlcnJvci5qczogcmljaGVyIEphdmFTY3JpcHQgZXJyb3JzXG4gKi9cblxudmFyIG1vZF9hc3NlcnRwbHVzID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBtb2RfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIG1vZF9leHRzcHJpbnRmID0gcmVxdWlyZSgnZXh0c3ByaW50ZicpO1xudmFyIG1vZF9pc0Vycm9yID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJykuaXNFcnJvcjtcbnZhciBzcHJpbnRmID0gbW9kX2V4dHNwcmludGYuc3ByaW50ZjtcblxuLypcbiAqIFB1YmxpYyBpbnRlcmZhY2VcbiAqL1xuXG4vKiBTbyB5b3UgY2FuICd2YXIgVkVycm9yID0gcmVxdWlyZSgndmVycm9yJyknICovXG5tb2R1bGUuZXhwb3J0cyA9IFZFcnJvcjtcbi8qIEZvciBjb21wYXRpYmlsaXR5ICovXG5WRXJyb3IuVkVycm9yID0gVkVycm9yO1xuLyogT3RoZXIgZXhwb3J0ZWQgY2xhc3NlcyAqL1xuVkVycm9yLlNFcnJvciA9IFNFcnJvcjtcblZFcnJvci5XRXJyb3IgPSBXRXJyb3I7XG5WRXJyb3IuTXVsdGlFcnJvciA9IE11bHRpRXJyb3I7XG5cbi8qXG4gKiBDb21tb24gZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMgZm9yIFZFcnJvciwgV0Vycm9yLCBhbmRcbiAqIFNFcnJvci4gIE5hbWVkIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uOlxuICpcbiAqICAgICBzdHJpY3RcdFx0Zm9yY2Ugc3RyaWN0IGludGVycHJldGF0aW9uIG9mIHNwcmludGYgYXJndW1lbnRzLCBldmVuXG4gKiAgICAgXHRcdFx0aWYgdGhlIG9wdGlvbnMgaW4gXCJhcmd2XCIgZG9uJ3Qgc2F5IHNvXG4gKlxuICogICAgIGFyZ3ZcdFx0ZXJyb3IncyBjb25zdHJ1Y3RvciBhcmd1bWVudHMsIHdoaWNoIGFyZSB0byBiZVxuICogICAgIFx0XHRcdGludGVycHJldGVkIGFzIGRlc2NyaWJlZCBpbiBSRUFETUUubWQuICBGb3IgcXVpY2tcbiAqICAgICBcdFx0XHRyZWZlcmVuY2UsIFwiYXJndlwiIGhhcyBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqXG4gKiAgICAgICAgICBbIHNwcmludGZfYXJncy4uLiBdICAgICAgICAgICAoYXJndlswXSBpcyBhIHN0cmluZylcbiAqICAgICAgICAgIFsgY2F1c2UsIHNwcmludGZfYXJncy4uLiBdICAgIChhcmd2WzBdIGlzIGFuIEVycm9yKVxuICogICAgICAgICAgWyBvcHRpb25zLCBzcHJpbnRmX2FyZ3MuLi4gXSAgKGFyZ3ZbMF0gaXMgYW4gb2JqZWN0KVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplcyB0aGVzZSBmb3JtcywgcHJvZHVjaW5nIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAgb3B0aW9ucyAgICAgICAgICAgZXF1aXZhbGVudCB0byBcIm9wdGlvbnNcIiBpbiB0aGlyZCBmb3JtLiAgVGhpcyB3aWxsIG5ldmVyXG4gKiAgICBcdFx0XHRiZSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gd2hhdCB0aGUgY2FsbGVyIHBhc3NlZCBpblxuICogICAgXHRcdFx0KGkuZS4sIGl0IG1heSBiZSBhIHNoYWxsb3cgY29weSksIHNvIGl0IGNhbiBiZSBmcmVlbHlcbiAqICAgIFx0XHRcdG1vZGlmaWVkLlxuICpcbiAqICAgIHNob3J0bWVzc2FnZSAgICAgIHJlc3VsdCBvZiBzcHJpbnRmKHNwcmludGZfYXJncyksIHRha2luZyBvcHRpb25zLnN0cmljdFxuICogICAgXHRcdFx0aW50byBhY2NvdW50IGFzIGRlc2NyaWJlZCBpbiBSRUFETUUubWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoYXJncylcbntcblx0dmFyIGFyZ3YsIG9wdGlvbnMsIHNwcmludGZfYXJncywgc2hvcnRtZXNzYWdlLCBrO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9iamVjdChhcmdzLCAnYXJncycpO1xuXHRtb2RfYXNzZXJ0cGx1cy5ib29sKGFyZ3Muc3RyaWN0LCAnYXJncy5zdHJpY3QnKTtcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXkoYXJncy5hcmd2LCAnYXJncy5hcmd2Jyk7XG5cdGFyZ3YgPSBhcmdzLmFyZ3Y7XG5cblx0Lypcblx0ICogRmlyc3QsIGZpZ3VyZSBvdXQgd2hpY2ggZm9ybSBvZiBpbnZvY2F0aW9uIHdlJ3ZlIGJlZW4gZ2l2ZW4uXG5cdCAqL1xuXHRpZiAoYXJndi5sZW5ndGggPT09IDApIHtcblx0XHRvcHRpb25zID0ge307XG5cdFx0c3ByaW50Zl9hcmdzID0gW107XG5cdH0gZWxzZSBpZiAobW9kX2lzRXJyb3IoYXJndlswXSkpIHtcblx0XHRvcHRpb25zID0geyAnY2F1c2UnOiBhcmd2WzBdIH07XG5cdFx0c3ByaW50Zl9hcmdzID0gYXJndi5zbGljZSgxKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgKGFyZ3ZbMF0pID09PSAnb2JqZWN0Jykge1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRmb3IgKGsgaW4gYXJndlswXSkge1xuXHRcdFx0b3B0aW9uc1trXSA9IGFyZ3ZbMF1ba107XG5cdFx0fVxuXHRcdHNwcmludGZfYXJncyA9IGFyZ3Yuc2xpY2UoMSk7XG5cdH0gZWxzZSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKGFyZ3ZbMF0sXG5cdFx0ICAgICdmaXJzdCBhcmd1bWVudCB0byBWRXJyb3IsIFNFcnJvciwgb3IgV0Vycm9yICcgK1xuXHRcdCAgICAnY29uc3RydWN0b3IgbXVzdCBiZSBhIHN0cmluZywgb2JqZWN0LCBvciBFcnJvcicpO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRzcHJpbnRmX2FyZ3MgPSBhcmd2O1xuXHR9XG5cblx0Lypcblx0ICogTm93IGNvbnN0cnVjdCB0aGUgZXJyb3IncyBtZXNzYWdlLlxuXHQgKlxuXHQgKiBleHRzcHJpbnRmICh3aGljaCB3ZSBpbnZva2UgaGVyZSB3aXRoIG91ciBjYWxsZXIncyBhcmd1bWVudHMgaW4gb3JkZXJcblx0ICogdG8gY29uc3RydWN0IHRoaXMgRXJyb3IncyBtZXNzYWdlKSBpcyBzdHJpY3QgaW4gaXRzIGludGVycHJldGF0aW9uIG9mXG5cdCAqIHZhbHVlcyB0byBiZSBwcm9jZXNzZWQgYnkgdGhlIFwiJXNcIiBzcGVjaWZpZXIuICBUaGUgdmFsdWUgcGFzc2VkIHRvXG5cdCAqIGV4dHNwcmludGYgbXVzdCBhY3R1YWxseSBiZSBhIHN0cmluZyBvciBzb21ldGhpbmcgY29udmVydGlibGUgdG8gYVxuXHQgKiBTdHJpbmcgdXNpbmcgLnRvU3RyaW5nKCkuICBQYXNzaW5nIG90aGVyIHZhbHVlcyAobm90YWJseSBcIm51bGxcIiBhbmRcblx0ICogXCJ1bmRlZmluZWRcIikgaXMgY29uc2lkZXJlZCBhIHByb2dyYW1tZXIgZXJyb3IuICBUaGUgYXNzdW1wdGlvbiBpc1xuXHQgKiB0aGF0IGlmIHlvdSBhY3R1YWxseSB3YW50IHRvIHByaW50IHRoZSBzdHJpbmcgXCJudWxsXCIgb3IgXCJ1bmRlZmluZWRcIixcblx0ICogdGhlbiB0aGF0J3MgZWFzeSB0byBkbyB0aGF0IHdoZW4geW91J3JlIGNhbGxpbmcgZXh0c3ByaW50Zjsgb24gdGhlXG5cdCAqIG90aGVyIGhhbmQsIGlmIHlvdSBkaWQgTk9UIHdhbnQgdGhhdCAoaS5lLiwgdGhlcmUncyBhY3R1YWxseSBhIGJ1Z1xuXHQgKiB3aGVyZSB0aGUgcHJvZ3JhbSBhc3N1bWVzIHNvbWUgdmFyaWFibGUgaXMgbm9uLW51bGwgYW5kIHRyaWVzIHRvXG5cdCAqIHByaW50IGl0LCB3aGljaCBtaWdodCBoYXBwZW4gd2hlbiBjb25zdHJ1Y3RpbmcgYSBwYWNrZXQgb3IgZmlsZSBpblxuXHQgKiBzb21lIHNwZWNpZmljIGZvcm1hdCksIHRoZW4gaXQncyBiZXR0ZXIgdG8gc3RvcCBpbW1lZGlhdGVseSB0aGFuXG5cdCAqIHByb2R1Y2UgYm9ndXMgb3V0cHV0LlxuXHQgKlxuXHQgKiBIb3dldmVyLCBzb21ldGltZXMgdGhlIGJ1ZyBpcyBvbmx5IGluIHRoZSBjb2RlIGNhbGxpbmcgVkVycm9yLCBhbmQgYVxuXHQgKiBwcm9ncmFtbWVyIG1pZ2h0IHByZWZlciB0byBoYXZlIHRoZSBlcnJvciBtZXNzYWdlIGNvbnRhaW4gXCJudWxsXCIgb3Jcblx0ICogXCJ1bmRlZmluZWRcIiByYXRoZXIgdGhhbiBoYXZlIHRoZSBidWcgaW4gdGhlIGVycm9yIHBhdGggY3Jhc2ggdGhlXG5cdCAqIHByb2dyYW0gKG1ha2luZyB0aGUgZmlyc3QgYnVnIGhhcmRlciB0byBpZGVudGlmeSkuICBGb3IgdGhhdCByZWFzb24sXG5cdCAqIGJ5IGRlZmF1bHQgVkVycm9yIGNvbnZlcnRzIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIgYXJndW1lbnRzIHRvIHRoZWlyXG5cdCAqIHN0cmluZyByZXByZXNlbnRhdGlvbnMgYW5kIHBhc3NlcyB0aG9zZSB0byBleHRzcHJpbnRmLiAgUHJvZ3JhbW1lcnNcblx0ICogZGVzaXJpbmcgdGhlIHN0cmljdCBiZWhhdmlvciBjYW4gdXNlIHRoZSBTRXJyb3IgY2xhc3Mgb3IgcGFzcyB0aGVcblx0ICogXCJzdHJpY3RcIiBvcHRpb24gdG8gdGhlIFZFcnJvciBjb25zdHJ1Y3Rvci5cblx0ICovXG5cdG1vZF9hc3NlcnRwbHVzLm9iamVjdChvcHRpb25zKTtcblx0aWYgKCFvcHRpb25zLnN0cmljdCAmJiAhYXJncy5zdHJpY3QpIHtcblx0XHRzcHJpbnRmX2FyZ3MgPSBzcHJpbnRmX2FyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG5cdFx0XHRyZXR1cm4gKGEgPT09IG51bGwgPyAnbnVsbCcgOlxuXHRcdFx0ICAgIGEgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogYSk7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoc3ByaW50Zl9hcmdzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHNob3J0bWVzc2FnZSA9ICcnO1xuXHR9IGVsc2Uge1xuXHRcdHNob3J0bWVzc2FnZSA9IHNwcmludGYuYXBwbHkobnVsbCwgc3ByaW50Zl9hcmdzKTtcblx0fVxuXG5cdHJldHVybiAoe1xuXHQgICAgJ29wdGlvbnMnOiBvcHRpb25zLFxuXHQgICAgJ3Nob3J0bWVzc2FnZSc6IHNob3J0bWVzc2FnZVxuXHR9KTtcbn1cblxuLypcbiAqIFNlZSBSRUFETUUubWQgZm9yIHJlZmVyZW5jZSBkb2N1bWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBWRXJyb3IoKVxue1xuXHR2YXIgYXJncywgb2JqLCBwYXJzZWQsIGNhdXNlLCBjdG9yLCBtZXNzYWdlLCBrO1xuXG5cdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG5cdC8qXG5cdCAqIFRoaXMgaXMgYSByZWdyZXR0YWJsZSBwYXR0ZXJuLCBidXQgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIEVycm9yIGNsYXNzXG5cdCAqIGlzIGRlZmluZWQgdG8gd29yayB0aGlzIHdheSwgc28gd2UgYWxsb3cgdGhlIGNvbnN0cnVjdG9yIHRvIGJlIGNhbGxlZFxuXHQgKiB3aXRob3V0IFwibmV3XCIuXG5cdCAqL1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgVkVycm9yKSkge1xuXHRcdG9iaiA9IE9iamVjdC5jcmVhdGUoVkVycm9yLnByb3RvdHlwZSk7XG5cdFx0VkVycm9yLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gKG9iaik7XG5cdH1cblxuXHQvKlxuXHQgKiBGb3IgY29udmVuaWVuY2UgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHNldmVyYWxcblx0ICogZGlmZmVyZW50IGNhbGxpbmcgZm9ybXMuICBOb3JtYWxpemUgdGhlbSBoZXJlLlxuXHQgKi9cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogZmFsc2Vcblx0fSk7XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhIG5hbWUsIGFwcGx5IGl0IG5vdy5cblx0ICovXG5cdGlmIChwYXJzZWQub3B0aW9ucy5uYW1lKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKHBhcnNlZC5vcHRpb25zLm5hbWUsXG5cdFx0ICAgICdlcnJvclxcJ3MgXCJuYW1lXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMubmFtZSA9IHBhcnNlZC5vcHRpb25zLm5hbWU7XG5cdH1cblxuXHQvKlxuXHQgKiBGb3IgZGVidWdnaW5nLCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBzaG9ydCBtZXNzYWdlIChhdHRhY2hlZFxuXHQgKiB0aGlzIEVycm9yIHBhcnRpY3VsYXJseSkgc2VwYXJhdGVseSBmcm9tIHRoZSBjb21wbGV0ZSBtZXNzYWdlICh3aGljaFxuXHQgKiBpbmNsdWRlcyB0aGUgbWVzc2FnZXMgb2Ygb3VyIGNhdXNlIGNoYWluKS5cblx0ICovXG5cdHRoaXMuanNlX3Nob3J0bXNnID0gcGFyc2VkLnNob3J0bWVzc2FnZTtcblx0bWVzc2FnZSA9IHBhcnNlZC5zaG9ydG1lc3NhZ2U7XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNhdXNlLCByZWNvcmQgYSByZWZlcmVuY2UgdG8gaXQgYW5kIHVwZGF0ZSBvdXJcblx0ICogbWVzc2FnZSBhcHByb3ByaWF0ZWx5LlxuXHQgKi9cblx0Y2F1c2UgPSBwYXJzZWQub3B0aW9ucy5jYXVzZTtcblx0aWYgKGNhdXNlKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoY2F1c2UpLCAnY2F1c2UgaXMgbm90IGFuIEVycm9yJyk7XG5cdFx0dGhpcy5qc2VfY2F1c2UgPSBjYXVzZTtcblxuXHRcdGlmICghcGFyc2VkLm9wdGlvbnMuc2tpcENhdXNlTWVzc2FnZSkge1xuXHRcdFx0bWVzc2FnZSArPSAnOiAnICsgY2F1c2UubWVzc2FnZTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHQgKiBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMsIHNoYWxsb3ctY29weSB0aGF0XG5cdCAqIGhlcmUuICBXZSBkb24ndCB3YW50IHRvIHVzZSBhIGRlZXAgY29weSBpbiBjYXNlIHRoZXJlIGFyZSBub24tcGxhaW5cblx0ICogb2JqZWN0cyBoZXJlLCBidXQgd2UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIG9yaWdpbmFsIG9iamVjdCBpbiBjYXNlXG5cdCAqIHRoZSBjYWxsZXIgbW9kaWZpZXMgaXQgbGF0ZXIuXG5cdCAqL1xuXHR0aGlzLmpzZV9pbmZvID0ge307XG5cdGlmIChwYXJzZWQub3B0aW9ucy5pbmZvKSB7XG5cdFx0Zm9yIChrIGluIHBhcnNlZC5vcHRpb25zLmluZm8pIHtcblx0XHRcdHRoaXMuanNlX2luZm9ba10gPSBwYXJzZWQub3B0aW9ucy5pbmZvW2tdO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0Y3RvciA9IHBhcnNlZC5vcHRpb25zLmNvbnN0cnVjdG9yT3B0IHx8IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY3Rvcik7XG5cdH1cblxuXHRyZXR1cm4gKHRoaXMpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhWRXJyb3IsIEVycm9yKTtcblZFcnJvci5wcm90b3R5cGUubmFtZSA9ICdWRXJyb3InO1xuXG5WRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdmVfdG9TdHJpbmcoKVxue1xuXHR2YXIgc3RyID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiB0aGlzLm5hbWUgfHxcblx0XHR0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSk7XG5cdGlmICh0aGlzLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc6ICcgKyB0aGlzLm1lc3NhZ2U7XG5cblx0cmV0dXJuIChzdHIpO1xufTtcblxuLypcbiAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGZvciBjb21wYXRpYmlsaXR5LiAgTmV3IGNhbGxlcnMgc2hvdWxkIHVzZVxuICogVkVycm9yLmNhdXNlKCkgaW5zdGVhZC4gIFRoYXQgbWV0aG9kIGFsc28gdXNlcyB0aGUgc2FuZXIgYG51bGxgIHJldHVybiB2YWx1ZVxuICogd2hlbiB0aGVyZSBpcyBubyBjYXVzZS5cbiAqL1xuVkVycm9yLnByb3RvdHlwZS5jYXVzZSA9IGZ1bmN0aW9uIHZlX2NhdXNlKClcbntcblx0dmFyIGNhdXNlID0gVkVycm9yLmNhdXNlKHRoaXMpO1xuXHRyZXR1cm4gKGNhdXNlID09PSBudWxsID8gdW5kZWZpbmVkIDogY2F1c2UpO1xufTtcblxuLypcbiAqIFN0YXRpYyBtZXRob2RzXG4gKlxuICogVGhlc2UgY2xhc3MtbGV2ZWwgbWV0aG9kcyBhcmUgcHJvdmlkZWQgc28gdGhhdCBjYWxsZXJzIGNhbiB1c2UgdGhlbSBvblxuICogaW5zdGFuY2VzIG9mIEVycm9ycyB0aGF0IGFyZSBub3QgVkVycm9ycy4gIE5ldyBpbnRlcmZhY2VzIHNob3VsZCBiZSBwcm92aWRlZFxuICogb25seSB1c2luZyBzdGF0aWMgbWV0aG9kcyB0byBlbGltaW5hdGUgdGhlIGNsYXNzIG9mIHByb2dyYW1taW5nIG1pc3Rha2Ugd2hlcmVcbiAqIHBlb3BsZSBmYWlsIHRvIGNoZWNrIHdoZXRoZXIgdGhlIEVycm9yIG9iamVjdCBoYXMgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcy5cbiAqL1xuXG5WRXJyb3IuY2F1c2UgPSBmdW5jdGlvbiAoZXJyKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0cmV0dXJuIChtb2RfaXNFcnJvcihlcnIuanNlX2NhdXNlKSA/IGVyci5qc2VfY2F1c2UgOiBudWxsKTtcbn07XG5cblZFcnJvci5pbmZvID0gZnVuY3Rpb24gKGVycilcbntcblx0dmFyIHJ2LCBjYXVzZSwgaztcblxuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0Y2F1c2UgPSBWRXJyb3IuY2F1c2UoZXJyKTtcblx0aWYgKGNhdXNlICE9PSBudWxsKSB7XG5cdFx0cnYgPSBWRXJyb3IuaW5mbyhjYXVzZSk7XG5cdH0gZWxzZSB7XG5cdFx0cnYgPSB7fTtcblx0fVxuXG5cdGlmICh0eXBlb2YgKGVyci5qc2VfaW5mbykgPT0gJ29iamVjdCcgJiYgZXJyLmpzZV9pbmZvICE9PSBudWxsKSB7XG5cdFx0Zm9yIChrIGluIGVyci5qc2VfaW5mbykge1xuXHRcdFx0cnZba10gPSBlcnIuanNlX2luZm9ba107XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChydik7XG59O1xuXG5WRXJyb3IuZmluZENhdXNlQnlOYW1lID0gZnVuY3Rpb24gKGVyciwgbmFtZSlcbntcblx0dmFyIGNhdXNlO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXHRtb2RfYXNzZXJ0cGx1cy5zdHJpbmcobmFtZSwgJ25hbWUnKTtcblx0bW9kX2Fzc2VydHBsdXMub2sobmFtZS5sZW5ndGggPiAwLCAnbmFtZSBjYW5ub3QgYmUgZW1wdHknKTtcblxuXHRmb3IgKGNhdXNlID0gZXJyOyBjYXVzZSAhPT0gbnVsbDsgY2F1c2UgPSBWRXJyb3IuY2F1c2UoY2F1c2UpKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoY2F1c2UpKTtcblx0XHRpZiAoY2F1c2UubmFtZSA9PSBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gKGNhdXNlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKG51bGwpO1xufTtcblxuVkVycm9yLmhhc0NhdXNlV2l0aE5hbWUgPSBmdW5jdGlvbiAoZXJyLCBuYW1lKVxue1xuXHRyZXR1cm4gKFZFcnJvci5maW5kQ2F1c2VCeU5hbWUoZXJyLCBuYW1lKSAhPT0gbnVsbCk7XG59O1xuXG5WRXJyb3IuZnVsbFN0YWNrID0gZnVuY3Rpb24gKGVycilcbntcblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cblx0dmFyIGNhdXNlID0gVkVycm9yLmNhdXNlKGVycik7XG5cblx0aWYgKGNhdXNlKSB7XG5cdFx0cmV0dXJuIChlcnIuc3RhY2sgKyAnXFxuY2F1c2VkIGJ5OiAnICsgVkVycm9yLmZ1bGxTdGFjayhjYXVzZSkpO1xuXHR9XG5cblx0cmV0dXJuIChlcnIuc3RhY2spO1xufTtcblxuVkVycm9yLmVycm9yRnJvbUxpc3QgPSBmdW5jdGlvbiAoZXJyb3JzKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5hcnJheU9mT2JqZWN0KGVycm9ycywgJ2Vycm9ycycpO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIChudWxsKTtcblx0fVxuXG5cdGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZSkpO1xuXHR9KTtcblxuXHRpZiAoZXJyb3JzLmxlbmd0aCA9PSAxKSB7XG5cdFx0cmV0dXJuIChlcnJvcnNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIChuZXcgTXVsdGlFcnJvcihlcnJvcnMpKTtcbn07XG5cblZFcnJvci5lcnJvckZvckVhY2ggPSBmdW5jdGlvbiAoZXJyLCBmdW5jKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0bW9kX2Fzc2VydHBsdXMuZnVuYyhmdW5jLCAnZnVuYycpO1xuXG5cdGlmIChlcnIgaW5zdGFuY2VvZiBNdWx0aUVycm9yKSB7XG5cdFx0ZXJyLmVycm9ycygpLmZvckVhY2goZnVuY3Rpb24gaXRlckVycm9yKGUpIHsgZnVuYyhlKTsgfSk7XG5cdH0gZWxzZSB7XG5cdFx0ZnVuYyhlcnIpO1xuXHR9XG59O1xuXG5cbi8qXG4gKiBTRXJyb3IgaXMgbGlrZSBWRXJyb3IsIGJ1dCBzdHJpY3RlciBhYm91dCB0eXBlcy4gIFlvdSBjYW5ub3QgcGFzcyBcIm51bGxcIiBvclxuICogXCJ1bmRlZmluZWRcIiBhcyBzdHJpbmcgYXJndW1lbnRzIHRvIHRoZSBmb3JtYXR0ZXIuXG4gKi9cbmZ1bmN0aW9uIFNFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgb3B0aW9ucztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFNFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFNFcnJvci5wcm90b3R5cGUpO1xuXHRcdFNFcnJvci5hcHBseShvYmosIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIChvYmopO1xuXHR9XG5cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogdHJ1ZVxuXHR9KTtcblxuXHRvcHRpb25zID0gcGFyc2VkLm9wdGlvbnM7XG5cdFZFcnJvci5jYWxsKHRoaXMsIG9wdGlvbnMsICclcycsIHBhcnNlZC5zaG9ydG1lc3NhZ2UpO1xuXG5cdHJldHVybiAodGhpcyk7XG59XG5cbi8qXG4gKiBXZSBkb24ndCBib3RoZXIgc2V0dGluZyBTRXJyb3IucHJvdG90eXBlLm5hbWUgYmVjYXVzZSBvbmNlIGNvbnN0cnVjdGVkLFxuICogU0Vycm9ycyBhcmUganVzdCBsaWtlIFZFcnJvcnMuXG4gKi9cbm1vZF91dGlsLmluaGVyaXRzKFNFcnJvciwgVkVycm9yKTtcblxuXG4vKlxuICogUmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgZXJyb3JzIGZvciB0aGUgcHVycG9zZSBvZiBjb25zdW1lcnMgdGhhdCBnZW5lcmFsbHlcbiAqIG9ubHkgZGVhbCB3aXRoIG9uZSBlcnJvci4gIENhbGxlcnMgY2FuIGV4dHJhY3QgdGhlIGluZGl2aWR1YWwgZXJyb3JzXG4gKiBjb250YWluZWQgaW4gdGhpcyBvYmplY3QsIGJ1dCBtYXkgYWxzbyBqdXN0IHRyZWF0IGl0IGFzIGEgbm9ybWFsIHNpbmdsZVxuICogZXJyb3IsIGluIHdoaWNoIGNhc2UgYSBzdW1tYXJ5IG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkLlxuICovXG5mdW5jdGlvbiBNdWx0aUVycm9yKGVycm9ycylcbntcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXkoZXJyb3JzLCAnbGlzdCBvZiBlcnJvcnMnKTtcblx0bW9kX2Fzc2VydHBsdXMub2soZXJyb3JzLmxlbmd0aCA+IDAsICdtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvcicpO1xuXHR0aGlzLmFzZV9lcnJvcnMgPSBlcnJvcnM7XG5cblx0VkVycm9yLmNhbGwodGhpcywge1xuXHQgICAgJ2NhdXNlJzogZXJyb3JzWzBdXG5cdH0sICdmaXJzdCBvZiAlZCBlcnJvciVzJywgZXJyb3JzLmxlbmd0aCwgZXJyb3JzLmxlbmd0aCA9PSAxID8gJycgOiAncycpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhNdWx0aUVycm9yLCBWRXJyb3IpO1xuTXVsdGlFcnJvci5wcm90b3R5cGUubmFtZSA9ICdNdWx0aUVycm9yJztcblxuTXVsdGlFcnJvci5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24gbWVfZXJyb3JzKClcbntcblx0cmV0dXJuICh0aGlzLmFzZV9lcnJvcnMuc2xpY2UoMCkpO1xufTtcblxuXG4vKlxuICogU2VlIFJFQURNRS5tZCBmb3IgcmVmZXJlbmNlIGRldGFpbHMuXG4gKi9cbmZ1bmN0aW9uIFdFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgb3B0aW9ucztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFdFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFdFcnJvci5wcm90b3R5cGUpO1xuXHRcdFdFcnJvci5hcHBseShvYmosIGFyZ3MpO1xuXHRcdHJldHVybiAob2JqKTtcblx0fVxuXG5cdHBhcnNlZCA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoe1xuXHQgICAgJ2FyZ3YnOiBhcmdzLFxuXHQgICAgJ3N0cmljdCc6IGZhbHNlXG5cdH0pO1xuXG5cdG9wdGlvbnMgPSBwYXJzZWQub3B0aW9ucztcblx0b3B0aW9uc1snc2tpcENhdXNlTWVzc2FnZSddID0gdHJ1ZTtcblx0VkVycm9yLmNhbGwodGhpcywgb3B0aW9ucywgJyVzJywgcGFyc2VkLnNob3J0bWVzc2FnZSk7XG5cblx0cmV0dXJuICh0aGlzKTtcbn1cblxubW9kX3V0aWwuaW5oZXJpdHMoV0Vycm9yLCBWRXJyb3IpO1xuV0Vycm9yLnByb3RvdHlwZS5uYW1lID0gJ1dFcnJvcic7XG5cbldFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB3ZV90b1N0cmluZygpXG57XG5cdHZhciBzdHIgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpICYmIHRoaXMubmFtZSB8fFxuXHRcdHRoaXMuY29uc3RydWN0b3IubmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5uYW1lKTtcblx0aWYgKHRoaXMubWVzc2FnZSlcblx0XHRzdHIgKz0gJzogJyArIHRoaXMubWVzc2FnZTtcblx0aWYgKHRoaXMuanNlX2NhdXNlICYmIHRoaXMuanNlX2NhdXNlLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc7IGNhdXNlZCBieSAnICsgdGhpcy5qc2VfY2F1c2UudG9TdHJpbmcoKTtcblxuXHRyZXR1cm4gKHN0cik7XG59O1xuXG4vKlxuICogRm9yIHB1cmVseSBoaXN0b3JpY2FsIHJlYXNvbnMsIFdFcnJvcidzIGNhdXNlKCkgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXRcbiAqIHRoZSBjYXVzZS5cbiAqL1xuV0Vycm9yLnByb3RvdHlwZS5jYXVzZSA9IGZ1bmN0aW9uIHdlX2NhdXNlKGMpXG57XG5cdGlmIChtb2RfaXNFcnJvcihjKSlcblx0XHR0aGlzLmpzZV9jYXVzZSA9IGM7XG5cblx0cmV0dXJuICh0aGlzLmpzZV9jYXVzZSk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZF9hc3NlcnRwbHVzIiwicmVxdWlyZSIsIm1vZF91dGlsIiwibW9kX2V4dHNwcmludGYiLCJtb2RfaXNFcnJvciIsImlzRXJyb3IiLCJzcHJpbnRmIiwibW9kdWxlIiwiZXhwb3J0cyIsIlZFcnJvciIsIlNFcnJvciIsIldFcnJvciIsIk11bHRpRXJyb3IiLCJwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzIiwiYXJncyIsImFyZ3YiLCJvcHRpb25zIiwic3ByaW50Zl9hcmdzIiwic2hvcnRtZXNzYWdlIiwiayIsIm9iamVjdCIsImJvb2wiLCJzdHJpY3QiLCJhcnJheSIsImxlbmd0aCIsInNsaWNlIiwic3RyaW5nIiwibWFwIiwiYSIsInVuZGVmaW5lZCIsImFwcGx5Iiwib2JqIiwicGFyc2VkIiwiY2F1c2UiLCJjdG9yIiwibWVzc2FnZSIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsImFyZ3VtZW50cyIsIk9iamVjdCIsImNyZWF0ZSIsIm5hbWUiLCJqc2Vfc2hvcnRtc2ciLCJvayIsImpzZV9jYXVzZSIsInNraXBDYXVzZU1lc3NhZ2UiLCJqc2VfaW5mbyIsImluZm8iLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiY29uc3RydWN0b3JPcHQiLCJjb25zdHJ1Y3RvciIsImluaGVyaXRzIiwidG9TdHJpbmciLCJ2ZV90b1N0cmluZyIsInN0ciIsImhhc093blByb3BlcnR5IiwidmVfY2F1c2UiLCJlcnIiLCJydiIsImZpbmRDYXVzZUJ5TmFtZSIsImhhc0NhdXNlV2l0aE5hbWUiLCJmdWxsU3RhY2siLCJzdGFjayIsImVycm9yRnJvbUxpc3QiLCJlcnJvcnMiLCJhcnJheU9mT2JqZWN0IiwiZm9yRWFjaCIsImUiLCJlcnJvckZvckVhY2giLCJmdW5jIiwiaXRlckVycm9yIiwiYXNlX2Vycm9ycyIsIm1lX2Vycm9ycyIsIndlX3RvU3RyaW5nIiwid2VfY2F1c2UiLCJjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/verror/lib/verror.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/verror/lib/verror.js":
/*!*******************************************!*\
  !*** ./node_modules/verror/lib/verror.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * verror.js: richer JavaScript errors\n */ \nvar mod_assertplus = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\nvar mod_extsprintf = __webpack_require__(/*! extsprintf */ \"(rsc)/./node_modules/extsprintf/lib/extsprintf.js\");\nvar mod_isError = (__webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\").isError);\nvar sprintf = mod_extsprintf.sprintf;\n/*\n * Public interface\n */ /* So you can 'var VError = require('verror')' */ module.exports = VError;\n/* For compatibility */ VError.VError = VError;\n/* Other exported classes */ VError.SError = SError;\nVError.WError = WError;\nVError.MultiError = MultiError;\n/*\n * Common function used to parse constructor arguments for VError, WError, and\n * SError.  Named arguments to this function:\n *\n *     strict\t\tforce strict interpretation of sprintf arguments, even\n *     \t\t\tif the options in \"argv\" don't say so\n *\n *     argv\t\terror's constructor arguments, which are to be\n *     \t\t\tinterpreted as described in README.md.  For quick\n *     \t\t\treference, \"argv\" has one of the following forms:\n *\n *          [ sprintf_args... ]           (argv[0] is a string)\n *          [ cause, sprintf_args... ]    (argv[0] is an Error)\n *          [ options, sprintf_args... ]  (argv[0] is an object)\n *\n * This function normalizes these forms, producing an object with the following\n * properties:\n *\n *    options           equivalent to \"options\" in third form.  This will never\n *    \t\t\tbe a direct reference to what the caller passed in\n *    \t\t\t(i.e., it may be a shallow copy), so it can be freely\n *    \t\t\tmodified.\n *\n *    shortmessage      result of sprintf(sprintf_args), taking options.strict\n *    \t\t\tinto account as described in README.md.\n */ function parseConstructorArguments(args) {\n    var argv, options, sprintf_args, shortmessage, k;\n    mod_assertplus.object(args, \"args\");\n    mod_assertplus.bool(args.strict, \"args.strict\");\n    mod_assertplus.array(args.argv, \"args.argv\");\n    argv = args.argv;\n    /*\n\t * First, figure out which form of invocation we've been given.\n\t */ if (argv.length === 0) {\n        options = {};\n        sprintf_args = [];\n    } else if (mod_isError(argv[0])) {\n        options = {\n            \"cause\": argv[0]\n        };\n        sprintf_args = argv.slice(1);\n    } else if (typeof argv[0] === \"object\") {\n        options = {};\n        for(k in argv[0]){\n            options[k] = argv[0][k];\n        }\n        sprintf_args = argv.slice(1);\n    } else {\n        mod_assertplus.string(argv[0], \"first argument to VError, SError, or WError \" + \"constructor must be a string, object, or Error\");\n        options = {};\n        sprintf_args = argv;\n    }\n    /*\n\t * Now construct the error's message.\n\t *\n\t * extsprintf (which we invoke here with our caller's arguments in order\n\t * to construct this Error's message) is strict in its interpretation of\n\t * values to be processed by the \"%s\" specifier.  The value passed to\n\t * extsprintf must actually be a string or something convertible to a\n\t * String using .toString().  Passing other values (notably \"null\" and\n\t * \"undefined\") is considered a programmer error.  The assumption is\n\t * that if you actually want to print the string \"null\" or \"undefined\",\n\t * then that's easy to do that when you're calling extsprintf; on the\n\t * other hand, if you did NOT want that (i.e., there's actually a bug\n\t * where the program assumes some variable is non-null and tries to\n\t * print it, which might happen when constructing a packet or file in\n\t * some specific format), then it's better to stop immediately than\n\t * produce bogus output.\n\t *\n\t * However, sometimes the bug is only in the code calling VError, and a\n\t * programmer might prefer to have the error message contain \"null\" or\n\t * \"undefined\" rather than have the bug in the error path crash the\n\t * program (making the first bug harder to identify).  For that reason,\n\t * by default VError converts \"null\" or \"undefined\" arguments to their\n\t * string representations and passes those to extsprintf.  Programmers\n\t * desiring the strict behavior can use the SError class or pass the\n\t * \"strict\" option to the VError constructor.\n\t */ mod_assertplus.object(options);\n    if (!options.strict && !args.strict) {\n        sprintf_args = sprintf_args.map(function(a) {\n            return a === null ? \"null\" : a === undefined ? \"undefined\" : a;\n        });\n    }\n    if (sprintf_args.length === 0) {\n        shortmessage = \"\";\n    } else {\n        shortmessage = sprintf.apply(null, sprintf_args);\n    }\n    return {\n        \"options\": options,\n        \"shortmessage\": shortmessage\n    };\n}\n/*\n * See README.md for reference documentation.\n */ function VError() {\n    var args, obj, parsed, cause, ctor, message, k;\n    args = Array.prototype.slice.call(arguments, 0);\n    /*\n\t * This is a regrettable pattern, but JavaScript's built-in Error class\n\t * is defined to work this way, so we allow the constructor to be called\n\t * without \"new\".\n\t */ if (!(this instanceof VError)) {\n        obj = Object.create(VError.prototype);\n        VError.apply(obj, arguments);\n        return obj;\n    }\n    /*\n\t * For convenience and backwards compatibility, we support several\n\t * different calling forms.  Normalize them here.\n\t */ parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": false\n    });\n    /*\n\t * If we've been given a name, apply it now.\n\t */ if (parsed.options.name) {\n        mod_assertplus.string(parsed.options.name, 'error\\'s \"name\" must be a string');\n        this.name = parsed.options.name;\n    }\n    /*\n\t * For debugging, we keep track of the original short message (attached\n\t * this Error particularly) separately from the complete message (which\n\t * includes the messages of our cause chain).\n\t */ this.jse_shortmsg = parsed.shortmessage;\n    message = parsed.shortmessage;\n    /*\n\t * If we've been given a cause, record a reference to it and update our\n\t * message appropriately.\n\t */ cause = parsed.options.cause;\n    if (cause) {\n        mod_assertplus.ok(mod_isError(cause), \"cause is not an Error\");\n        this.jse_cause = cause;\n        if (!parsed.options.skipCauseMessage) {\n            message += \": \" + cause.message;\n        }\n    }\n    /*\n\t * If we've been given an object with properties, shallow-copy that\n\t * here.  We don't want to use a deep copy in case there are non-plain\n\t * objects here, but we don't want to use the original object in case\n\t * the caller modifies it later.\n\t */ this.jse_info = {};\n    if (parsed.options.info) {\n        for(k in parsed.options.info){\n            this.jse_info[k] = parsed.options.info[k];\n        }\n    }\n    this.message = message;\n    Error.call(this, message);\n    if (Error.captureStackTrace) {\n        ctor = parsed.options.constructorOpt || this.constructor;\n        Error.captureStackTrace(this, ctor);\n    }\n    return this;\n}\nmod_util.inherits(VError, Error);\nVError.prototype.name = \"VError\";\nVError.prototype.toString = function ve_toString() {\n    var str = this.hasOwnProperty(\"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n    if (this.message) str += \": \" + this.message;\n    return str;\n};\n/*\n * This method is provided for compatibility.  New callers should use\n * VError.cause() instead.  That method also uses the saner `null` return value\n * when there is no cause.\n */ VError.prototype.cause = function ve_cause() {\n    var cause = VError.cause(this);\n    return cause === null ? undefined : cause;\n};\n/*\n * Static methods\n *\n * These class-level methods are provided so that callers can use them on\n * instances of Errors that are not VErrors.  New interfaces should be provided\n * only using static methods to eliminate the class of programming mistake where\n * people fail to check whether the Error object has the corresponding methods.\n */ VError.cause = function(err) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    return mod_isError(err.jse_cause) ? err.jse_cause : null;\n};\nVError.info = function(err) {\n    var rv, cause, k;\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    cause = VError.cause(err);\n    if (cause !== null) {\n        rv = VError.info(cause);\n    } else {\n        rv = {};\n    }\n    if (typeof err.jse_info == \"object\" && err.jse_info !== null) {\n        for(k in err.jse_info){\n            rv[k] = err.jse_info[k];\n        }\n    }\n    return rv;\n};\nVError.findCauseByName = function(err, name) {\n    var cause;\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    mod_assertplus.string(name, \"name\");\n    mod_assertplus.ok(name.length > 0, \"name cannot be empty\");\n    for(cause = err; cause !== null; cause = VError.cause(cause)){\n        mod_assertplus.ok(mod_isError(cause));\n        if (cause.name == name) {\n            return cause;\n        }\n    }\n    return null;\n};\nVError.hasCauseWithName = function(err, name) {\n    return VError.findCauseByName(err, name) !== null;\n};\nVError.fullStack = function(err) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    var cause = VError.cause(err);\n    if (cause) {\n        return err.stack + \"\\ncaused by: \" + VError.fullStack(cause);\n    }\n    return err.stack;\n};\nVError.errorFromList = function(errors) {\n    mod_assertplus.arrayOfObject(errors, \"errors\");\n    if (errors.length === 0) {\n        return null;\n    }\n    errors.forEach(function(e) {\n        mod_assertplus.ok(mod_isError(e));\n    });\n    if (errors.length == 1) {\n        return errors[0];\n    }\n    return new MultiError(errors);\n};\nVError.errorForEach = function(err, func) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    mod_assertplus.func(func, \"func\");\n    if (err instanceof MultiError) {\n        err.errors().forEach(function iterError(e) {\n            func(e);\n        });\n    } else {\n        func(err);\n    }\n};\n/*\n * SError is like VError, but stricter about types.  You cannot pass \"null\" or\n * \"undefined\" as string arguments to the formatter.\n */ function SError() {\n    var args, obj, parsed, options;\n    args = Array.prototype.slice.call(arguments, 0);\n    if (!(this instanceof SError)) {\n        obj = Object.create(SError.prototype);\n        SError.apply(obj, arguments);\n        return obj;\n    }\n    parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": true\n    });\n    options = parsed.options;\n    VError.call(this, options, \"%s\", parsed.shortmessage);\n    return this;\n}\n/*\n * We don't bother setting SError.prototype.name because once constructed,\n * SErrors are just like VErrors.\n */ mod_util.inherits(SError, VError);\n/*\n * Represents a collection of errors for the purpose of consumers that generally\n * only deal with one error.  Callers can extract the individual errors\n * contained in this object, but may also just treat it as a normal single\n * error, in which case a summary message will be printed.\n */ function MultiError(errors) {\n    mod_assertplus.array(errors, \"list of errors\");\n    mod_assertplus.ok(errors.length > 0, \"must be at least one error\");\n    this.ase_errors = errors;\n    VError.call(this, {\n        \"cause\": errors[0]\n    }, \"first of %d error%s\", errors.length, errors.length == 1 ? \"\" : \"s\");\n}\nmod_util.inherits(MultiError, VError);\nMultiError.prototype.name = \"MultiError\";\nMultiError.prototype.errors = function me_errors() {\n    return this.ase_errors.slice(0);\n};\n/*\n * See README.md for reference details.\n */ function WError() {\n    var args, obj, parsed, options;\n    args = Array.prototype.slice.call(arguments, 0);\n    if (!(this instanceof WError)) {\n        obj = Object.create(WError.prototype);\n        WError.apply(obj, args);\n        return obj;\n    }\n    parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": false\n    });\n    options = parsed.options;\n    options[\"skipCauseMessage\"] = true;\n    VError.call(this, options, \"%s\", parsed.shortmessage);\n    return this;\n}\nmod_util.inherits(WError, VError);\nWError.prototype.name = \"WError\";\nWError.prototype.toString = function we_toString() {\n    var str = this.hasOwnProperty(\"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n    if (this.message) str += \": \" + this.message;\n    if (this.jse_cause && this.jse_cause.message) str += \"; caused by \" + this.jse_cause.toString();\n    return str;\n};\n/*\n * For purely historical reasons, WError's cause() function allows you to set\n * the cause.\n */ WError.prototype.cause = function we_cause(c) {\n    if (mod_isError(c)) this.jse_cause = c;\n    return this.jse_cause;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdmVycm9yL2xpYi92ZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7QUFFRCxJQUFJQSxpQkFBaUJDLG1CQUFPQSxDQUFDO0FBQzdCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCLElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUcsY0FBY0gsa0dBQStCO0FBQ2pELElBQUlLLFVBQVVILGVBQWVHLE9BQU87QUFFcEM7O0NBRUMsR0FFRCwrQ0FBK0MsR0FDL0NDLE9BQU9DLE9BQU8sR0FBR0M7QUFDakIscUJBQXFCLEdBQ3JCQSxPQUFPQSxNQUFNLEdBQUdBO0FBQ2hCLDBCQUEwQixHQUMxQkEsT0FBT0MsTUFBTSxHQUFHQTtBQUNoQkQsT0FBT0UsTUFBTSxHQUFHQTtBQUNoQkYsT0FBT0csVUFBVSxHQUFHQTtBQUVwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELFNBQVNDLDBCQUEwQkMsSUFBSTtJQUV0QyxJQUFJQyxNQUFNQyxTQUFTQyxjQUFjQyxjQUFjQztJQUUvQ25CLGVBQWVvQixNQUFNLENBQUNOLE1BQU07SUFDNUJkLGVBQWVxQixJQUFJLENBQUNQLEtBQUtRLE1BQU0sRUFBRTtJQUNqQ3RCLGVBQWV1QixLQUFLLENBQUNULEtBQUtDLElBQUksRUFBRTtJQUNoQ0EsT0FBT0QsS0FBS0MsSUFBSTtJQUVoQjs7RUFFQyxHQUNELElBQUlBLEtBQUtTLE1BQU0sS0FBSyxHQUFHO1FBQ3RCUixVQUFVLENBQUM7UUFDWEMsZUFBZSxFQUFFO0lBQ2xCLE9BQU8sSUFBSWIsWUFBWVcsSUFBSSxDQUFDLEVBQUUsR0FBRztRQUNoQ0MsVUFBVTtZQUFFLFNBQVNELElBQUksQ0FBQyxFQUFFO1FBQUM7UUFDN0JFLGVBQWVGLEtBQUtVLEtBQUssQ0FBQztJQUMzQixPQUFPLElBQUksT0FBUVYsSUFBSSxDQUFDLEVBQUUsS0FBTSxVQUFVO1FBQ3pDQyxVQUFVLENBQUM7UUFDWCxJ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UUFBUSxHQUFHLFNBQVNxQjtJQUVwQyxJQUFJbkIsTUFBTyxJQUFJLENBQUNDLGNBQWMsQ0FBQyxXQUFXLElBQUksQ0FBQ2YsSUFBSSxJQUNsRCxJQUFJLENBQUNVLFdBQVcsQ0FBQ1YsSUFBSSxJQUFJLElBQUksQ0FBQ1UsV0FBVyxDQUFDZixTQUFTLENBQUNLLElBQUk7SUFDekQsSUFBSSxJQUFJLENBQUNQLE9BQU8sRUFDZnFCLE9BQU8sT0FBTyxJQUFJLENBQUNyQixPQUFPO0lBQzNCLElBQUksSUFBSSxDQUFDVSxTQUFTLElBQUksSUFBSSxDQUFDQSxTQUFTLENBQUNWLE9BQU8sRUFDM0NxQixPQUFPLGlCQUFpQixJQUFJLENBQUNYLFNBQVMsQ0FBQ1MsUUFBUTtJQUVoRCxPQUFRRTtBQUNUO0FBRUE7OztDQUdDLEdBQ0Q3QyxPQUFPMEIsU0FBUyxDQUFDSixLQUFLLEdBQUcsU0FBUzJDLFNBQVNDLENBQUM7SUFFM0MsSUFBSXpFLFlBQVl5RSxJQUNmLElBQUksQ0FBQ2hDLFNBQVMsR0FBR2dDO0lBRWxCLE9BQVEsSUFBSSxDQUFDaEMsU0FBUztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL3ZlcnJvci9saWIvdmVycm9yLmpzP2YwYTYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIHZlcnJvci5qczogcmljaGVyIEphdmFTY3JpcHQgZXJyb3JzXG4gKi9cblxudmFyIG1vZF9hc3NlcnRwbHVzID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBtb2RfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIG1vZF9leHRzcHJpbnRmID0gcmVxdWlyZSgnZXh0c3ByaW50ZicpO1xudmFyIG1vZF9pc0Vycm9yID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJykuaXNFcnJvcjtcbnZhciBzcHJpbnRmID0gbW9kX2V4dHNwcmludGYuc3ByaW50ZjtcblxuLypcbiAqIFB1YmxpYyBpbnRlcmZhY2VcbiAqL1xuXG4vKiBTbyB5b3UgY2FuICd2YXIgVkVycm9yID0gcmVxdWlyZSgndmVycm9yJyknICovXG5tb2R1bGUuZXhwb3J0cyA9IFZFcnJvcjtcbi8qIEZvciBjb21wYXRpYmlsaXR5ICovXG5WRXJyb3IuVkVycm9yID0gVkVycm9yO1xuLyogT3RoZXIgZXhwb3J0ZWQgY2xhc3NlcyAqL1xuVkVycm9yLlNFcnJvciA9IFNFcnJvcjtcblZFcnJvci5XRXJyb3IgPSBXRXJyb3I7XG5WRXJyb3IuTXVsdGlFcnJvciA9IE11bHRpRXJyb3I7XG5cbi8qXG4gKiBDb21tb24gZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMgZm9yIFZFcnJvciwgV0Vycm9yLCBhbmRcbiAqIFNFcnJvci4gIE5hbWVkIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uOlxuICpcbiAqICAgICBzdHJpY3RcdFx0Zm9yY2Ugc3RyaWN0IGludGVycHJldGF0aW9uIG9mIHNwcmludGYgYXJndW1lbnRzLCBldmVuXG4gKiAgICAgXHRcdFx0aWYgdGhlIG9wdGlvbnMgaW4gXCJhcmd2XCIgZG9uJ3Qgc2F5IHNvXG4gKlxuICogICAgIGFyZ3ZcdFx0ZXJyb3IncyBjb25zdHJ1Y3RvciBhcmd1bWVudHMsIHdoaWNoIGFyZSB0byBiZVxuICogICAgIFx0XHRcdGludGVycHJldGVkIGFzIGRlc2NyaWJlZCBpbiBSRUFETUUubWQuICBGb3IgcXVpY2tcbiAqICAgICBcdFx0XHRyZWZlcmVuY2UsIFwiYXJndlwiIGhhcyBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqXG4gKiAgICAgICAgICBbIHNwcmludGZfYXJncy4uLiBdICAgICAgICAgICAoYXJndlswXSBpcyBhIHN0cmluZylcbiAqICAgICAgICAgIFsgY2F1c2UsIHNwcmludGZfYXJncy4uLiBdICAgIChhcmd2WzBdIGlzIGFuIEVycm9yKVxuICogICAgICAgICAgWyBvcHRpb25zLCBzcHJpbnRmX2FyZ3MuLi4gXSAgKGFyZ3ZbMF0gaXMgYW4gb2JqZWN0KVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplcyB0aGVzZSBmb3JtcywgcHJvZHVjaW5nIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAgb3B0aW9ucyAgICAgICAgICAgZXF1aXZhbGVudCB0byBcIm9wdGlvbnNcIiBpbiB0aGlyZCBmb3JtLiAgVGhpcyB3aWxsIG5ldmVyXG4gKiAgICBcdFx0XHRiZSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gd2hhdCB0aGUgY2FsbGVyIHBhc3NlZCBpblxuICogICAgXHRcdFx0KGkuZS4sIGl0IG1heSBiZSBhIHNoYWxsb3cgY29weSksIHNvIGl0IGNhbiBiZSBmcmVlbHlcbiAqICAgIFx0XHRcdG1vZGlmaWVkLlxuICpcbiAqICAgIHNob3J0bWVzc2FnZSAgICAgIHJlc3VsdCBvZiBzcHJpbnRmKHNwcmludGZfYXJncyksIHRha2luZyBvcHRpb25zLnN0cmljdFxuICogICAgXHRcdFx0aW50byBhY2NvdW50IGFzIGRlc2NyaWJlZCBpbiBSRUFETUUubWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoYXJncylcbntcblx0dmFyIGFyZ3YsIG9wdGlvbnMsIHNwcmludGZfYXJncywgc2hvcnRtZXNzYWdlLCBrO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9iamVjdChhcmdzLCAnYXJncycpO1xuXHRtb2RfYXNzZXJ0cGx1cy5ib29sKGFyZ3Muc3RyaWN0LCAnYXJncy5zdHJpY3QnKTtcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXkoYXJncy5hcmd2LCAnYXJncy5hcmd2Jyk7XG5cdGFyZ3YgPSBhcmdzLmFyZ3Y7XG5cblx0Lypcblx0ICogRmlyc3QsIGZpZ3VyZSBvdXQgd2hpY2ggZm9ybSBvZiBpbnZvY2F0aW9uIHdlJ3ZlIGJlZW4gZ2l2ZW4uXG5cdCAqL1xuXHRpZiAoYXJndi5sZW5ndGggPT09IDApIHtcblx0XHRvcHRpb25zID0ge307XG5cdFx0c3ByaW50Zl9hcmdzID0gW107XG5cdH0gZWxzZSBpZiAobW9kX2lzRXJyb3IoYXJndlswXSkpIHtcblx0XHRvcHRpb25zID0geyAnY2F1c2UnOiBhcmd2WzBdIH07XG5cdFx0c3ByaW50Zl9hcmdzID0gYXJndi5zbGljZSgxKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgKGFyZ3ZbMF0pID09PSAnb2JqZWN0Jykge1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRmb3IgKGsgaW4gYXJndlswXSkge1xuXHRcdFx0b3B0aW9uc1trXSA9IGFyZ3ZbMF1ba107XG5cdFx0fVxuXHRcdHNwcmludGZfYXJncyA9IGFyZ3Yuc2xpY2UoMSk7XG5cdH0gZWxzZSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKGFyZ3ZbMF0sXG5cdFx0ICAgICdmaXJzdCBhcmd1bWVudCB0byBWRXJyb3IsIFNFcnJvciwgb3IgV0Vycm9yICcgK1xuXHRcdCAgICAnY29uc3RydWN0b3IgbXVzdCBiZSBhIHN0cmluZywgb2JqZWN0LCBvciBFcnJvcicpO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRzcHJpbnRmX2FyZ3MgPSBhcmd2O1xuXHR9XG5cblx0Lypcblx0ICogTm93IGNvbnN0cnVjdCB0aGUgZXJyb3IncyBtZXNzYWdlLlxuXHQgKlxuXHQgKiBleHRzcHJpbnRmICh3aGljaCB3ZSBpbnZva2UgaGVyZSB3aXRoIG91ciBjYWxsZXIncyBhcmd1bWVudHMgaW4gb3JkZXJcblx0ICogdG8gY29uc3RydWN0IHRoaXMgRXJyb3IncyBtZXNzYWdlKSBpcyBzdHJpY3QgaW4gaXRzIGludGVycHJldGF0aW9uIG9mXG5cdCAqIHZhbHVlcyB0byBiZSBwcm9jZXNzZWQgYnkgdGhlIFwiJXNcIiBzcGVjaWZpZXIuICBUaGUgdmFsdWUgcGFzc2VkIHRvXG5cdCAqIGV4dHNwcmludGYgbXVzdCBhY3R1YWxseSBiZSBhIHN0cmluZyBvciBzb21ldGhpbmcgY29udmVydGlibGUgdG8gYVxuXHQgKiBTdHJpbmcgdXNpbmcgLnRvU3RyaW5nKCkuICBQYXNzaW5nIG90aGVyIHZhbHVlcyAobm90YWJseSBcIm51bGxcIiBhbmRcblx0ICogXCJ1bmRlZmluZWRcIikgaXMgY29uc2lkZXJlZCBhIHByb2dyYW1tZXIgZXJyb3IuICBUaGUgYXNzdW1wdGlvbiBpc1xuXHQgKiB0aGF0IGlmIHlvdSBhY3R1YWxseSB3YW50IHRvIHByaW50IHRoZSBzdHJpbmcgXCJudWxsXCIgb3IgXCJ1bmRlZmluZWRcIixcblx0ICogdGhlbiB0aGF0J3MgZWFzeSB0byBkbyB0aGF0IHdoZW4geW91J3JlIGNhbGxpbmcgZXh0c3ByaW50Zjsgb24gdGhlXG5cdCAqIG90aGVyIGhhbmQsIGlmIHlvdSBkaWQgTk9UIHdhbnQgdGhhdCAoaS5lLiwgdGhlcmUncyBhY3R1YWxseSBhIGJ1Z1xuXHQgKiB3aGVyZSB0aGUgcHJvZ3JhbSBhc3N1bWVzIHNvbWUgdmFyaWFibGUgaXMgbm9uLW51bGwgYW5kIHRyaWVzIHRvXG5cdCAqIHByaW50IGl0LCB3aGljaCBtaWdodCBoYXBwZW4gd2hlbiBjb25zdHJ1Y3RpbmcgYSBwYWNrZXQgb3IgZmlsZSBpblxuXHQgKiBzb21lIHNwZWNpZmljIGZvcm1hdCksIHRoZW4gaXQncyBiZXR0ZXIgdG8gc3RvcCBpbW1lZGlhdGVseSB0aGFuXG5cdCAqIHByb2R1Y2UgYm9ndXMgb3V0cHV0LlxuXHQgKlxuXHQgKiBIb3dldmVyLCBzb21ldGltZXMgdGhlIGJ1ZyBpcyBvbmx5IGluIHRoZSBjb2RlIGNhbGxpbmcgVkVycm9yLCBhbmQgYVxuXHQgKiBwcm9ncmFtbWVyIG1pZ2h0IHByZWZlciB0byBoYXZlIHRoZSBlcnJvciBtZXNzYWdlIGNvbnRhaW4gXCJudWxsXCIgb3Jcblx0ICogXCJ1bmRlZmluZWRcIiByYXRoZXIgdGhhbiBoYXZlIHRoZSBidWcgaW4gdGhlIGVycm9yIHBhdGggY3Jhc2ggdGhlXG5cdCAqIHByb2dyYW0gKG1ha2luZyB0aGUgZmlyc3QgYnVnIGhhcmRlciB0byBpZGVudGlmeSkuICBGb3IgdGhhdCByZWFzb24sXG5cdCAqIGJ5IGRlZmF1bHQgVkVycm9yIGNvbnZlcnRzIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIgYXJndW1lbnRzIHRvIHRoZWlyXG5cdCAqIHN0cmluZyByZXByZXNlbnRhdGlvbnMgYW5kIHBhc3NlcyB0aG9zZSB0byBleHRzcHJpbnRmLiAgUHJvZ3JhbW1lcnNcblx0ICogZGVzaXJpbmcgdGhlIHN0cmljdCBiZWhhdmlvciBjYW4gdXNlIHRoZSBTRXJyb3IgY2xhc3Mgb3IgcGFzcyB0aGVcblx0ICogXCJzdHJpY3RcIiBvcHRpb24gdG8gdGhlIFZFcnJvciBjb25zdHJ1Y3Rvci5cblx0ICovXG5cdG1vZF9hc3NlcnRwbHVzLm9iamVjdChvcHRpb25zKTtcblx0aWYgKCFvcHRpb25zLnN0cmljdCAmJiAhYXJncy5zdHJpY3QpIHtcblx0XHRzcHJpbnRmX2FyZ3MgPSBzcHJpbnRmX2FyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG5cdFx0XHRyZXR1cm4gKGEgPT09IG51bGwgPyAnbnVsbCcgOlxuXHRcdFx0ICAgIGEgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogYSk7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoc3ByaW50Zl9hcmdzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHNob3J0bWVzc2FnZSA9ICcnO1xuXHR9IGVsc2Uge1xuXHRcdHNob3J0bWVzc2FnZSA9IHNwcmludGYuYXBwbHkobnVsbCwgc3ByaW50Zl9hcmdzKTtcblx0fVxuXG5cdHJldHVybiAoe1xuXHQgICAgJ29wdGlvbnMnOiBvcHRpb25zLFxuXHQgICAgJ3Nob3J0bWVzc2FnZSc6IHNob3J0bWVzc2FnZVxuXHR9KTtcbn1cblxuLypcbiAqIFNlZSBSRUFETUUubWQgZm9yIHJlZmVyZW5jZSBkb2N1bWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBWRXJyb3IoKVxue1xuXHR2YXIgYXJncywgb2JqLCBwYXJzZWQsIGNhdXNlLCBjdG9yLCBtZXNzYWdlLCBrO1xuXG5cdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG5cdC8qXG5cdCAqIFRoaXMgaXMgYSByZWdyZXR0YWJsZSBwYXR0ZXJuLCBidXQgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIEVycm9yIGNsYXNzXG5cdCAqIGlzIGRlZmluZWQgdG8gd29yayB0aGlzIHdheSwgc28gd2UgYWxsb3cgdGhlIGNvbnN0cnVjdG9yIHRvIGJlIGNhbGxlZFxuXHQgKiB3aXRob3V0IFwibmV3XCIuXG5cdCAqL1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgVkVycm9yKSkge1xuXHRcdG9iaiA9IE9iamVjdC5jcmVhdGUoVkVycm9yLnByb3RvdHlwZSk7XG5cdFx0VkVycm9yLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gKG9iaik7XG5cdH1cblxuXHQvKlxuXHQgKiBGb3IgY29udmVuaWVuY2UgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHNldmVyYWxcblx0ICogZGlmZmVyZW50IGNhbGxpbmcgZm9ybXMuICBOb3JtYWxpemUgdGhlbSBoZXJlLlxuXHQgKi9cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogZmFsc2Vcblx0fSk7XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhIG5hbWUsIGFwcGx5IGl0IG5vdy5cblx0ICovXG5cdGlmIChwYXJzZWQub3B0aW9ucy5uYW1lKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKHBhcnNlZC5vcHRpb25zLm5hbWUsXG5cdFx0ICAgICdlcnJvclxcJ3MgXCJuYW1lXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMubmFtZSA9IHBhcnNlZC5vcHRpb25zLm5hbWU7XG5cdH1cblxuXHQvKlxuXHQgKiBGb3IgZGVidWdnaW5nLCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBzaG9ydCBtZXNzYWdlIChhdHRhY2hlZFxuXHQgKiB0aGlzIEVycm9yIHBhcnRpY3VsYXJseSkgc2VwYXJhdGVseSBmcm9tIHRoZSBjb21wbGV0ZSBtZXNzYWdlICh3aGljaFxuXHQgKiBpbmNsdWRlcyB0aGUgbWVzc2FnZXMgb2Ygb3VyIGNhdXNlIGNoYWluKS5cblx0ICovXG5cdHRoaXMuanNlX3Nob3J0bXNnID0gcGFyc2VkLnNob3J0bWVzc2FnZTtcblx0bWVzc2FnZSA9IHBhcnNlZC5zaG9ydG1lc3NhZ2U7XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNhdXNlLCByZWNvcmQgYSByZWZlcmVuY2UgdG8gaXQgYW5kIHVwZGF0ZSBvdXJcblx0ICogbWVzc2FnZSBhcHByb3ByaWF0ZWx5LlxuXHQgKi9cblx0Y2F1c2UgPSBwYXJzZWQub3B0aW9ucy5jYXVzZTtcblx0aWYgKGNhdXNlKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoY2F1c2UpLCAnY2F1c2UgaXMgbm90IGFuIEVycm9yJyk7XG5cdFx0dGhpcy5qc2VfY2F1c2UgPSBjYXVzZTtcblxuXHRcdGlmICghcGFyc2VkLm9wdGlvbnMuc2tpcENhdXNlTWVzc2FnZSkge1xuXHRcdFx0bWVzc2FnZSArPSAnOiAnICsgY2F1c2UubWVzc2FnZTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHQgKiBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMsIHNoYWxsb3ctY29weSB0aGF0XG5cdCAqIGhlcmUuICBXZSBkb24ndCB3YW50IHRvIHVzZSBhIGRlZXAgY29weSBpbiBjYXNlIHRoZXJlIGFyZSBub24tcGxhaW5cblx0ICogb2JqZWN0cyBoZXJlLCBidXQgd2UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIG9yaWdpbmFsIG9iamVjdCBpbiBjYXNlXG5cdCAqIHRoZSBjYWxsZXIgbW9kaWZpZXMgaXQgbGF0ZXIuXG5cdCAqL1xuXHR0aGlzLmpzZV9pbmZvID0ge307XG5cdGlmIChwYXJzZWQub3B0aW9ucy5pbmZvKSB7XG5cdFx0Zm9yIChrIGluIHBhcnNlZC5vcHRpb25zLmluZm8pIHtcblx0XHRcdHRoaXMuanNlX2luZm9ba10gPSBwYXJzZWQub3B0aW9ucy5pbmZvW2tdO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0Y3RvciA9IHBhcnNlZC5vcHRpb25zLmNvbnN0cnVjdG9yT3B0IHx8IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY3Rvcik7XG5cdH1cblxuXHRyZXR1cm4gKHRoaXMpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhWRXJyb3IsIEVycm9yKTtcblZFcnJvci5wcm90b3R5cGUubmFtZSA9ICdWRXJyb3InO1xuXG5WRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdmVfdG9TdHJpbmcoKVxue1xuXHR2YXIgc3RyID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiB0aGlzLm5hbWUgfHxcblx0XHR0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSk7XG5cdGlmICh0aGlzLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc6ICcgKyB0aGlzLm1lc3NhZ2U7XG5cblx0cmV0dXJuIChzdHIpO1xufTtcblxuLypcbiAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGZvciBjb21wYXRpYmlsaXR5LiAgTmV3IGNhbGxlcnMgc2hvdWxkIHVzZVxuICogVkVycm9yLmNhdXNlKCkgaW5zdGVhZC4gIFRoYXQgbWV0aG9kIGFsc28gdXNlcyB0aGUgc2FuZXIgYG51bGxgIHJldHVybiB2YWx1ZVxuICogd2hlbiB0aGVyZSBpcyBubyBjYXVzZS5cbiAqL1xuVkVycm9yLnByb3RvdHlwZS5jYXVzZSA9IGZ1bmN0aW9uIHZlX2NhdXNlKClcbntcblx0dmFyIGNhdXNlID0gVkVycm9yLmNhdXNlKHRoaXMpO1xuXHRyZXR1cm4gKGNhdXNlID09PSBudWxsID8gdW5kZWZpbmVkIDogY2F1c2UpO1xufTtcblxuLypcbiAqIFN0YXRpYyBtZXRob2RzXG4gKlxuICogVGhlc2UgY2xhc3MtbGV2ZWwgbWV0aG9kcyBhcmUgcHJvdmlkZWQgc28gdGhhdCBjYWxsZXJzIGNhbiB1c2UgdGhlbSBvblxuICogaW5zdGFuY2VzIG9mIEVycm9ycyB0aGF0IGFyZSBub3QgVkVycm9ycy4gIE5ldyBpbnRlcmZhY2VzIHNob3VsZCBiZSBwcm92aWRlZFxuICogb25seSB1c2luZyBzdGF0aWMgbWV0aG9kcyB0byBlbGltaW5hdGUgdGhlIGNsYXNzIG9mIHByb2dyYW1taW5nIG1pc3Rha2Ugd2hlcmVcbiAqIHBlb3BsZSBmYWlsIHRvIGNoZWNrIHdoZXRoZXIgdGhlIEVycm9yIG9iamVjdCBoYXMgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcy5cbiAqL1xuXG5WRXJyb3IuY2F1c2UgPSBmdW5jdGlvbiAoZXJyKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0cmV0dXJuIChtb2RfaXNFcnJvcihlcnIuanNlX2NhdXNlKSA/IGVyci5qc2VfY2F1c2UgOiBudWxsKTtcbn07XG5cblZFcnJvci5pbmZvID0gZnVuY3Rpb24gKGVycilcbntcblx0dmFyIHJ2LCBjYXVzZSwgaztcblxuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0Y2F1c2UgPSBWRXJyb3IuY2F1c2UoZXJyKTtcblx0aWYgKGNhdXNlICE9PSBudWxsKSB7XG5cdFx0cnYgPSBWRXJyb3IuaW5mbyhjYXVzZSk7XG5cdH0gZWxzZSB7XG5cdFx0cnYgPSB7fTtcblx0fVxuXG5cdGlmICh0eXBlb2YgKGVyci5qc2VfaW5mbykgPT0gJ29iamVjdCcgJiYgZXJyLmpzZV9pbmZvICE9PSBudWxsKSB7XG5cdFx0Zm9yIChrIGluIGVyci5qc2VfaW5mbykge1xuXHRcdFx0cnZba10gPSBlcnIuanNlX2luZm9ba107XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChydik7XG59O1xuXG5WRXJyb3IuZmluZENhdXNlQnlOYW1lID0gZnVuY3Rpb24gKGVyciwgbmFtZSlcbntcblx0dmFyIGNhdXNlO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXHRtb2RfYXNzZXJ0cGx1cy5zdHJpbmcobmFtZSwgJ25hbWUnKTtcblx0bW9kX2Fzc2VydHBsdXMub2sobmFtZS5sZW5ndGggPiAwLCAnbmFtZSBjYW5ub3QgYmUgZW1wdHknKTtcblxuXHRmb3IgKGNhdXNlID0gZXJyOyBjYXVzZSAhPT0gbnVsbDsgY2F1c2UgPSBWRXJyb3IuY2F1c2UoY2F1c2UpKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoY2F1c2UpKTtcblx0XHRpZiAoY2F1c2UubmFtZSA9PSBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gKGNhdXNlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKG51bGwpO1xufTtcblxuVkVycm9yLmhhc0NhdXNlV2l0aE5hbWUgPSBmdW5jdGlvbiAoZXJyLCBuYW1lKVxue1xuXHRyZXR1cm4gKFZFcnJvci5maW5kQ2F1c2VCeU5hbWUoZXJyLCBuYW1lKSAhPT0gbnVsbCk7XG59O1xuXG5WRXJyb3IuZnVsbFN0YWNrID0gZnVuY3Rpb24gKGVycilcbntcblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cblx0dmFyIGNhdXNlID0gVkVycm9yLmNhdXNlKGVycik7XG5cblx0aWYgKGNhdXNlKSB7XG5cdFx0cmV0dXJuIChlcnIuc3RhY2sgKyAnXFxuY2F1c2VkIGJ5OiAnICsgVkVycm9yLmZ1bGxTdGFjayhjYXVzZSkpO1xuXHR9XG5cblx0cmV0dXJuIChlcnIuc3RhY2spO1xufTtcblxuVkVycm9yLmVycm9yRnJvbUxpc3QgPSBmdW5jdGlvbiAoZXJyb3JzKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5hcnJheU9mT2JqZWN0KGVycm9ycywgJ2Vycm9ycycpO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIChudWxsKTtcblx0fVxuXG5cdGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZSkpO1xuXHR9KTtcblxuXHRpZiAoZXJyb3JzLmxlbmd0aCA9PSAxKSB7XG5cdFx0cmV0dXJuIChlcnJvcnNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIChuZXcgTXVsdGlFcnJvcihlcnJvcnMpKTtcbn07XG5cblZFcnJvci5lcnJvckZvckVhY2ggPSBmdW5jdGlvbiAoZXJyLCBmdW5jKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0bW9kX2Fzc2VydHBsdXMuZnVuYyhmdW5jLCAnZnVuYycpO1xuXG5cdGlmIChlcnIgaW5zdGFuY2VvZiBNdWx0aUVycm9yKSB7XG5cdFx0ZXJyLmVycm9ycygpLmZvckVhY2goZnVuY3Rpb24gaXRlckVycm9yKGUpIHsgZnVuYyhlKTsgfSk7XG5cdH0gZWxzZSB7XG5cdFx0ZnVuYyhlcnIpO1xuXHR9XG59O1xuXG5cbi8qXG4gKiBTRXJyb3IgaXMgbGlrZSBWRXJyb3IsIGJ1dCBzdHJpY3RlciBhYm91dCB0eXBlcy4gIFlvdSBjYW5ub3QgcGFzcyBcIm51bGxcIiBvclxuICogXCJ1bmRlZmluZWRcIiBhcyBzdHJpbmcgYXJndW1lbnRzIHRvIHRoZSBmb3JtYXR0ZXIuXG4gKi9cbmZ1bmN0aW9uIFNFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgb3B0aW9ucztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFNFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFNFcnJvci5wcm90b3R5cGUpO1xuXHRcdFNFcnJvci5hcHBseShvYmosIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIChvYmopO1xuXHR9XG5cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogdHJ1ZVxuXHR9KTtcblxuXHRvcHRpb25zID0gcGFyc2VkLm9wdGlvbnM7XG5cdFZFcnJvci5jYWxsKHRoaXMsIG9wdGlvbnMsICclcycsIHBhcnNlZC5zaG9ydG1lc3NhZ2UpO1xuXG5cdHJldHVybiAodGhpcyk7XG59XG5cbi8qXG4gKiBXZSBkb24ndCBib3RoZXIgc2V0dGluZyBTRXJyb3IucHJvdG90eXBlLm5hbWUgYmVjYXVzZSBvbmNlIGNvbnN0cnVjdGVkLFxuICogU0Vycm9ycyBhcmUganVzdCBsaWtlIFZFcnJvcnMuXG4gKi9cbm1vZF91dGlsLmluaGVyaXRzKFNFcnJvciwgVkVycm9yKTtcblxuXG4vKlxuICogUmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgZXJyb3JzIGZvciB0aGUgcHVycG9zZSBvZiBjb25zdW1lcnMgdGhhdCBnZW5lcmFsbHlcbiAqIG9ubHkgZGVhbCB3aXRoIG9uZSBlcnJvci4gIENhbGxlcnMgY2FuIGV4dHJhY3QgdGhlIGluZGl2aWR1YWwgZXJyb3JzXG4gKiBjb250YWluZWQgaW4gdGhpcyBvYmplY3QsIGJ1dCBtYXkgYWxzbyBqdXN0IHRyZWF0IGl0IGFzIGEgbm9ybWFsIHNpbmdsZVxuICogZXJyb3IsIGluIHdoaWNoIGNhc2UgYSBzdW1tYXJ5IG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkLlxuICovXG5mdW5jdGlvbiBNdWx0aUVycm9yKGVycm9ycylcbntcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXkoZXJyb3JzLCAnbGlzdCBvZiBlcnJvcnMnKTtcblx0bW9kX2Fzc2VydHBsdXMub2soZXJyb3JzLmxlbmd0aCA+IDAsICdtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvcicpO1xuXHR0aGlzLmFzZV9lcnJvcnMgPSBlcnJvcnM7XG5cblx0VkVycm9yLmNhbGwodGhpcywge1xuXHQgICAgJ2NhdXNlJzogZXJyb3JzWzBdXG5cdH0sICdmaXJzdCBvZiAlZCBlcnJvciVzJywgZXJyb3JzLmxlbmd0aCwgZXJyb3JzLmxlbmd0aCA9PSAxID8gJycgOiAncycpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhNdWx0aUVycm9yLCBWRXJyb3IpO1xuTXVsdGlFcnJvci5wcm90b3R5cGUubmFtZSA9ICdNdWx0aUVycm9yJztcblxuTXVsdGlFcnJvci5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24gbWVfZXJyb3JzKClcbntcblx0cmV0dXJuICh0aGlzLmFzZV9lcnJvcnMuc2xpY2UoMCkpO1xufTtcblxuXG4vKlxuICogU2VlIFJFQURNRS5tZCBmb3IgcmVmZXJlbmNlIGRldGFpbHMuXG4gKi9cbmZ1bmN0aW9uIFdFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgb3B0aW9ucztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFdFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFdFcnJvci5wcm90b3R5cGUpO1xuXHRcdFdFcnJvci5hcHBseShvYmosIGFyZ3MpO1xuXHRcdHJldHVybiAob2JqKTtcblx0fVxuXG5cdHBhcnNlZCA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoe1xuXHQgICAgJ2FyZ3YnOiBhcmdzLFxuXHQgICAgJ3N0cmljdCc6IGZhbHNlXG5cdH0pO1xuXG5cdG9wdGlvbnMgPSBwYXJzZWQub3B0aW9ucztcblx0b3B0aW9uc1snc2tpcENhdXNlTWVzc2FnZSddID0gdHJ1ZTtcblx0VkVycm9yLmNhbGwodGhpcywgb3B0aW9ucywgJyVzJywgcGFyc2VkLnNob3J0bWVzc2FnZSk7XG5cblx0cmV0dXJuICh0aGlzKTtcbn1cblxubW9kX3V0aWwuaW5oZXJpdHMoV0Vycm9yLCBWRXJyb3IpO1xuV0Vycm9yLnByb3RvdHlwZS5uYW1lID0gJ1dFcnJvcic7XG5cbldFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB3ZV90b1N0cmluZygpXG57XG5cdHZhciBzdHIgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpICYmIHRoaXMubmFtZSB8fFxuXHRcdHRoaXMuY29uc3RydWN0b3IubmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5uYW1lKTtcblx0aWYgKHRoaXMubWVzc2FnZSlcblx0XHRzdHIgKz0gJzogJyArIHRoaXMubWVzc2FnZTtcblx0aWYgKHRoaXMuanNlX2NhdXNlICYmIHRoaXMuanNlX2NhdXNlLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc7IGNhdXNlZCBieSAnICsgdGhpcy5qc2VfY2F1c2UudG9TdHJpbmcoKTtcblxuXHRyZXR1cm4gKHN0cik7XG59O1xuXG4vKlxuICogRm9yIHB1cmVseSBoaXN0b3JpY2FsIHJlYXNvbnMsIFdFcnJvcidzIGNhdXNlKCkgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXRcbiAqIHRoZSBjYXVzZS5cbiAqL1xuV0Vycm9yLnByb3RvdHlwZS5jYXVzZSA9IGZ1bmN0aW9uIHdlX2NhdXNlKGMpXG57XG5cdGlmIChtb2RfaXNFcnJvcihjKSlcblx0XHR0aGlzLmpzZV9jYXVzZSA9IGM7XG5cblx0cmV0dXJuICh0aGlzLmpzZV9jYXVzZSk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZF9hc3NlcnRwbHVzIiwicmVxdWlyZSIsIm1vZF91dGlsIiwibW9kX2V4dHNwcmludGYiLCJtb2RfaXNFcnJvciIsImlzRXJyb3IiLCJzcHJpbnRmIiwibW9kdWxlIiwiZXhwb3J0cyIsIlZFcnJvciIsIlNFcnJvciIsIldFcnJvciIsIk11bHRpRXJyb3IiLCJwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzIiwiYXJncyIsImFyZ3YiLCJvcHRpb25zIiwic3ByaW50Zl9hcmdzIiwic2hvcnRtZXNzYWdlIiwiayIsIm9iamVjdCIsImJvb2wiLCJzdHJpY3QiLCJhcnJheSIsImxlbmd0aCIsInNsaWNlIiwic3RyaW5nIiwibWFwIiwiYSIsInVuZGVmaW5lZCIsImFwcGx5Iiwib2JqIiwicGFyc2VkIiwiY2F1c2UiLCJjdG9yIiwibWVzc2FnZSIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsImFyZ3VtZW50cyIsIk9iamVjdCIsImNyZWF0ZSIsIm5hbWUiLCJqc2Vfc2hvcnRtc2ciLCJvayIsImpzZV9jYXVzZSIsInNraXBDYXVzZU1lc3NhZ2UiLCJqc2VfaW5mbyIsImluZm8iLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiY29uc3RydWN0b3JPcHQiLCJjb25zdHJ1Y3RvciIsImluaGVyaXRzIiwidG9TdHJpbmciLCJ2ZV90b1N0cmluZyIsInN0ciIsImhhc093blByb3BlcnR5IiwidmVfY2F1c2UiLCJlcnIiLCJydiIsImZpbmRDYXVzZUJ5TmFtZSIsImhhc0NhdXNlV2l0aE5hbWUiLCJmdWxsU3RhY2siLCJzdGFjayIsImVycm9yRnJvbUxpc3QiLCJlcnJvcnMiLCJhcnJheU9mT2JqZWN0IiwiZm9yRWFjaCIsImUiLCJlcnJvckZvckVhY2giLCJmdW5jIiwiaXRlckVycm9yIiwiYXNlX2Vycm9ycyIsIm1lX2Vycm9ycyIsIndlX3RvU3RyaW5nIiwid2VfY2F1c2UiLCJjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/verror/lib/verror.js\n");

/***/ })

};
;