"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/http-signature";
exports.ids = ["vendor-chunks/http-signature"];
exports.modules = {

/***/ "(ssr)/./node_modules/http-signature/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/http-signature/lib/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar parser = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/http-signature/lib/parser.js\");\nvar signer = __webpack_require__(/*! ./signer */ \"(ssr)/./node_modules/http-signature/lib/signer.js\");\nvar verify = __webpack_require__(/*! ./verify */ \"(ssr)/./node_modules/http-signature/lib/verify.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/http-signature/lib/utils.js\");\n///--- API\nmodule.exports = {\n    parse: parser.parseRequest,\n    parseRequest: parser.parseRequest,\n    sign: signer.signRequest,\n    signRequest: signer.signRequest,\n    createSigner: signer.createSigner,\n    isSigner: signer.isSigner,\n    sshKeyToPEM: utils.sshKeyToPEM,\n    sshKeyFingerprint: utils.fingerprint,\n    pemToRsaSSHKey: utils.pemToRsaSSHKey,\n    verify: verify.verifySignature,\n    verifySignature: verify.verifySignature,\n    verifyHMAC: verify.verifyHMAC\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDhCQUE4Qjs7QUFFOUIsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUM7QUFDckIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUM7QUFJcEIsVUFBVTtBQUVWSSxPQUFPQyxPQUFPLEdBQUc7SUFFZkMsT0FBT1AsT0FBT1EsWUFBWTtJQUMxQkEsY0FBY1IsT0FBT1EsWUFBWTtJQUVqQ0MsTUFBTVAsT0FBT1EsV0FBVztJQUN4QkEsYUFBYVIsT0FBT1EsV0FBVztJQUMvQkMsY0FBY1QsT0FBT1MsWUFBWTtJQUNqQ0MsVUFBVVYsT0FBT1UsUUFBUTtJQUV6QkMsYUFBYVQsTUFBTVMsV0FBVztJQUM5QkMsbUJBQW1CVixNQUFNVyxXQUFXO0lBQ3BDQyxnQkFBZ0JaLE1BQU1ZLGNBQWM7SUFFcENiLFFBQVFBLE9BQU9jLGVBQWU7SUFDOUJBLGlCQUFpQmQsT0FBT2MsZUFBZTtJQUN2Q0MsWUFBWWYsT0FBT2UsVUFBVTtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi9pbmRleC5qcz82MmJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciBzaWduZXIgPSByZXF1aXJlKCcuL3NpZ25lcicpO1xudmFyIHZlcmlmeSA9IHJlcXVpcmUoJy4vdmVyaWZ5Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuXG4vLy8tLS0gQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHBhcnNlOiBwYXJzZXIucGFyc2VSZXF1ZXN0LFxuICBwYXJzZVJlcXVlc3Q6IHBhcnNlci5wYXJzZVJlcXVlc3QsXG5cbiAgc2lnbjogc2lnbmVyLnNpZ25SZXF1ZXN0LFxuICBzaWduUmVxdWVzdDogc2lnbmVyLnNpZ25SZXF1ZXN0LFxuICBjcmVhdGVTaWduZXI6IHNpZ25lci5jcmVhdGVTaWduZXIsXG4gIGlzU2lnbmVyOiBzaWduZXIuaXNTaWduZXIsXG5cbiAgc3NoS2V5VG9QRU06IHV0aWxzLnNzaEtleVRvUEVNLFxuICBzc2hLZXlGaW5nZXJwcmludDogdXRpbHMuZmluZ2VycHJpbnQsXG4gIHBlbVRvUnNhU1NIS2V5OiB1dGlscy5wZW1Ub1JzYVNTSEtleSxcblxuICB2ZXJpZnk6IHZlcmlmeS52ZXJpZnlTaWduYXR1cmUsXG4gIHZlcmlmeVNpZ25hdHVyZTogdmVyaWZ5LnZlcmlmeVNpZ25hdHVyZSxcbiAgdmVyaWZ5SE1BQzogdmVyaWZ5LnZlcmlmeUhNQUNcbn07XG4iXSwibmFtZXMiOlsicGFyc2VyIiwicmVxdWlyZSIsInNpZ25lciIsInZlcmlmeSIsInV0aWxzIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlIiwicGFyc2VSZXF1ZXN0Iiwic2lnbiIsInNpZ25SZXF1ZXN0IiwiY3JlYXRlU2lnbmVyIiwiaXNTaWduZXIiLCJzc2hLZXlUb1BFTSIsInNzaEtleUZpbmdlcnByaW50IiwiZmluZ2VycHJpbnQiLCJwZW1Ub1JzYVNTSEtleSIsInZlcmlmeVNpZ25hdHVyZSIsInZlcmlmeUhNQUMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/http-signature/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/http-signature/lib/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/parser.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(ssr)/./node_modules/assert-plus/assert.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/http-signature/lib/utils.js\");\n///--- Globals\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar validateAlgorithm = utils.validateAlgorithm;\nvar State = {\n    New: 0,\n    Params: 1\n};\nvar ParamsState = {\n    Name: 0,\n    Quote: 1,\n    Value: 2,\n    Comma: 3\n};\n///--- Specific Errors\nfunction ExpiredRequestError(message) {\n    HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\nfunction InvalidHeaderError(message) {\n    HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\nfunction InvalidParamsError(message) {\n    HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\nfunction MissingHeaderError(message) {\n    HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\nfunction StrictParsingError(message) {\n    HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n///--- Exported API\nmodule.exports = {\n    /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"digest\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   *                   - strict: should enforce latest spec parsing\n   *                             (default: false).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {StrictParsingError} if old attributes are used in strict parsing\n   *                              mode.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */ parseRequest: function parseRequest(request, options) {\n        assert.object(request, \"request\");\n        assert.object(request.headers, \"request.headers\");\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.headers === undefined) {\n            options.headers = [\n                request.headers[\"x-date\"] ? \"x-date\" : \"date\"\n            ];\n        }\n        assert.object(options, \"options\");\n        assert.arrayOfString(options.headers, \"options.headers\");\n        assert.optionalFinite(options.clockSkew, \"options.clockSkew\");\n        var authzHeaderName = options.authorizationHeaderName || \"authorization\";\n        if (!request.headers[authzHeaderName]) {\n            throw new MissingHeaderError(\"no \" + authzHeaderName + \" header \" + \"present in the request\");\n        }\n        options.clockSkew = options.clockSkew || 300;\n        var i = 0;\n        var state = State.New;\n        var substate = ParamsState.Name;\n        var tmpName = \"\";\n        var tmpValue = \"\";\n        var parsed = {\n            scheme: \"\",\n            params: {},\n            signingString: \"\"\n        };\n        var authz = request.headers[authzHeaderName];\n        for(i = 0; i < authz.length; i++){\n            var c = authz.charAt(i);\n            switch(Number(state)){\n                case State.New:\n                    if (c !== \" \") parsed.scheme += c;\n                    else state = State.Params;\n                    break;\n                case State.Params:\n                    switch(Number(substate)){\n                        case ParamsState.Name:\n                            var code = c.charCodeAt(0);\n                            // restricted name of A-Z / a-z\n                            if (code >= 0x41 && code <= 0x5a || // A-Z\n                            code >= 0x61 && code <= 0x7a) {\n                                tmpName += c;\n                            } else if (c === \"=\") {\n                                if (tmpName.length === 0) throw new InvalidHeaderError(\"bad param format\");\n                                substate = ParamsState.Quote;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        case ParamsState.Quote:\n                            if (c === '\"') {\n                                tmpValue = \"\";\n                                substate = ParamsState.Value;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        case ParamsState.Value:\n                            if (c === '\"') {\n                                parsed.params[tmpName] = tmpValue;\n                                substate = ParamsState.Comma;\n                            } else {\n                                tmpValue += c;\n                            }\n                            break;\n                        case ParamsState.Comma:\n                            if (c === \",\") {\n                                tmpName = \"\";\n                                substate = ParamsState.Name;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        default:\n                            throw new Error(\"Invalid substate\");\n                    }\n                    break;\n                default:\n                    throw new Error(\"Invalid substate\");\n            }\n        }\n        if (!parsed.params.headers || parsed.params.headers === \"\") {\n            if (request.headers[\"x-date\"]) {\n                parsed.params.headers = [\n                    \"x-date\"\n                ];\n            } else {\n                parsed.params.headers = [\n                    \"date\"\n                ];\n            }\n        } else {\n            parsed.params.headers = parsed.params.headers.split(\" \");\n        }\n        // Minimally validate the parsed object\n        if (!parsed.scheme || parsed.scheme !== \"Signature\") throw new InvalidHeaderError('scheme was not \"Signature\"');\n        if (!parsed.params.keyId) throw new InvalidHeaderError(\"keyId was not specified\");\n        if (!parsed.params.algorithm) throw new InvalidHeaderError(\"algorithm was not specified\");\n        if (!parsed.params.signature) throw new InvalidHeaderError(\"signature was not specified\");\n        // Check the algorithm against the official list\n        parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n        try {\n            validateAlgorithm(parsed.params.algorithm);\n        } catch (e) {\n            if (e instanceof InvalidAlgorithmError) throw new InvalidParamsError(parsed.params.algorithm + \" is not \" + \"supported\");\n            else throw e;\n        }\n        // Build the signingString\n        for(i = 0; i < parsed.params.headers.length; i++){\n            var h = parsed.params.headers[i].toLowerCase();\n            parsed.params.headers[i] = h;\n            if (h === \"request-line\") {\n                if (!options.strict) {\n                    /*\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */ parsed.signingString += request.method + \" \" + request.url + \" HTTP/\" + request.httpVersion;\n                } else {\n                    /* Strict parsing doesn't allow older draft headers. */ throw new StrictParsingError(\"request-line is not a valid header \" + \"with strict parsing enabled.\");\n                }\n            } else if (h === \"(request-target)\") {\n                parsed.signingString += \"(request-target): \" + request.method.toLowerCase() + \" \" + request.url;\n            } else {\n                var value = request.headers[h];\n                if (value === undefined) throw new MissingHeaderError(h + \" was not in the request\");\n                parsed.signingString += h + \": \" + value;\n            }\n            if (i + 1 < parsed.params.headers.length) parsed.signingString += \"\\n\";\n        }\n        // Check against the constraints\n        var date;\n        if (request.headers.date || request.headers[\"x-date\"]) {\n            if (request.headers[\"x-date\"]) {\n                date = new Date(request.headers[\"x-date\"]);\n            } else {\n                date = new Date(request.headers.date);\n            }\n            var now = new Date();\n            var skew = Math.abs(now.getTime() - date.getTime());\n            if (skew > options.clockSkew * 1000) {\n                throw new ExpiredRequestError(\"clock skew of \" + skew / 1000 + \"s was greater than \" + options.clockSkew + \"s\");\n            }\n        }\n        options.headers.forEach(function(hdr) {\n            // Remember that we already checked any headers in the params\n            // were in the request, so if this passes we're good.\n            if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0) throw new MissingHeaderError(hdr + \" was not a signed header\");\n        });\n        if (options.algorithms) {\n            if (options.algorithms.indexOf(parsed.params.algorithm) === -1) throw new InvalidParamsError(parsed.params.algorithm + \" is not a supported algorithm\");\n        }\n        parsed.algorithm = parsed.params.algorithm.toUpperCase();\n        parsed.keyId = parsed.params.keyId;\n        return parsed;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvREFBb0Q7O0FBRXBELElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBSXBCLGNBQWM7QUFFZCxJQUFJRyxhQUFhRCxNQUFNQyxVQUFVO0FBQ2pDLElBQUlDLFdBQVdGLE1BQU1FLFFBQVE7QUFDN0IsSUFBSUMscUJBQXFCSCxNQUFNRyxrQkFBa0I7QUFDakQsSUFBSUMsd0JBQXdCSixNQUFNSSxxQkFBcUI7QUFDdkQsSUFBSUMsb0JBQW9CTCxNQUFNSyxpQkFBaUI7QUFFL0MsSUFBSUMsUUFBUTtJQUNWQyxLQUFLO0lBQ0xDLFFBQVE7QUFDVjtBQUVBLElBQUlDLGNBQWM7SUFDaEJDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE9BQU87QUFDVDtBQUdBLHNCQUFzQjtBQUd0QixTQUFTQyxvQkFBb0JDLE9BQU87SUFDbENaLG1CQUFtQmEsSUFBSSxDQUFDLElBQUksRUFBRUQsU0FBU0Q7QUFDekM7QUFDQWYsS0FBS2tCLFFBQVEsQ0FBQ0gscUJBQXFCWDtBQUduQyxTQUFTZSxtQkFBbUJILE9BQU87SUFDakNaLG1CQUFtQmEsSUFBSSxDQUFDLElBQUksRUFBRUQsU0FBU0c7QUFDekM7QUFDQW5CLEtBQUtrQixRQUFRLENBQUNDLG9CQUFvQmY7QUFHbEMsU0FBU2dCLG1CQUFtQkosT0FBTztJQUNqQ1osbUJBQW1CYSxJQUFJLENBQUMsSUFBSSxFQUFFRCxTQUFTSTtBQUN6QztBQUNBcEIsS0FBS2tCLFFBQVEsQ0FBQ0Usb0JBQW9CaEI7QUFHbEMsU0FBU2lCLG1CQUFtQkwsT0FBTztJQUNqQ1osbUJBQW1CYSxJQUFJLENBQUMsSUFBSSxFQUFFRCxTQUFTSztBQUN6QztBQUNBckIsS0FBS2tCLFFBQVEsQ0FBQ0csb0JBQW9C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QU0sQ0FBQ1csS0FBSztRQUNsQyxPQUFPYjtJQUNUO0FBRUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnZvaWNlLWFwcC8uL25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvcGFyc2VyLmpzPzUxOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTIgSm95ZW50LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIEhBU0hfQUxHT1MgPSB1dGlscy5IQVNIX0FMR09TO1xudmFyIFBLX0FMR09TID0gdXRpbHMuUEtfQUxHT1M7XG52YXIgSHR0cFNpZ25hdHVyZUVycm9yID0gdXRpbHMuSHR0cFNpZ25hdHVyZUVycm9yO1xudmFyIEludmFsaWRBbGdvcml0aG1FcnJvciA9IHV0aWxzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcbnZhciB2YWxpZGF0ZUFsZ29yaXRobSA9IHV0aWxzLnZhbGlkYXRlQWxnb3JpdGhtO1xuXG52YXIgU3RhdGUgPSB7XG4gIE5ldzogMCxcbiAgUGFyYW1zOiAxXG59O1xuXG52YXIgUGFyYW1zU3RhdGUgPSB7XG4gIE5hbWU6IDAsXG4gIFF1b3RlOiAxLFxuICBWYWx1ZTogMixcbiAgQ29tbWE6IDNcbn07XG5cblxuLy8vLS0tIFNwZWNpZmljIEVycm9yc1xuXG5cbmZ1bmN0aW9uIEV4cGlyZWRSZXF1ZXN0RXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBFeHBpcmVkUmVxdWVzdEVycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoRXhwaXJlZFJlcXVlc3RFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuXG5mdW5jdGlvbiBJbnZhbGlkSGVhZGVyRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBJbnZhbGlkSGVhZGVyRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhJbnZhbGlkSGVhZGVyRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cblxuZnVuY3Rpb24gSW52YWxpZFBhcmFtc0Vycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgSW52YWxpZFBhcmFtc0Vycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoSW52YWxpZFBhcmFtc0Vycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5cbmZ1bmN0aW9uIE1pc3NpbmdIZWFkZXJFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIE1pc3NpbmdIZWFkZXJFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKE1pc3NpbmdIZWFkZXJFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuZnVuY3Rpb24gU3RyaWN0UGFyc2luZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgU3RyaWN0UGFyc2luZ0Vycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RyaWN0UGFyc2luZ0Vycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlICdBdXRob3JpemF0aW9uJyBoZWFkZXIgb3V0IG9mIGFuIGh0dHAuU2VydmVyUmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIEFQSSB3aWxsIGZ1bGx5IHZhbGlkYXRlIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciwgYW5kIHRocm93XG4gICAqIG9uIGFueSBlcnJvci4gIEl0IHdpbGwgbm90IGhvd2V2ZXIgY2hlY2sgdGhlIHNpZ25hdHVyZSwgb3IgdGhlIGtleUlkIGZvcm1hdFxuICAgKiBhcyB0aG9zZSBhcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudC4gIFlvdSBjYW4gdXNlIHRoZSBvcHRpb25zIG9iamVjdFxuICAgKiB0byBwYXNzIGluIGV4dHJhIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBBcyBhIHJlc3BvbnNlIG9iamVjdCB5b3UgY2FuIGV4cGVjdCB0aGlzOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICBcInNjaGVtZVwiOiBcIlNpZ25hdHVyZVwiLFxuICAgKiAgICAgICBcInBhcmFtc1wiOiB7XG4gICAqICAgICAgICAgXCJrZXlJZFwiOiBcImZvb1wiLFxuICAgKiAgICAgICAgIFwiYWxnb3JpdGhtXCI6IFwicnNhLXNoYTI1NlwiLFxuICAgKiAgICAgICAgIFwiaGVhZGVyc1wiOiBbXG4gICAqICAgICAgICAgICBcImRhdGVcIiBvciBcIngtZGF0ZVwiLFxuICAgKiAgICAgICAgICAgXCJkaWdlc3RcIlxuICAgKiAgICAgICAgIF0sXG4gICAqICAgICAgICAgXCJzaWduYXR1cmVcIjogXCJiYXNlNjRcIlxuICAgKiAgICAgICB9LFxuICAgKiAgICAgICBcInNpZ25pbmdTdHJpbmdcIjogXCJyZWFkeSB0byBiZSBwYXNzZWQgdG8gY3J5cHRvLnZlcmlmeSgpXCJcbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgYW4gaHR0cC5TZXJ2ZXJSZXF1ZXN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdCB3aXRoOlxuICAgKiAgICAgICAgICAgICAgICAgICAtIGNsb2NrU2tldzogYWxsb3dlZCBjbG9jayBza2V3IGluIHNlY29uZHMgKGRlZmF1bHQgMzAwKS5cbiAgICogICAgICAgICAgICAgICAgICAgLSBoZWFkZXJzOiByZXF1aXJlZCBoZWFkZXIgbmFtZXMgKGRlZjogZGF0ZSBvciB4LWRhdGUpXG4gICAqICAgICAgICAgICAgICAgICAgIC0gYWxnb3JpdGhtczogYWxnb3JpdGhtcyB0byBzdXBwb3J0IChkZWZhdWx0OiBhbGwpLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHN0cmljdDogc2hvdWxkIGVuZm9yY2UgbGF0ZXN0IHNwZWMgcGFyc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBwYXJzZWQgb3V0IG9iamVjdCAoc2VlIGFib3ZlKS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBpbnZhbGlkIGlucHV0LlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkSGVhZGVyRXJyb3J9IG9uIGFuIGludmFsaWQgQXV0aG9yaXphdGlvbiBoZWFkZXIgZXJyb3IuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRQYXJhbXNFcnJvcn0gaWYgdGhlIHBhcmFtcyBpbiB0aGUgc2NoZW1lIGFyZSBpbnZhbGlkLlxuICAgKiBAdGhyb3dzIHtNaXNzaW5nSGVhZGVyRXJyb3J9IGlmIHRoZSBwYXJhbXMgaW5kaWNhdGUgYSBoZWFkZXIgbm90IHByZXNlbnQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyIGluIHRoZSByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGUgcGFyYW1zLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIG5vdCBpbiB0aGUgcGFyYW1zIGZyb20gYSByZXF1aXJlZCBoZWFkZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvcHRpb25zLlxuICAgKiBAdGhyb3dzIHtTdHJpY3RQYXJzaW5nRXJyb3J9IGlmIG9sZCBhdHRyaWJ1dGVzIGFyZSB1c2VkIGluIHN0cmljdCBwYXJzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZS5cbiAgICogQHRocm93cyB7RXhwaXJlZFJlcXVlc3RFcnJvcn0gaWYgdGhlIHZhbHVlIG9mIGRhdGUgb3IgeC1kYXRlIGV4Y2VlZHMgc2tldy5cbiAgICovXG4gIHBhcnNlUmVxdWVzdDogZnVuY3Rpb24gcGFyc2VSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQub2JqZWN0KHJlcXVlc3QsICdyZXF1ZXN0Jyk7XG4gICAgYXNzZXJ0Lm9iamVjdChyZXF1ZXN0LmhlYWRlcnMsICdyZXF1ZXN0LmhlYWRlcnMnKTtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gW3JlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10gPyAneC1kYXRlJyA6ICdkYXRlJ107XG4gICAgfVxuICAgIGFzc2VydC5vYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcbiAgICBhc3NlcnQuYXJyYXlPZlN0cmluZyhvcHRpb25zLmhlYWRlcnMsICdvcHRpb25zLmhlYWRlcnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxGaW5pdGUob3B0aW9ucy5jbG9ja1NrZXcsICdvcHRpb25zLmNsb2NrU2tldycpO1xuXG4gICAgdmFyIGF1dGh6SGVhZGVyTmFtZSA9IG9wdGlvbnMuYXV0aG9yaXphdGlvbkhlYWRlck5hbWUgfHwgJ2F1dGhvcml6YXRpb24nO1xuXG4gICAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNbYXV0aHpIZWFkZXJOYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcignbm8gJyArIGF1dGh6SGVhZGVyTmFtZSArICcgaGVhZGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJlc2VudCBpbiB0aGUgcmVxdWVzdCcpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuY2xvY2tTa2V3ID0gb3B0aW9ucy5jbG9ja1NrZXcgfHwgMzAwO1xuXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHN0YXRlID0gU3RhdGUuTmV3O1xuICAgIHZhciBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLk5hbWU7XG4gICAgdmFyIHRtcE5hbWUgPSAnJztcbiAgICB2YXIgdG1wVmFsdWUgPSAnJztcblxuICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICBzY2hlbWU6ICcnLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIHNpZ25pbmdTdHJpbmc6ICcnXG4gICAgfTtcblxuICAgIHZhciBhdXRoeiA9IHJlcXVlc3QuaGVhZGVyc1thdXRoekhlYWRlck5hbWVdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhdXRoei5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBhdXRoei5jaGFyQXQoaSk7XG5cbiAgICAgIHN3aXRjaCAoTnVtYmVyKHN0YXRlKSkge1xuXG4gICAgICBjYXNlIFN0YXRlLk5ldzpcbiAgICAgICAgaWYgKGMgIT09ICcgJykgcGFyc2VkLnNjaGVtZSArPSBjO1xuICAgICAgICBlbHNlIHN0YXRlID0gU3RhdGUuUGFyYW1zO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdGF0ZS5QYXJhbXM6XG4gICAgICAgIHN3aXRjaCAoTnVtYmVyKHN1YnN0YXRlKSkge1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuTmFtZTpcbiAgICAgICAgICB2YXIgY29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAvLyByZXN0cmljdGVkIG5hbWUgb2YgQS1aIC8gYS16XG4gICAgICAgICAgaWYgKChjb2RlID49IDB4NDEgJiYgY29kZSA8PSAweDVhKSB8fCAvLyBBLVpcbiAgICAgICAgICAgICAgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N2EpKSB7IC8vIGEtelxuICAgICAgICAgICAgdG1wTmFtZSArPSBjO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpZiAodG1wTmFtZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuUXVvdGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5RdW90ZTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgdG1wVmFsdWUgPSAnJztcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuVmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5WYWx1ZTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgcGFyc2VkLnBhcmFtc1t0bXBOYW1lXSA9IHRtcFZhbHVlO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5Db21tYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG1wVmFsdWUgKz0gYztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5Db21tYTpcbiAgICAgICAgICBpZiAoYyA9PT0gJywnKSB7XG4gICAgICAgICAgICB0bXBOYW1lID0gJyc7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLk5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnN0YXRlJyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuaGVhZGVycyB8fCBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPT09ICcnKSB7XG4gICAgICBpZiAocmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSkge1xuICAgICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPSBbJ3gtZGF0ZSddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID0gWydkYXRlJ107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9IHBhcnNlZC5wYXJhbXMuaGVhZGVycy5zcGxpdCgnICcpO1xuICAgIH1cblxuICAgIC8vIE1pbmltYWxseSB2YWxpZGF0ZSB0aGUgcGFyc2VkIG9iamVjdFxuICAgIGlmICghcGFyc2VkLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lICE9PSAnU2lnbmF0dXJlJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ3NjaGVtZSB3YXMgbm90IFwiU2lnbmF0dXJlXCInKTtcblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5rZXlJZClcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2tleUlkIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYWxnb3JpdGhtIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuc2lnbmF0dXJlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignc2lnbmF0dXJlIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICAvLyBDaGVjayB0aGUgYWxnb3JpdGhtIGFnYWluc3QgdGhlIG9mZmljaWFsIGxpc3RcbiAgICBwYXJzZWQucGFyYW1zLmFsZ29yaXRobSA9IHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCk7XG4gICAgdHJ5IHtcbiAgICAgIHZhbGlkYXRlQWxnb3JpdGhtKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEludmFsaWRBbGdvcml0aG1FcnJvcilcbiAgICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkUGFyYW1zRXJyb3IocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0gKyAnIGlzIG5vdCAnICtcbiAgICAgICAgICAnc3VwcG9ydGVkJykpO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyAoZSk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIHNpZ25pbmdTdHJpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFyc2VkLnBhcmFtcy5oZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaCA9IHBhcnNlZC5wYXJhbXMuaGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzW2ldID0gaDtcblxuICAgICAgaWYgKGggPT09ICdyZXF1ZXN0LWxpbmUnKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIFdlIGFsbG93IGhlYWRlcnMgZnJvbSB0aGUgb2xkZXIgc3BlYyBkcmFmdHMgaWYgc3RyaWN0IHBhcnNpbmcgaXNuJ3RcbiAgICAgICAgICAgKiBzcGVjaWZpZWQgaW4gb3B0aW9ucy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPVxuICAgICAgICAgICAgcmVxdWVzdC5tZXRob2QgKyAnICcgKyByZXF1ZXN0LnVybCArICcgSFRUUC8nICsgcmVxdWVzdC5odHRwVmVyc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBTdHJpY3QgcGFyc2luZyBkb2Vzbid0IGFsbG93IG9sZGVyIGRyYWZ0IGhlYWRlcnMuICovXG4gICAgICAgICAgdGhyb3cgKG5ldyBTdHJpY3RQYXJzaW5nRXJyb3IoJ3JlcXVlc3QtbGluZSBpcyBub3QgYSB2YWxpZCBoZWFkZXIgJyArXG4gICAgICAgICAgICAnd2l0aCBzdHJpY3QgcGFyc2luZyBlbmFibGVkLicpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoID09PSAnKHJlcXVlc3QtdGFyZ2V0KScpIHtcbiAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz1cbiAgICAgICAgICAnKHJlcXVlc3QtdGFyZ2V0KTogJyArIHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgKyAnICcgK1xuICAgICAgICAgIHJlcXVlc3QudXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVxdWVzdC5oZWFkZXJzW2hdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKGggKyAnIHdhcyBub3QgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz0gaCArICc6ICcgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpICsgMSkgPCBwYXJzZWQucGFyYW1zLmhlYWRlcnMubGVuZ3RoKVxuICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPSAnXFxuJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBhZ2FpbnN0IHRoZSBjb25zdHJhaW50c1xuICAgIHZhciBkYXRlO1xuICAgIGlmIChyZXF1ZXN0LmhlYWRlcnMuZGF0ZSB8fCByZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShyZXF1ZXN0LmhlYWRlcnMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgdmFyIHNrZXcgPSBNYXRoLmFicyhub3cuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lKCkpO1xuXG4gICAgICBpZiAoc2tldyA+IG9wdGlvbnMuY2xvY2tTa2V3ICogMTAwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXhwaXJlZFJlcXVlc3RFcnJvcignY2xvY2sgc2tldyBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNrZXcgLyAxMDAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzIHdhcyBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2xvY2tTa2V3ICsgJ3MnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGRyKSB7XG4gICAgICAvLyBSZW1lbWJlciB0aGF0IHdlIGFscmVhZHkgY2hlY2tlZCBhbnkgaGVhZGVycyBpbiB0aGUgcGFyYW1zXG4gICAgICAvLyB3ZXJlIGluIHRoZSByZXF1ZXN0LCBzbyBpZiB0aGlzIHBhc3NlcyB3ZSdyZSBnb29kLlxuICAgICAgaWYgKHBhcnNlZC5wYXJhbXMuaGVhZGVycy5pbmRleE9mKGhkci50b0xvd2VyQ2FzZSgpKSA8IDApXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nSGVhZGVyRXJyb3IoaGRyICsgJyB3YXMgbm90IGEgc2lnbmVkIGhlYWRlcicpO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtcykge1xuICAgICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtcy5pbmRleE9mKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtKSA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1zRXJyb3IocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgbm90IGEgc3VwcG9ydGVkIGFsZ29yaXRobScpO1xuICAgIH1cblxuICAgIHBhcnNlZC5hbGdvcml0aG0gPSBwYXJzZWQucGFyYW1zLmFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgIHBhcnNlZC5rZXlJZCA9IHBhcnNlZC5wYXJhbXMua2V5SWQ7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG59O1xuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJ1dGlsIiwidXRpbHMiLCJIQVNIX0FMR09TIiwiUEtfQUxHT1MiLCJIdHRwU2lnbmF0dXJlRXJyb3IiLCJJbnZhbGlkQWxnb3JpdGhtRXJyb3IiLCJ2YWxpZGF0ZUFsZ29yaXRobSIsIlN0YXRlIiwiTmV3IiwiUGFyYW1zIiwiUGFyYW1zU3RhdGUiLCJOYW1lIiwiUXVvdGUiLCJWYWx1ZSIsIkNvbW1hIiwiRXhwaXJlZFJlcXVlc3RFcnJvciIsIm1lc3NhZ2UiLCJjYWxsIiwiaW5oZXJpdHMiLCJJbnZhbGlkSGVhZGVyRXJyb3IiLCJJbnZhbGlkUGFyYW1zRXJyb3IiLCJNaXNzaW5nSGVhZGVyRXJyb3IiLCJTdHJpY3RQYXJzaW5nRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2VSZXF1ZXN0IiwicmVxdWVzdCIsIm9wdGlvbnMiLCJvYmplY3QiLCJoZWFkZXJzIiwidW5kZWZpbmVkIiwiYXJyYXlPZlN0cmluZyIsIm9wdGlvbmFsRmluaXRlIiwiY2xvY2tTa2V3IiwiYXV0aHpIZWFkZXJOYW1lIiwiYXV0aG9yaXphdGlvbkhlYWRlck5hbWUiLCJpIiwic3RhdGUiLCJzdWJzdGF0ZSIsInRtcE5hbWUiLCJ0bXBWYWx1ZSIsInBhcnNlZCIsInNjaGVtZSIsInBhcmFtcyIsInNpZ25pbmdTdHJpbmciLCJhdXRoeiIsImxlbmd0aCIsImMiLCJjaGFyQXQiLCJOdW1iZXIiLCJjb2RlIiwiY2hhckNvZGVBdCIsIkVycm9yIiwic3BsaXQiLCJrZXlJZCIsImFsZ29yaXRobSIsInNpZ25hdHVyZSIsInRvTG93ZXJDYXNlIiwiZSIsImgiLCJzdHJpY3QiLCJtZXRob2QiLCJ1cmwiLCJodHRwVmVyc2lvbiIsInZhbHVlIiwiZGF0ZSIsIkRhdGUiLCJub3ciLCJza2V3IiwiTWF0aCIsImFicyIsImdldFRpbWUiLCJmb3JFYWNoIiwiaGRyIiwiaW5kZXhPZiIsImFsZ29yaXRobXMiLCJ0b1VwcGVyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/http-signature/lib/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/http-signature/lib/signer.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/signer.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(ssr)/./node_modules/assert-plus/assert.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(ssr)/./node_modules/sshpk/lib/index.js\");\nvar jsprim = __webpack_require__(/*! jsprim */ \"(ssr)/./node_modules/jsprim/lib/jsprim.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/http-signature/lib/utils.js\");\nvar sprintf = (__webpack_require__(/*! util */ \"util\").format);\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar validateAlgorithm = utils.validateAlgorithm;\n///--- Globals\nvar AUTHZ_FMT = 'Signature keyId=\"%s\",algorithm=\"%s\",headers=\"%s\",signature=\"%s\"';\n///--- Specific Errors\nfunction MissingHeaderError(message) {\n    HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\nfunction StrictParsingError(message) {\n    HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n/* See createSigner() */ function RequestSigner(options) {\n    assert.object(options, \"options\");\n    var alg = [];\n    if (options.algorithm !== undefined) {\n        assert.string(options.algorithm, \"options.algorithm\");\n        alg = validateAlgorithm(options.algorithm);\n    }\n    this.rs_alg = alg;\n    /*\n   * RequestSigners come in two varieties: ones with an rs_signFunc, and ones\n   * with an rs_signer.\n   *\n   * rs_signFunc-based RequestSigners have to build up their entire signing\n   * string within the rs_lines array and give it to rs_signFunc as a single\n   * concat'd blob. rs_signer-based RequestSigners can add a line at a time to\n   * their signing state by using rs_signer.update(), thus only needing to\n   * buffer the hash function state and one line at a time.\n   */ if (options.sign !== undefined) {\n        assert.func(options.sign, \"options.sign\");\n        this.rs_signFunc = options.sign;\n    } else if (alg[0] === \"hmac\" && options.key !== undefined) {\n        assert.string(options.keyId, \"options.keyId\");\n        this.rs_keyId = options.keyId;\n        if (typeof options.key !== \"string\" && !Buffer.isBuffer(options.key)) throw new TypeError(\"options.key for HMAC must be a string or Buffer\");\n        /*\n     * Make an rs_signer for HMACs, not a rs_signFunc -- HMACs digest their\n     * data in chunks rather than requiring it all to be given in one go\n     * at the end, so they are more similar to signers than signFuncs.\n     */ this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);\n        this.rs_signer.sign = function() {\n            var digest = this.digest(\"base64\");\n            return {\n                hashAlgorithm: alg[1],\n                toString: function() {\n                    return digest;\n                }\n            };\n        };\n    } else if (options.key !== undefined) {\n        var key = options.key;\n        if (typeof key === \"string\" || Buffer.isBuffer(key)) key = sshpk.parsePrivateKey(key);\n        assert.ok(sshpk.PrivateKey.isPrivateKey(key, [\n            1,\n            2\n        ]), \"options.key must be a sshpk.PrivateKey\");\n        this.rs_key = key;\n        assert.string(options.keyId, \"options.keyId\");\n        this.rs_keyId = options.keyId;\n        if (!PK_ALGOS[key.type]) {\n            throw new InvalidAlgorithmError(key.type.toUpperCase() + \" type \" + \"keys are not supported\");\n        }\n        if (alg[0] !== undefined && key.type !== alg[0]) {\n            throw new InvalidAlgorithmError(\"options.key must be a \" + alg[0].toUpperCase() + \" key, was given a \" + key.type.toUpperCase() + \" key instead\");\n        }\n        this.rs_signer = key.createSign(alg[1]);\n    } else {\n        throw new TypeError(\"options.sign (func) or options.key is required\");\n    }\n    this.rs_headers = [];\n    this.rs_lines = [];\n}\n/**\n * Adds a header to be signed, with its value, into this signer.\n *\n * @param {String} header\n * @param {String} value\n * @return {String} value written\n */ RequestSigner.prototype.writeHeader = function(header, value) {\n    assert.string(header, \"header\");\n    header = header.toLowerCase();\n    assert.string(value, \"value\");\n    this.rs_headers.push(header);\n    if (this.rs_signFunc) {\n        this.rs_lines.push(header + \": \" + value);\n    } else {\n        var line = header + \": \" + value;\n        if (this.rs_headers.length > 0) line = \"\\n\" + line;\n        this.rs_signer.update(line);\n    }\n    return value;\n};\n/**\n * Adds a default Date header, returning its value.\n *\n * @return {String}\n */ RequestSigner.prototype.writeDateHeader = function() {\n    return this.writeHeader(\"date\", jsprim.rfc1123(new Date()));\n};\n/**\n * Adds the request target line to be signed.\n *\n * @param {String} method, HTTP method (e.g. 'get', 'post', 'put')\n * @param {String} path\n */ RequestSigner.prototype.writeTarget = function(method, path) {\n    assert.string(method, \"method\");\n    assert.string(path, \"path\");\n    method = method.toLowerCase();\n    this.writeHeader(\"(request-target)\", method + \" \" + path);\n};\n/**\n * Calculate the value for the Authorization header on this request\n * asynchronously.\n *\n * @param {Func} callback (err, authz)\n */ RequestSigner.prototype.sign = function(cb) {\n    assert.func(cb, \"callback\");\n    if (this.rs_headers.length < 1) throw new Error(\"At least one header must be signed\");\n    var alg, authz;\n    if (this.rs_signFunc) {\n        var data = this.rs_lines.join(\"\\n\");\n        var self = this;\n        this.rs_signFunc(data, function(err, sig) {\n            if (err) {\n                cb(err);\n                return;\n            }\n            try {\n                assert.object(sig, \"signature\");\n                assert.string(sig.keyId, \"signature.keyId\");\n                assert.string(sig.algorithm, \"signature.algorithm\");\n                assert.string(sig.signature, \"signature.signature\");\n                alg = validateAlgorithm(sig.algorithm);\n                authz = sprintf(AUTHZ_FMT, sig.keyId, sig.algorithm, self.rs_headers.join(\" \"), sig.signature);\n            } catch (e) {\n                cb(e);\n                return;\n            }\n            cb(null, authz);\n        });\n    } else {\n        try {\n            var sigObj = this.rs_signer.sign();\n        } catch (e) {\n            cb(e);\n            return;\n        }\n        alg = (this.rs_alg[0] || this.rs_key.type) + \"-\" + sigObj.hashAlgorithm;\n        var signature = sigObj.toString();\n        authz = sprintf(AUTHZ_FMT, this.rs_keyId, alg, this.rs_headers.join(\" \"), signature);\n        cb(null, authz);\n    }\n};\n///--- Exported API\nmodule.exports = {\n    /**\n   * Identifies whether a given object is a request signer or not.\n   *\n   * @param {Object} object, the object to identify\n   * @returns {Boolean}\n   */ isSigner: function(obj) {\n        if (typeof obj === \"object\" && obj instanceof RequestSigner) return true;\n        return false;\n    },\n    /**\n   * Creates a request signer, used to asynchronously build a signature\n   * for a request (does not have to be an http.ClientRequest).\n   *\n   * @param {Object} options, either:\n   *                   - {String} keyId\n   *                   - {String|Buffer} key\n   *                   - {String} algorithm (optional, required for HMAC)\n   *                 or:\n   *                   - {Func} sign (data, cb)\n   * @return {RequestSigner}\n   */ createSigner: function createSigner(options) {\n        return new RequestSigner(options);\n    },\n    /**\n   * Adds an 'Authorization' header to an http.ClientRequest object.\n   *\n   * Note that this API will add a Date header if it's not already set. Any\n   * other headers in the options.headers array MUST be present, or this\n   * will throw.\n   *\n   * You shouldn't need to check the return type; it's just there if you want\n   * to be pedantic.\n   *\n   * The optional flag indicates whether parsing should use strict enforcement\n   * of the version draft-cavage-http-signatures-04 of the spec or beyond.\n   * The default is to be loose and support\n   * older versions for compatibility.\n   *\n   * @param {Object} request an instance of http.ClientRequest.\n   * @param {Object} options signing parameters object:\n   *                   - {String} keyId required.\n   *                   - {String} key required (either a PEM or HMAC key).\n   *                   - {Array} headers optional; defaults to ['date'].\n   *                   - {String} algorithm optional (unless key is HMAC);\n   *                              default is the same as the sshpk default\n   *                              signing algorithm for the type of key given\n   *                   - {String} httpVersion optional; defaults to '1.1'.\n   *                   - {Boolean} strict optional; defaults to 'false'.\n   * @return {Boolean} true if Authorization (and optionally Date) were added.\n   * @throws {TypeError} on bad parameter types (input).\n   * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with\n   *                                 the given key.\n   * @throws {sshpk.KeyParseError} if key was bad.\n   * @throws {MissingHeaderError} if a header to be signed was specified but\n   *                              was not present.\n   */ signRequest: function signRequest(request, options) {\n        assert.object(request, \"request\");\n        assert.object(options, \"options\");\n        assert.optionalString(options.algorithm, \"options.algorithm\");\n        assert.string(options.keyId, \"options.keyId\");\n        assert.optionalArrayOfString(options.headers, \"options.headers\");\n        assert.optionalString(options.httpVersion, \"options.httpVersion\");\n        if (!request.getHeader(\"Date\")) request.setHeader(\"Date\", jsprim.rfc1123(new Date()));\n        if (!options.headers) options.headers = [\n            \"date\"\n        ];\n        if (!options.httpVersion) options.httpVersion = \"1.1\";\n        var alg = [];\n        if (options.algorithm) {\n            options.algorithm = options.algorithm.toLowerCase();\n            alg = validateAlgorithm(options.algorithm);\n        }\n        var i;\n        var stringToSign = \"\";\n        for(i = 0; i < options.headers.length; i++){\n            if (typeof options.headers[i] !== \"string\") throw new TypeError(\"options.headers must be an array of Strings\");\n            var h = options.headers[i].toLowerCase();\n            if (h === \"request-line\") {\n                if (!options.strict) {\n                    /**\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */ stringToSign += request.method + \" \" + request.path + \" HTTP/\" + options.httpVersion;\n                } else {\n                    /* Strict parsing doesn't allow older draft headers. */ throw new StrictParsingError(\"request-line is not a valid header \" + \"with strict parsing enabled.\");\n                }\n            } else if (h === \"(request-target)\") {\n                stringToSign += \"(request-target): \" + request.method.toLowerCase() + \" \" + request.path;\n            } else {\n                var value = request.getHeader(h);\n                if (value === undefined || value === \"\") {\n                    throw new MissingHeaderError(h + \" was not in the request\");\n                }\n                stringToSign += h + \": \" + value;\n            }\n            if (i + 1 < options.headers.length) stringToSign += \"\\n\";\n        }\n        /* This is just for unit tests. */ if (request.hasOwnProperty(\"_stringToSign\")) {\n            request._stringToSign = stringToSign;\n        }\n        var signature;\n        if (alg[0] === \"hmac\") {\n            if (typeof options.key !== \"string\" && !Buffer.isBuffer(options.key)) throw new TypeError(\"options.key must be a string or Buffer\");\n            var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);\n            hmac.update(stringToSign);\n            signature = hmac.digest(\"base64\");\n        } else {\n            var key = options.key;\n            if (typeof key === \"string\" || Buffer.isBuffer(key)) key = sshpk.parsePrivateKey(options.key);\n            assert.ok(sshpk.PrivateKey.isPrivateKey(key, [\n                1,\n                2\n            ]), \"options.key must be a sshpk.PrivateKey\");\n            if (!PK_ALGOS[key.type]) {\n                throw new InvalidAlgorithmError(key.type.toUpperCase() + \" type \" + \"keys are not supported\");\n            }\n            if (alg[0] !== undefined && key.type !== alg[0]) {\n                throw new InvalidAlgorithmError(\"options.key must be a \" + alg[0].toUpperCase() + \" key, was given a \" + key.type.toUpperCase() + \" key instead\");\n            }\n            var signer = key.createSign(alg[1]);\n            signer.update(stringToSign);\n            var sigObj = signer.sign();\n            if (!HASH_ALGOS[sigObj.hashAlgorithm]) {\n                throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + \" is not a supported hash algorithm\");\n            }\n            options.algorithm = key.type + \"-\" + sigObj.hashAlgorithm;\n            signature = sigObj.toString();\n            assert.notStrictEqual(signature, \"\", \"empty signature produced\");\n        }\n        var authzHeaderName = options.authorizationHeaderName || \"Authorization\";\n        request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(\" \"), signature));\n        return true;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3NpZ25lci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvREFBb0Q7O0FBRXBELElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlHLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ25CLElBQUlJLFFBQVFKLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlLLFNBQVNMLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlNLFFBQVFOLG1CQUFPQSxDQUFDO0FBRXBCLElBQUlPLFVBQVVQLGdEQUFzQjtBQUVwQyxJQUFJUyxhQUFhSCxNQUFNRyxVQUFVO0FBQ2pDLElBQUlDLFdBQVdKLE1BQU1JLFFBQVE7QUFDN0IsSUFBSUMsd0JBQXdCTCxNQUFNSyxxQkFBcUI7QUFDdkQsSUFBSUMscUJBQXFCTixNQUFNTSxrQkFBa0I7QUFDakQsSUFBSUMsb0JBQW9CUCxNQUFNTyxpQkFBaUI7QUFFL0MsY0FBYztBQUVkLElBQUlDLFlBQ0Y7QUFFRixzQkFBc0I7QUFFdEIsU0FBU0MsbUJBQW1CQyxPQUFPO0lBQ2pDSixtQkFBbUJLLElBQUksQ0FBQyxJQUFJLEVBQUVELFNBQVNEO0FBQ3pDO0FBQ0FaLEtBQUtlLFFBQVEsQ0FBQ0gsb0JBQW9CSDtBQUVsQyxTQUFTTyxtQkFBbUJILE9BQU87SUFDakNKLG1CQUFtQkssSUFBSSxDQUFDLElBQUksRUFBRUQsU0FBU0c7QUFDekM7QUFDQWhCLEtBQUtlLFFBQVEsQ0FBQ0Msb0JBQW9CUDtBQUVsQyxzQkFBc0IsR0FDdEIsU0FBU1EsY0FBY0MsT0FBTztJQUM1QnRCLE9BQU91QixNQUFNLENBQUNELFNBQVM7SUFFdkIsSUFBSUUsTUFBTSxFQUFFO0lBQ1osSUFBSUYsUUFBUUcsU0FBUyxLQUFLQyxXQUFXO1FBQ25DMUIsT0FBTzJCLE1BQU0sQ0FBQ0wsUUFBUUcsU0FBUyxFQUFF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QVFnRix1QkFBdUIsSUFBSTtRQUV6RGpCLFFBQVFNLFNBQVMsQ0FBQ1UsaUJBQWlCN0YsUUFBUU8sV0FDQU8sUUFBUVcsS0FBSyxFQUNiWCxRQUFRRyxTQUFTLEVBQ2pCSCxRQUFRa0UsT0FBTyxDQUFDaEIsSUFBSSxDQUFDLE1BQ3JCSTtRQUUzQyxPQUFPO0lBQ1Q7QUFFRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi9zaWduZXIuanM/YTk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBzc2hwayA9IHJlcXVpcmUoJ3NzaHBrJyk7XG52YXIganNwcmltID0gcmVxdWlyZSgnanNwcmltJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBzcHJpbnRmID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxudmFyIEhBU0hfQUxHT1MgPSB1dGlscy5IQVNIX0FMR09TO1xudmFyIFBLX0FMR09TID0gdXRpbHMuUEtfQUxHT1M7XG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gdXRpbHMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xudmFyIEh0dHBTaWduYXR1cmVFcnJvciA9IHV0aWxzLkh0dHBTaWduYXR1cmVFcnJvcjtcbnZhciB2YWxpZGF0ZUFsZ29yaXRobSA9IHV0aWxzLnZhbGlkYXRlQWxnb3JpdGhtO1xuXG4vLy8tLS0gR2xvYmFsc1xuXG52YXIgQVVUSFpfRk1UID1cbiAgJ1NpZ25hdHVyZSBrZXlJZD1cIiVzXCIsYWxnb3JpdGhtPVwiJXNcIixoZWFkZXJzPVwiJXNcIixzaWduYXR1cmU9XCIlc1wiJztcblxuLy8vLS0tIFNwZWNpZmljIEVycm9yc1xuXG5mdW5jdGlvbiBNaXNzaW5nSGVhZGVyRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBNaXNzaW5nSGVhZGVyRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhNaXNzaW5nSGVhZGVyRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbmZ1bmN0aW9uIFN0cmljdFBhcnNpbmdFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIFN0cmljdFBhcnNpbmdFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKFN0cmljdFBhcnNpbmdFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuLyogU2VlIGNyZWF0ZVNpZ25lcigpICovXG5mdW5jdGlvbiBSZXF1ZXN0U2lnbmVyKG9wdGlvbnMpIHtcbiAgYXNzZXJ0Lm9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXG4gIHZhciBhbGcgPSBbXTtcbiAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMuYWxnb3JpdGhtLCAnb3B0aW9ucy5hbGdvcml0aG0nKTtcbiAgICBhbGcgPSB2YWxpZGF0ZUFsZ29yaXRobShvcHRpb25zLmFsZ29yaXRobSk7XG4gIH1cbiAgdGhpcy5yc19hbGcgPSBhbGc7XG5cbiAgLypcbiAgICogUmVxdWVzdFNpZ25lcnMgY29tZSBpbiB0d28gdmFyaWV0aWVzOiBvbmVzIHdpdGggYW4gcnNfc2lnbkZ1bmMsIGFuZCBvbmVzXG4gICAqIHdpdGggYW4gcnNfc2lnbmVyLlxuICAgKlxuICAgKiByc19zaWduRnVuYy1iYXNlZCBSZXF1ZXN0U2lnbmVycyBoYXZlIHRvIGJ1aWxkIHVwIHRoZWlyIGVudGlyZSBzaWduaW5nXG4gICAqIHN0cmluZyB3aXRoaW4gdGhlIHJzX2xpbmVzIGFycmF5IGFuZCBnaXZlIGl0IHRvIHJzX3NpZ25GdW5jIGFzIGEgc2luZ2xlXG4gICAqIGNvbmNhdCdkIGJsb2IuIHJzX3NpZ25lci1iYXNlZCBSZXF1ZXN0U2lnbmVycyBjYW4gYWRkIGEgbGluZSBhdCBhIHRpbWUgdG9cbiAgICogdGhlaXIgc2lnbmluZyBzdGF0ZSBieSB1c2luZyByc19zaWduZXIudXBkYXRlKCksIHRodXMgb25seSBuZWVkaW5nIHRvXG4gICAqIGJ1ZmZlciB0aGUgaGFzaCBmdW5jdGlvbiBzdGF0ZSBhbmQgb25lIGxpbmUgYXQgYSB0aW1lLlxuICAgKi9cbiAgaWYgKG9wdGlvbnMuc2lnbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0LmZ1bmMob3B0aW9ucy5zaWduLCAnb3B0aW9ucy5zaWduJyk7XG4gICAgdGhpcy5yc19zaWduRnVuYyA9IG9wdGlvbnMuc2lnbjtcblxuICB9IGVsc2UgaWYgKGFsZ1swXSA9PT0gJ2htYWMnICYmIG9wdGlvbnMua2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMua2V5SWQsICdvcHRpb25zLmtleUlkJyk7XG4gICAgdGhpcy5yc19rZXlJZCA9IG9wdGlvbnMua2V5SWQ7XG5cbiAgICBpZiAodHlwZW9mIChvcHRpb25zLmtleSkgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5rZXkpKVxuICAgICAgdGhyb3cgKG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMua2V5IGZvciBITUFDIG11c3QgYmUgYSBzdHJpbmcgb3IgQnVmZmVyJykpO1xuXG4gICAgLypcbiAgICAgKiBNYWtlIGFuIHJzX3NpZ25lciBmb3IgSE1BQ3MsIG5vdCBhIHJzX3NpZ25GdW5jIC0tIEhNQUNzIGRpZ2VzdCB0aGVpclxuICAgICAqIGRhdGEgaW4gY2h1bmtzIHJhdGhlciB0aGFuIHJlcXVpcmluZyBpdCBhbGwgdG8gYmUgZ2l2ZW4gaW4gb25lIGdvXG4gICAgICogYXQgdGhlIGVuZCwgc28gdGhleSBhcmUgbW9yZSBzaW1pbGFyIHRvIHNpZ25lcnMgdGhhbiBzaWduRnVuY3MuXG4gICAgICovXG4gICAgdGhpcy5yc19zaWduZXIgPSBjcnlwdG8uY3JlYXRlSG1hYyhhbGdbMV0udG9VcHBlckNhc2UoKSwgb3B0aW9ucy5rZXkpO1xuICAgIHRoaXMucnNfc2lnbmVyLnNpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGlnZXN0ID0gdGhpcy5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgICAgcmV0dXJuICh7XG4gICAgICAgIGhhc2hBbGdvcml0aG06IGFsZ1sxXSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChkaWdlc3QpOyB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBpZiAodHlwZW9mIChrZXkpID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIoa2V5KSlcbiAgICAgIGtleSA9IHNzaHBrLnBhcnNlUHJpdmF0ZUtleShrZXkpO1xuXG4gICAgYXNzZXJ0Lm9rKHNzaHBrLlByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSwgWzEsIDJdKSxcbiAgICAgICdvcHRpb25zLmtleSBtdXN0IGJlIGEgc3NocGsuUHJpdmF0ZUtleScpO1xuICAgIHRoaXMucnNfa2V5ID0ga2V5O1xuXG4gICAgYXNzZXJ0LnN0cmluZyhvcHRpb25zLmtleUlkLCAnb3B0aW9ucy5rZXlJZCcpO1xuICAgIHRoaXMucnNfa2V5SWQgPSBvcHRpb25zLmtleUlkO1xuXG4gICAgaWYgKCFQS19BTEdPU1trZXkudHlwZV0pIHtcbiAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGtleS50eXBlLnRvVXBwZXJDYXNlKCkgKyAnIHR5cGUgJyArXG4gICAgICAgICdrZXlzIGFyZSBub3Qgc3VwcG9ydGVkJykpO1xuICAgIH1cblxuICAgIGlmIChhbGdbMF0gIT09IHVuZGVmaW5lZCAmJiBrZXkudHlwZSAhPT0gYWxnWzBdKSB7XG4gICAgICB0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcignb3B0aW9ucy5rZXkgbXVzdCBiZSBhICcgK1xuICAgICAgICBhbGdbMF0udG9VcHBlckNhc2UoKSArICcga2V5LCB3YXMgZ2l2ZW4gYSAnICtcbiAgICAgICAga2V5LnR5cGUudG9VcHBlckNhc2UoKSArICcga2V5IGluc3RlYWQnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5yc19zaWduZXIgPSBrZXkuY3JlYXRlU2lnbihhbGdbMV0pO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgKG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuc2lnbiAoZnVuYykgb3Igb3B0aW9ucy5rZXkgaXMgcmVxdWlyZWQnKSk7XG4gIH1cblxuICB0aGlzLnJzX2hlYWRlcnMgPSBbXTtcbiAgdGhpcy5yc19saW5lcyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZHMgYSBoZWFkZXIgdG8gYmUgc2lnbmVkLCB3aXRoIGl0cyB2YWx1ZSwgaW50byB0aGlzIHNpZ25lci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gdmFsdWUgd3JpdHRlblxuICovXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS53cml0ZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIsIHZhbHVlKSB7XG4gIGFzc2VydC5zdHJpbmcoaGVhZGVyLCAnaGVhZGVyJyk7XG4gIGhlYWRlciA9IGhlYWRlci50b0xvd2VyQ2FzZSgpO1xuICBhc3NlcnQuc3RyaW5nKHZhbHVlLCAndmFsdWUnKTtcblxuICB0aGlzLnJzX2hlYWRlcnMucHVzaChoZWFkZXIpO1xuXG4gIGlmICh0aGlzLnJzX3NpZ25GdW5jKSB7XG4gICAgdGhpcy5yc19saW5lcy5wdXNoKGhlYWRlciArICc6ICcgKyB2YWx1ZSk7XG5cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGluZSA9IGhlYWRlciArICc6ICcgKyB2YWx1ZTtcbiAgICBpZiAodGhpcy5yc19oZWFkZXJzLmxlbmd0aCA+IDApXG4gICAgICBsaW5lID0gJ1xcbicgKyBsaW5lO1xuICAgIHRoaXMucnNfc2lnbmVyLnVwZGF0ZShsaW5lKTtcbiAgfVxuXG4gIHJldHVybiAodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZGVmYXVsdCBEYXRlIGhlYWRlciwgcmV0dXJuaW5nIGl0cyB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLndyaXRlRGF0ZUhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLndyaXRlSGVhZGVyKCdkYXRlJywganNwcmltLnJmYzExMjMobmV3IERhdGUoKSkpKTtcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgcmVxdWVzdCB0YXJnZXQgbGluZSB0byBiZSBzaWduZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCwgSFRUUCBtZXRob2QgKGUuZy4gJ2dldCcsICdwb3N0JywgJ3B1dCcpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICovXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS53cml0ZVRhcmdldCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhdGgpIHtcbiAgYXNzZXJ0LnN0cmluZyhtZXRob2QsICdtZXRob2QnKTtcbiAgYXNzZXJ0LnN0cmluZyhwYXRoLCAncGF0aCcpO1xuICBtZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy53cml0ZUhlYWRlcignKHJlcXVlc3QtdGFyZ2V0KScsIG1ldGhvZCArICcgJyArIHBhdGgpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHZhbHVlIGZvciB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXIgb24gdGhpcyByZXF1ZXN0XG4gKiBhc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN9IGNhbGxiYWNrIChlcnIsIGF1dGh6KVxuICovXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKGNiKSB7XG4gIGFzc2VydC5mdW5jKGNiLCAnY2FsbGJhY2snKTtcblxuICBpZiAodGhpcy5yc19oZWFkZXJzLmxlbmd0aCA8IDEpXG4gICAgdGhyb3cgKG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIGhlYWRlciBtdXN0IGJlIHNpZ25lZCcpKTtcblxuICB2YXIgYWxnLCBhdXRoejtcbiAgaWYgKHRoaXMucnNfc2lnbkZ1bmMpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMucnNfbGluZXMuam9pbignXFxuJyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucnNfc2lnbkZ1bmMoZGF0YSwgZnVuY3Rpb24gKGVyciwgc2lnKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGFzc2VydC5vYmplY3Qoc2lnLCAnc2lnbmF0dXJlJyk7XG4gICAgICAgIGFzc2VydC5zdHJpbmcoc2lnLmtleUlkLCAnc2lnbmF0dXJlLmtleUlkJyk7XG4gICAgICAgIGFzc2VydC5zdHJpbmcoc2lnLmFsZ29yaXRobSwgJ3NpZ25hdHVyZS5hbGdvcml0aG0nKTtcbiAgICAgICAgYXNzZXJ0LnN0cmluZyhzaWcuc2lnbmF0dXJlLCAnc2lnbmF0dXJlLnNpZ25hdHVyZScpO1xuICAgICAgICBhbGcgPSB2YWxpZGF0ZUFsZ29yaXRobShzaWcuYWxnb3JpdGhtKTtcblxuICAgICAgICBhdXRoeiA9IHNwcmludGYoQVVUSFpfRk1ULFxuICAgICAgICAgIHNpZy5rZXlJZCxcbiAgICAgICAgICBzaWcuYWxnb3JpdGhtLFxuICAgICAgICAgIHNlbGYucnNfaGVhZGVycy5qb2luKCcgJyksXG4gICAgICAgICAgc2lnLnNpZ25hdHVyZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNiKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYihudWxsLCBhdXRoeik7XG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHNpZ09iaiA9IHRoaXMucnNfc2lnbmVyLnNpZ24oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWxnID0gKHRoaXMucnNfYWxnWzBdIHx8IHRoaXMucnNfa2V5LnR5cGUpICsgJy0nICsgc2lnT2JqLmhhc2hBbGdvcml0aG07XG4gICAgdmFyIHNpZ25hdHVyZSA9IHNpZ09iai50b1N0cmluZygpO1xuICAgIGF1dGh6ID0gc3ByaW50ZihBVVRIWl9GTVQsXG4gICAgICB0aGlzLnJzX2tleUlkLFxuICAgICAgYWxnLFxuICAgICAgdGhpcy5yc19oZWFkZXJzLmpvaW4oJyAnKSxcbiAgICAgIHNpZ25hdHVyZSk7XG4gICAgY2IobnVsbCwgYXV0aHopO1xuICB9XG59O1xuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogSWRlbnRpZmllcyB3aGV0aGVyIGEgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVxdWVzdCBzaWduZXIgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0LCB0aGUgb2JqZWN0IHRvIGlkZW50aWZ5XG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNTaWduZXI6IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIChvYmopID09PSAnb2JqZWN0JyAmJiBvYmogaW5zdGFuY2VvZiBSZXF1ZXN0U2lnbmVyKVxuICAgICAgcmV0dXJuICh0cnVlKTtcbiAgICByZXR1cm4gKGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlcXVlc3Qgc2lnbmVyLCB1c2VkIHRvIGFzeW5jaHJvbm91c2x5IGJ1aWxkIGEgc2lnbmF0dXJlXG4gICAqIGZvciBhIHJlcXVlc3QgKGRvZXMgbm90IGhhdmUgdG8gYmUgYW4gaHR0cC5DbGllbnRSZXF1ZXN0KS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMsIGVpdGhlcjpcbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBrZXlJZFxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd8QnVmZmVyfSBrZXlcbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhbGdvcml0aG0gKG9wdGlvbmFsLCByZXF1aXJlZCBmb3IgSE1BQylcbiAgICogICAgICAgICAgICAgICAgIG9yOlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtGdW5jfSBzaWduIChkYXRhLCBjYilcbiAgICogQHJldHVybiB7UmVxdWVzdFNpZ25lcn1cbiAgICovXG4gIGNyZWF0ZVNpZ25lcjogZnVuY3Rpb24gY3JlYXRlU2lnbmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG5ldyBSZXF1ZXN0U2lnbmVyKG9wdGlvbnMpKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhbiAnQXV0aG9yaXphdGlvbicgaGVhZGVyIHRvIGFuIGh0dHAuQ2xpZW50UmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIEFQSSB3aWxsIGFkZCBhIERhdGUgaGVhZGVyIGlmIGl0J3Mgbm90IGFscmVhZHkgc2V0LiBBbnlcbiAgICogb3RoZXIgaGVhZGVycyBpbiB0aGUgb3B0aW9ucy5oZWFkZXJzIGFycmF5IE1VU1QgYmUgcHJlc2VudCwgb3IgdGhpc1xuICAgKiB3aWxsIHRocm93LlxuICAgKlxuICAgKiBZb3Ugc2hvdWxkbid0IG5lZWQgdG8gY2hlY2sgdGhlIHJldHVybiB0eXBlOyBpdCdzIGp1c3QgdGhlcmUgaWYgeW91IHdhbnRcbiAgICogdG8gYmUgcGVkYW50aWMuXG4gICAqXG4gICAqIFRoZSBvcHRpb25hbCBmbGFnIGluZGljYXRlcyB3aGV0aGVyIHBhcnNpbmcgc2hvdWxkIHVzZSBzdHJpY3QgZW5mb3JjZW1lbnRcbiAgICogb2YgdGhlIHZlcnNpb24gZHJhZnQtY2F2YWdlLWh0dHAtc2lnbmF0dXJlcy0wNCBvZiB0aGUgc3BlYyBvciBiZXlvbmQuXG4gICAqIFRoZSBkZWZhdWx0IGlzIHRvIGJlIGxvb3NlIGFuZCBzdXBwb3J0XG4gICAqIG9sZGVyIHZlcnNpb25zIGZvciBjb21wYXRpYmlsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBhbiBpbnN0YW5jZSBvZiBodHRwLkNsaWVudFJlcXVlc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHNpZ25pbmcgcGFyYW1ldGVycyBvYmplY3Q6XG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30ga2V5SWQgcmVxdWlyZWQuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30ga2V5IHJlcXVpcmVkIChlaXRoZXIgYSBQRU0gb3IgSE1BQyBrZXkpLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtBcnJheX0gaGVhZGVycyBvcHRpb25hbDsgZGVmYXVsdHMgdG8gWydkYXRlJ10uXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYWxnb3JpdGhtIG9wdGlvbmFsICh1bmxlc3Mga2V5IGlzIEhNQUMpO1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgaXMgdGhlIHNhbWUgYXMgdGhlIHNzaHBrIGRlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduaW5nIGFsZ29yaXRobSBmb3IgdGhlIHR5cGUgb2Yga2V5IGdpdmVuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gaHR0cFZlcnNpb24gb3B0aW9uYWw7IGRlZmF1bHRzIHRvICcxLjEnLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBzdHJpY3Qgb3B0aW9uYWw7IGRlZmF1bHRzIHRvICdmYWxzZScuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgQXV0aG9yaXphdGlvbiAoYW5kIG9wdGlvbmFsbHkgRGF0ZSkgd2VyZSBhZGRlZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgcGFyYW1ldGVyIHR5cGVzIChpbnB1dCkuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn0gaWYgYWxnb3JpdGhtIHdhcyBiYWQgb3IgaW5jb21wYXRpYmxlIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZ2l2ZW4ga2V5LlxuICAgKiBAdGhyb3dzIHtzc2hway5LZXlQYXJzZUVycm9yfSBpZiBrZXkgd2FzIGJhZC5cbiAgICogQHRocm93cyB7TWlzc2luZ0hlYWRlckVycm9yfSBpZiBhIGhlYWRlciB0byBiZSBzaWduZWQgd2FzIHNwZWNpZmllZCBidXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBzaWduUmVxdWVzdDogZnVuY3Rpb24gc2lnblJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucykge1xuICAgIGFzc2VydC5vYmplY3QocmVxdWVzdCwgJ3JlcXVlc3QnKTtcbiAgICBhc3NlcnQub2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdGlvbnMuYWxnb3JpdGhtLCAnb3B0aW9ucy5hbGdvcml0aG0nKTtcbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMua2V5SWQsICdvcHRpb25zLmtleUlkJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsQXJyYXlPZlN0cmluZyhvcHRpb25zLmhlYWRlcnMsICdvcHRpb25zLmhlYWRlcnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5odHRwVmVyc2lvbiwgJ29wdGlvbnMuaHR0cFZlcnNpb24nKTtcblxuICAgIGlmICghcmVxdWVzdC5nZXRIZWFkZXIoJ0RhdGUnKSlcbiAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdEYXRlJywganNwcmltLnJmYzExMjMobmV3IERhdGUoKSkpO1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gWydkYXRlJ107XG4gICAgaWYgKCFvcHRpb25zLmh0dHBWZXJzaW9uKVxuICAgICAgb3B0aW9ucy5odHRwVmVyc2lvbiA9ICcxLjEnO1xuXG4gICAgdmFyIGFsZyA9IFtdO1xuICAgIGlmIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xuICAgICAgYWxnID0gdmFsaWRhdGVBbGdvcml0aG0ob3B0aW9ucy5hbGdvcml0aG0pO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBzdHJpbmdUb1NpZ24gPSAnJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5oZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIChvcHRpb25zLmhlYWRlcnNbaV0pICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5oZWFkZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgU3RyaW5ncycpO1xuXG4gICAgICB2YXIgaCA9IG9wdGlvbnMuaGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoaCA9PT0gJ3JlcXVlc3QtbGluZScpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdlIGFsbG93IGhlYWRlcnMgZnJvbSB0aGUgb2xkZXIgc3BlYyBkcmFmdHMgaWYgc3RyaWN0IHBhcnNpbmcgaXNuJ3RcbiAgICAgICAgICAgKiBzcGVjaWZpZWQgaW4gb3B0aW9ucy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBzdHJpbmdUb1NpZ24gKz1cbiAgICAgICAgICAgIHJlcXVlc3QubWV0aG9kICsgJyAnICsgcmVxdWVzdC5wYXRoICsgJyBIVFRQLycgK1xuICAgICAgICAgICAgb3B0aW9ucy5odHRwVmVyc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBTdHJpY3QgcGFyc2luZyBkb2Vzbid0IGFsbG93IG9sZGVyIGRyYWZ0IGhlYWRlcnMuICovXG4gICAgICAgICAgdGhyb3cgKG5ldyBTdHJpY3RQYXJzaW5nRXJyb3IoJ3JlcXVlc3QtbGluZSBpcyBub3QgYSB2YWxpZCBoZWFkZXIgJyArXG4gICAgICAgICAgICAnd2l0aCBzdHJpY3QgcGFyc2luZyBlbmFibGVkLicpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoID09PSAnKHJlcXVlc3QtdGFyZ2V0KScpIHtcbiAgICAgICAgc3RyaW5nVG9TaWduICs9XG4gICAgICAgICAgJyhyZXF1ZXN0LXRhcmdldCk6ICcgKyByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpICsgJyAnICtcbiAgICAgICAgICByZXF1ZXN0LnBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSByZXF1ZXN0LmdldEhlYWRlcihoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcihoICsgJyB3YXMgbm90IGluIHRoZSByZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nVG9TaWduICs9IGggKyAnOiAnICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaSArIDEpIDwgb3B0aW9ucy5oZWFkZXJzLmxlbmd0aClcbiAgICAgICAgc3RyaW5nVG9TaWduICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8qIFRoaXMgaXMganVzdCBmb3IgdW5pdCB0ZXN0cy4gKi9cbiAgICBpZiAocmVxdWVzdC5oYXNPd25Qcm9wZXJ0eSgnX3N0cmluZ1RvU2lnbicpKSB7XG4gICAgICByZXF1ZXN0Ll9zdHJpbmdUb1NpZ24gPSBzdHJpbmdUb1NpZ247XG4gICAgfVxuXG4gICAgdmFyIHNpZ25hdHVyZTtcbiAgICBpZiAoYWxnWzBdID09PSAnaG1hYycpIHtcbiAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMua2V5KSAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmtleSkpXG4gICAgICAgIHRocm93IChuZXcgVHlwZUVycm9yKCdvcHRpb25zLmtleSBtdXN0IGJlIGEgc3RyaW5nIG9yIEJ1ZmZlcicpKTtcblxuICAgICAgdmFyIGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhhbGdbMV0udG9VcHBlckNhc2UoKSwgb3B0aW9ucy5rZXkpO1xuICAgICAgaG1hYy51cGRhdGUoc3RyaW5nVG9TaWduKTtcbiAgICAgIHNpZ25hdHVyZSA9IGhtYWMuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgICBpZiAodHlwZW9mIChrZXkpID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIoa2V5KSlcbiAgICAgICAga2V5ID0gc3NocGsucGFyc2VQcml2YXRlS2V5KG9wdGlvbnMua2V5KTtcblxuICAgICAgYXNzZXJ0Lm9rKHNzaHBrLlByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSwgWzEsIDJdKSxcbiAgICAgICAgJ29wdGlvbnMua2V5IG11c3QgYmUgYSBzc2hway5Qcml2YXRlS2V5Jyk7XG5cbiAgICAgIGlmICghUEtfQUxHT1Nba2V5LnR5cGVdKSB7XG4gICAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGtleS50eXBlLnRvVXBwZXJDYXNlKCkgKyAnIHR5cGUgJyArXG4gICAgICAgICAgJ2tleXMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGdbMF0gIT09IHVuZGVmaW5lZCAmJiBrZXkudHlwZSAhPT0gYWxnWzBdKSB7XG4gICAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKCdvcHRpb25zLmtleSBtdXN0IGJlIGEgJyArXG4gICAgICAgICAgYWxnWzBdLnRvVXBwZXJDYXNlKCkgKyAnIGtleSwgd2FzIGdpdmVuIGEgJyArXG4gICAgICAgICAga2V5LnR5cGUudG9VcHBlckNhc2UoKSArICcga2V5IGluc3RlYWQnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaWduZXIgPSBrZXkuY3JlYXRlU2lnbihhbGdbMV0pO1xuICAgICAgc2lnbmVyLnVwZGF0ZShzdHJpbmdUb1NpZ24pO1xuICAgICAgdmFyIHNpZ09iaiA9IHNpZ25lci5zaWduKCk7XG4gICAgICBpZiAoIUhBU0hfQUxHT1Nbc2lnT2JqLmhhc2hBbGdvcml0aG1dKSB7XG4gICAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKHNpZ09iai5oYXNoQWxnb3JpdGhtLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICcgaXMgbm90IGEgc3VwcG9ydGVkIGhhc2ggYWxnb3JpdGhtJykpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5hbGdvcml0aG0gPSBrZXkudHlwZSArICctJyArIHNpZ09iai5oYXNoQWxnb3JpdGhtO1xuICAgICAgc2lnbmF0dXJlID0gc2lnT2JqLnRvU3RyaW5nKCk7XG4gICAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwoc2lnbmF0dXJlLCAnJywgJ2VtcHR5IHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIH1cblxuICAgIHZhciBhdXRoekhlYWRlck5hbWUgPSBvcHRpb25zLmF1dGhvcml6YXRpb25IZWFkZXJOYW1lIHx8ICdBdXRob3JpemF0aW9uJztcblxuICAgIHJlcXVlc3Quc2V0SGVhZGVyKGF1dGh6SGVhZGVyTmFtZSwgc3ByaW50ZihBVVRIWl9GTVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMua2V5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuam9pbignICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUpKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImNyeXB0byIsImh0dHAiLCJ1dGlsIiwic3NocGsiLCJqc3ByaW0iLCJ1dGlscyIsInNwcmludGYiLCJmb3JtYXQiLCJIQVNIX0FMR09TIiwiUEtfQUxHT1MiLCJJbnZhbGlkQWxnb3JpdGhtRXJyb3IiLCJIdHRwU2lnbmF0dXJlRXJyb3IiLCJ2YWxpZGF0ZUFsZ29yaXRobSIsIkFVVEhaX0ZNVCIsIk1pc3NpbmdIZWFkZXJFcnJvciIsIm1lc3NhZ2UiLCJjYWxsIiwiaW5oZXJpdHMiLCJTdHJpY3RQYXJzaW5nRXJyb3IiLCJSZXF1ZXN0U2lnbmVyIiwib3B0aW9ucyIsIm9iamVjdCIsImFsZyIsImFsZ29yaXRobSIsInVuZGVmaW5lZCIsInN0cmluZyIsInJzX2FsZyIsInNpZ24iLCJmdW5jIiwicnNfc2lnbkZ1bmMiLCJrZXkiLCJrZXlJZCIsInJzX2tleUlkIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJUeXBlRXJyb3IiLCJyc19zaWduZXIiLCJjcmVhdGVIbWFjIiwidG9VcHBlckNhc2UiLCJkaWdlc3QiLCJoYXNoQWxnb3JpdGhtIiwidG9TdHJpbmciLCJwYXJzZVByaXZhdGVLZXkiLCJvayIsIlByaXZhdGVLZXkiLCJpc1ByaXZhdGVLZXkiLCJyc19rZXkiLCJ0eXBlIiwiY3JlYXRlU2lnbiIsInJzX2hlYWRlcnMiLCJyc19saW5lcyIsInByb3RvdHlwZSIsIndyaXRlSGVhZGVyIiwiaGVhZGVyIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJsaW5lIiwibGVuZ3RoIiwidXBkYXRlIiwid3JpdGVEYXRlSGVhZGVyIiwicmZjMTEyMyIsIkRhdGUiLCJ3cml0ZVRhcmdldCIsIm1ldGhvZCIsInBhdGgiLCJjYiIsIkVycm9yIiwiYXV0aHoiLCJkYXRhIiwiam9pbiIsInNlbGYiLCJlcnIiLCJzaWciLCJzaWduYXR1cmUiLCJlIiwic2lnT2JqIiwibW9kdWxlIiwiZXhwb3J0cyIsImlzU2lnbmVyIiwib2JqIiwiY3JlYXRlU2lnbmVyIiwic2lnblJlcXVlc3QiLCJyZXF1ZXN0Iiwib3B0aW9uYWxTdHJpbmciLCJvcHRpb25hbEFycmF5T2ZTdHJpbmciLCJoZWFkZXJzIiwiaHR0cFZlcnNpb24iLCJnZXRIZWFkZXIiLCJzZXRIZWFkZXIiLCJpIiwic3RyaW5nVG9TaWduIiwiaCIsInN0cmljdCIsImhhc093blByb3BlcnR5IiwiX3N0cmluZ1RvU2lnbiIsImhtYWMiLCJzaWduZXIiLCJub3RTdHJpY3RFcXVhbCIsImF1dGh6SGVhZGVyTmFtZSIsImF1dGhvcml6YXRpb25IZWFkZXJOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/http-signature/lib/signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/http-signature/lib/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/http-signature/lib/utils.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(ssr)/./node_modules/assert-plus/assert.js\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(ssr)/./node_modules/sshpk/lib/index.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar HASH_ALGOS = {\n    \"sha1\": true,\n    \"sha256\": true,\n    \"sha512\": true\n};\nvar PK_ALGOS = {\n    \"rsa\": true,\n    \"dsa\": true,\n    \"ecdsa\": true\n};\nfunction HttpSignatureError(message, caller) {\n    if (Error.captureStackTrace) Error.captureStackTrace(this, caller || HttpSignatureError);\n    this.message = message;\n    this.name = caller.name;\n}\nutil.inherits(HttpSignatureError, Error);\nfunction InvalidAlgorithmError(message) {\n    HttpSignatureError.call(this, message, InvalidAlgorithmError);\n}\nutil.inherits(InvalidAlgorithmError, HttpSignatureError);\nfunction validateAlgorithm(algorithm) {\n    var alg = algorithm.toLowerCase().split(\"-\");\n    if (alg.length !== 2) {\n        throw new InvalidAlgorithmError(alg[0].toUpperCase() + \" is not a \" + \"valid algorithm\");\n    }\n    if (alg[0] !== \"hmac\" && !PK_ALGOS[alg[0]]) {\n        throw new InvalidAlgorithmError(alg[0].toUpperCase() + \" type keys \" + \"are not supported\");\n    }\n    if (!HASH_ALGOS[alg[1]]) {\n        throw new InvalidAlgorithmError(alg[1].toUpperCase() + \" is not a \" + \"supported hash algorithm\");\n    }\n    return alg;\n}\n///--- API\nmodule.exports = {\n    HASH_ALGOS: HASH_ALGOS,\n    PK_ALGOS: PK_ALGOS,\n    HttpSignatureError: HttpSignatureError,\n    InvalidAlgorithmError: InvalidAlgorithmError,\n    validateAlgorithm: validateAlgorithm,\n    /**\n   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.\n   *\n   * The intent of this module is to interoperate with OpenSSL only,\n   * specifically the node crypto module's `verify` method.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} PEM encoded form of the RSA public key.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} on invalid ssh key formatted data.\n   */ sshKeyToPEM: function sshKeyToPEM(key) {\n        assert.string(key, \"ssh_key\");\n        var k = sshpk.parseKey(key, \"ssh\");\n        return k.toString(\"pem\");\n    },\n    /**\n   * Generates an OpenSSH fingerprint from an ssh public key.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} key fingerprint.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} if what you passed doesn't look like an ssh public key.\n   */ fingerprint: function fingerprint(key) {\n        assert.string(key, \"ssh_key\");\n        var k = sshpk.parseKey(key, \"ssh\");\n        return k.fingerprint(\"md5\").toString(\"hex\");\n    },\n    /**\n   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)\n   *\n   * The reverse of the above function.\n   */ pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {\n        assert.equal(\"string\", typeof pem, \"typeof pem\");\n        var k = sshpk.parseKey(pem, \"pem\");\n        k.comment = comment;\n        return k.toString(\"ssh\");\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9EQUFvRDs7QUFFcEQsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUM7QUFFbkIsSUFBSUcsYUFBYTtJQUNmLFFBQVE7SUFDUixVQUFVO0lBQ1YsVUFBVTtBQUNaO0FBRUEsSUFBSUMsV0FBVztJQUNiLE9BQU87SUFDUCxPQUFPO0lBQ1AsU0FBUztBQUNYO0FBRUEsU0FBU0MsbUJBQW1CQyxPQUFPLEVBQUVDLE1BQU07SUFDekMsSUFBSUMsTUFBTUMsaUJBQWlCLEVBQ3pCRCxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVGLFVBQVVGO0lBRTFDLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNmLElBQUksQ0FBQ0ksSUFBSSxHQUFHSCxPQUFPRyxJQUFJO0FBQ3pCO0FBQ0FSLEtBQUtTLFFBQVEsQ0FBQ04sb0JBQW9CRztBQUVsQyxTQUFTSSxzQkFBc0JOLE9BQU87SUFDcENELG1CQUFtQlEsSUFBSSxDQUFDLElBQUksRUFBRVAsU0FBU007QUFDekM7QUFDQVYsS0FBS1MsUUFBUSxDQUFDQyx1QkFBdUJQO0FBRXJDLFNBQVNTLGtCQUFrQkMsU0FBUztJQUNsQyxJQUFJQyxNQUFNRCxVQUFVRSxXQUFXLEdBQUdDLEtBQUssQ0FBQztJQUV4QyxJQUFJRixJQUFJRyxNQUFNLEtBQUssR0FBRztRQUNwQixNQUFPLElBQUlQLHNCQUFzQkksR0FBRyxDQUFDLEVBQUUsQ0FBQ0ksV0FBVyxLQUFLLGVBQ3REO0lBQ0o7SUFFQSxJQUFJSixHQUFHLENBQUMsRUFBRSxLQUFLLFVBQVUsQ0FBQ1osUUFBUSxDQUFDWSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDMUMsTUFBTyxJQUFJSixzQkFBc0JJLEdBQUcsQ0FBQyxFQUFFLENBQUNJLFdBQVcsS0FBSyxnQkFDdEQ7SUFDSjtJQUVBLElBQUksQ0FBQ2pCLFVBQVUsQ0FBQ2EsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ3ZCLE1BQU8sSUFBSUosc0JBQXNCSSxHQUFHLENBQUMsRUFBRSxDQUFDSSxXQUFXLEtBQUssZUFDdEQ7SUFDSjtJQUVBLE9BQVFKO0FBQ1Y7QUFFQSxVQUFVO0FBRVZLLE9BQU9DLE9BQU8sR0FBRztJQUVmbkIsWUFBWUE7SUFDWkMsVUFBVUE7SUFFVkMsb0JBQW9CQTtJQUNwQk8sdUJBQXVCQTtJQUV2QkUsbUJBQW1CQTtJQUVuQjs7Ozs7Ozs7OztHQVVDLEdBQ0RTLGFBQWEsU0FBU0EsWUFBWUMsR0FBRztRQUNuQ3pCLE9BQU8wQixNQUFNLENBQUNELEtBQUs7UUFFbkIsSUFBSUUsSUFBSXpCLE1BQU0wQixRQUFRLENBQUNILEtBQUs7UUFDNUIsT0FBUUUsRUFBRUUsUUFBUSxDQUFDO0lBQ3JCO0lBR0E7Ozs7Ozs7R0FPQyxHQUNEQyxhQUFhLFNBQVNBLFlBQVlMLEdBQUc7UUFDbkN6QixPQUFPMEIsTUFBTSxDQUFDRCxLQUFLO1FBRW5CLElBQUlFLElBQUl6QixNQUFNMEIsUUFBUSxDQUFDSCxLQUFLO1FBQzVCLE9BQVFFLEVBQUVHLFdBQVcsQ0FBQyxPQUFPRCxRQUFRLENBQUM7SUFDeEM7SUFFQTs7OztHQUlDLEdBQ0RFLGdCQUFnQixTQUFTQSxlQUFlQyxHQUFHLEVBQUVDLE9BQU87UUFDbERqQyxPQUFPa0MsS0FBSyxDQUFDLFVBQVUsT0FBUUYsS0FBTTtRQUVyQyxJQUFJTCxJQUFJekIsTUFBTTBCLFFBQVEsQ0FBQ0ksS0FBSztRQUM1QkwsRUFBRU0sT0FBTyxHQUFHQTtRQUNaLE9BQVFOLEVBQUVFLFFBQVEsQ0FBQztJQUNyQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2ljZS1hcHAvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3V0aWxzLmpzP2I2YjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTIgSm95ZW50LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBzc2hwayA9IHJlcXVpcmUoJ3NzaHBrJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIEhBU0hfQUxHT1MgPSB7XG4gICdzaGExJzogdHJ1ZSxcbiAgJ3NoYTI1Nic6IHRydWUsXG4gICdzaGE1MTInOiB0cnVlXG59O1xuXG52YXIgUEtfQUxHT1MgPSB7XG4gICdyc2EnOiB0cnVlLFxuICAnZHNhJzogdHJ1ZSxcbiAgJ2VjZHNhJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gSHR0cFNpZ25hdHVyZUVycm9yKG1lc3NhZ2UsIGNhbGxlcikge1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY2FsbGVyIHx8IEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gY2FsbGVyLm5hbWU7XG59XG51dGlsLmluaGVyaXRzKEh0dHBTaWduYXR1cmVFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBJbnZhbGlkQWxnb3JpdGhtRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhJbnZhbGlkQWxnb3JpdGhtRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQWxnb3JpdGhtKGFsZ29yaXRobSkge1xuICB2YXIgYWxnID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcblxuICBpZiAoYWxnLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZ1swXS50b1VwcGVyQ2FzZSgpICsgJyBpcyBub3QgYSAnICtcbiAgICAgICd2YWxpZCBhbGdvcml0aG0nKSk7XG4gIH1cblxuICBpZiAoYWxnWzBdICE9PSAnaG1hYycgJiYgIVBLX0FMR09TW2FsZ1swXV0pIHtcbiAgICB0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGdbMF0udG9VcHBlckNhc2UoKSArICcgdHlwZSBrZXlzICcgK1xuICAgICAgJ2FyZSBub3Qgc3VwcG9ydGVkJykpO1xuICB9XG5cbiAgaWYgKCFIQVNIX0FMR09TW2FsZ1sxXV0pIHtcbiAgICB0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGdbMV0udG9VcHBlckNhc2UoKSArICcgaXMgbm90IGEgJyArXG4gICAgICAnc3VwcG9ydGVkIGhhc2ggYWxnb3JpdGhtJykpO1xuICB9XG5cbiAgcmV0dXJuIChhbGcpO1xufVxuXG4vLy8tLS0gQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIEhBU0hfQUxHT1M6IEhBU0hfQUxHT1MsXG4gIFBLX0FMR09TOiBQS19BTEdPUyxcblxuICBIdHRwU2lnbmF0dXJlRXJyb3I6IEh0dHBTaWduYXR1cmVFcnJvcixcbiAgSW52YWxpZEFsZ29yaXRobUVycm9yOiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IsXG5cbiAgdmFsaWRhdGVBbGdvcml0aG06IHZhbGlkYXRlQWxnb3JpdGhtLFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NIIHB1YmxpYyBrZXkgKHJzYSBvbmx5KSB0byBhIFBLQ1MjOCBQRU0gZmlsZS5cbiAgICpcbiAgICogVGhlIGludGVudCBvZiB0aGlzIG1vZHVsZSBpcyB0byBpbnRlcm9wZXJhdGUgd2l0aCBPcGVuU1NMIG9ubHksXG4gICAqIHNwZWNpZmljYWxseSB0aGUgbm9kZSBjcnlwdG8gbW9kdWxlJ3MgYHZlcmlmeWAgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGFuIE9wZW5TU0ggcHVibGljIGtleS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBQRU0gZW5jb2RlZCBmb3JtIG9mIHRoZSBSU0EgcHVibGljIGtleS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBvbiBpbnZhbGlkIHNzaCBrZXkgZm9ybWF0dGVkIGRhdGEuXG4gICAqL1xuICBzc2hLZXlUb1BFTTogZnVuY3Rpb24gc3NoS2V5VG9QRU0oa2V5KSB7XG4gICAgYXNzZXJ0LnN0cmluZyhrZXksICdzc2hfa2V5Jyk7XG5cbiAgICB2YXIgayA9IHNzaHBrLnBhcnNlS2V5KGtleSwgJ3NzaCcpO1xuICAgIHJldHVybiAoay50b1N0cmluZygncGVtJykpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBPcGVuU1NIIGZpbmdlcnByaW50IGZyb20gYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGtleSBmaW5nZXJwcmludC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB3aGF0IHlvdSBwYXNzZWQgZG9lc24ndCBsb29rIGxpa2UgYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqL1xuICBmaW5nZXJwcmludDogZnVuY3Rpb24gZmluZ2VycHJpbnQoa2V5KSB7XG4gICAgYXNzZXJ0LnN0cmluZyhrZXksICdzc2hfa2V5Jyk7XG5cbiAgICB2YXIgayA9IHNzaHBrLnBhcnNlS2V5KGtleSwgJ3NzaCcpO1xuICAgIHJldHVybiAoay5maW5nZXJwcmludCgnbWQ1JykudG9TdHJpbmcoJ2hleCcpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBQS0dDUyM4IFBFTSBmaWxlIHRvIGFuIE9wZW5TU0ggcHVibGljIGtleSAocnNhKVxuICAgKlxuICAgKiBUaGUgcmV2ZXJzZSBvZiB0aGUgYWJvdmUgZnVuY3Rpb24uXG4gICAqL1xuICBwZW1Ub1JzYVNTSEtleTogZnVuY3Rpb24gcGVtVG9Sc2FTU0hLZXkocGVtLCBjb21tZW50KSB7XG4gICAgYXNzZXJ0LmVxdWFsKCdzdHJpbmcnLCB0eXBlb2YgKHBlbSksICd0eXBlb2YgcGVtJyk7XG5cbiAgICB2YXIgayA9IHNzaHBrLnBhcnNlS2V5KHBlbSwgJ3BlbScpO1xuICAgIGsuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIChrLnRvU3RyaW5nKCdzc2gnKSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsInNzaHBrIiwidXRpbCIsIkhBU0hfQUxHT1MiLCJQS19BTEdPUyIsIkh0dHBTaWduYXR1cmVFcnJvciIsIm1lc3NhZ2UiLCJjYWxsZXIiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwibmFtZSIsImluaGVyaXRzIiwiSW52YWxpZEFsZ29yaXRobUVycm9yIiwiY2FsbCIsInZhbGlkYXRlQWxnb3JpdGhtIiwiYWxnb3JpdGhtIiwiYWxnIiwidG9Mb3dlckNhc2UiLCJzcGxpdCIsImxlbmd0aCIsInRvVXBwZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyIsInNzaEtleVRvUEVNIiwia2V5Iiwic3RyaW5nIiwiayIsInBhcnNlS2V5IiwidG9TdHJpbmciLCJmaW5nZXJwcmludCIsInBlbVRvUnNhU1NIS2V5IiwicGVtIiwiY29tbWVudCIsImVxdWFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/http-signature/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/http-signature/lib/verify.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/verify.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(ssr)/./node_modules/assert-plus/assert.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(ssr)/./node_modules/sshpk/lib/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/http-signature/lib/utils.js\");\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar validateAlgorithm = utils.validateAlgorithm;\n///--- Exported API\nmodule.exports = {\n    /**\n   * Verify RSA/DSA signature against public key.  You are expected to pass in\n   * an object that was returned from `parse()`.\n   *\n   * @param {Object} parsedSignature the object you got from `parse`.\n   * @param {String} pubkey RSA/DSA private key PEM.\n   * @return {Boolean} true if valid, false otherwise.\n   * @throws {TypeError} if you pass in bad arguments.\n   * @throws {InvalidAlgorithmError}\n   */ verifySignature: function verifySignature(parsedSignature, pubkey) {\n        assert.object(parsedSignature, \"parsedSignature\");\n        if (typeof pubkey === \"string\" || Buffer.isBuffer(pubkey)) pubkey = sshpk.parseKey(pubkey);\n        assert.ok(sshpk.Key.isKey(pubkey, [\n            1,\n            1\n        ]), \"pubkey must be a sshpk.Key\");\n        var alg = validateAlgorithm(parsedSignature.algorithm);\n        if (alg[0] === \"hmac\" || alg[0] !== pubkey.type) return false;\n        var v = pubkey.createVerify(alg[1]);\n        v.update(parsedSignature.signingString);\n        return v.verify(parsedSignature.params.signature, \"base64\");\n    },\n    /**\n   * Verify HMAC against shared secret.  You are expected to pass in an object\n   * that was returned from `parse()`.\n   *\n   * @param {Object} parsedSignature the object you got from `parse`.\n   * @param {String} secret HMAC shared secret.\n   * @return {Boolean} true if valid, false otherwise.\n   * @throws {TypeError} if you pass in bad arguments.\n   * @throws {InvalidAlgorithmError}\n   */ verifyHMAC: function verifyHMAC(parsedSignature, secret) {\n        assert.object(parsedSignature, \"parsedHMAC\");\n        assert.string(secret, \"secret\");\n        var alg = validateAlgorithm(parsedSignature.algorithm);\n        if (alg[0] !== \"hmac\") return false;\n        var hashAlg = alg[1].toUpperCase();\n        var hmac = crypto.createHmac(hashAlg, secret);\n        hmac.update(parsedSignature.signingString);\n        /*\n     * Now double-hash to avoid leaking timing information - there's\n     * no easy constant-time compare in JS, so we use this approach\n     * instead. See for more info:\n     * https://www.isecpartners.com/blog/2011/february/double-hmac-\n     * verification.aspx\n     */ var h1 = crypto.createHmac(hashAlg, secret);\n        h1.update(hmac.digest());\n        h1 = h1.digest();\n        var h2 = crypto.createHmac(hashAlg, secret);\n        h2.update(new Buffer(parsedSignature.params.signature, \"base64\"));\n        h2 = h2.digest();\n        /* Node 0.8 returns strings from .digest(). */ if (typeof h1 === \"string\") return h1 === h2;\n        /* And node 0.10 lacks the .equals() method on Buffers. */ if (Buffer.isBuffer(h1) && !h1.equals) return h1.toString(\"binary\") === h2.toString(\"binary\");\n        return h1.equals(h2);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3ZlcmlmeS5qcyIsIm1hcHBpbmdzIjoiQUFBQSw4QkFBOEI7O0FBRTlCLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDO0FBRXBCLElBQUlJLGFBQWFELE1BQU1DLFVBQVU7QUFDakMsSUFBSUMsV0FBV0YsTUFBTUUsUUFBUTtBQUM3QixJQUFJQyx3QkFBd0JILE1BQU1HLHFCQUFxQjtBQUN2RCxJQUFJQyxxQkFBcUJKLE1BQU1JLGtCQUFrQjtBQUNqRCxJQUFJQyxvQkFBb0JMLE1BQU1LLGlCQUFpQjtBQUUvQyxtQkFBbUI7QUFFbkJDLE9BQU9DLE9BQU8sR0FBRztJQUNmOzs7Ozs7Ozs7R0FTQyxHQUNEQyxpQkFBaUIsU0FBU0EsZ0JBQWdCQyxlQUFlLEVBQUVDLE1BQU07UUFDL0RkLE9BQU9lLE1BQU0sQ0FBQ0YsaUJBQWlCO1FBQy9CLElBQUksT0FBUUMsV0FBWSxZQUFZRSxPQUFPQyxRQUFRLENBQUNILFNBQ2xEQSxTQUFTWCxNQUFNZSxRQUFRLENBQUNKO1FBQzFCZCxPQUFPbUIsRUFBRSxDQUFDaEIsTUFBTWlCLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDUCxRQUFRO1lBQUM7WUFBRztTQUFFLEdBQUc7UUFFM0MsSUFBSVEsTUFBTWIsa0JBQWtCSSxnQkFBZ0JVLFNBQVM7UUFDckQsSUFBSUQsR0FBRyxDQUFDLEVBQUUsS0FBSyxVQUFVQSxHQUFHLENBQUMsRUFBRSxLQUFLUixPQUFPVSxJQUFJLEVBQzdDLE9BQVE7UUFFVixJQUFJQyxJQUFJWCxPQUFPWSxZQUFZLENBQUNKLEdBQUcsQ0FBQyxFQUFFO1FBQ2xDRyxFQUFFRSxNQUFNLENBQUNkLGdCQUFnQmUsYUFBYTtRQUN0QyxPQUFRSCxFQUFFSSxNQUFNLENBQUNoQixnQkFBZ0JpQixNQUFNLENBQUNDLFNBQVMsRUFBRTtJQUNyRDtJQUVBOzs7Ozs7Ozs7R0FTQyxHQUNEQyxZQUFZLFNBQVNBLFdBQVduQixlQUFlLEVBQUVvQixNQUFNO1FBQ3JEakMsT0FBT2UsTUFBTSxDQUFDRixpQkFBaUI7UUFDL0JiLE9BQU9rQyxNQUFNLENBQUNELFFBQVE7UUFFdEIsSUFBSVgsTUFBTWIsa0JBQWtCSSxnQkFBZ0JVLFNBQVM7UUFDckQsSUFBSUQsR0FBRyxDQUFDLEVBQUUsS0FBSyxRQUNiLE9BQVE7UUFFVixJQUFJYSxVQUFVYixHQUFHLENBQUMsRUFBRSxDQUFDYyxXQUFXO1FBRWhDLElBQUlDLE9BQU9uQyxPQUFPb0MsVUFBVSxDQUFDSCxTQUFTRjtRQUN0Q0ksS0FBS1YsTUFBTSxDQUFDZCxnQkFBZ0JlLGFBQWE7UUFFekM7Ozs7OztLQU1DLEdBQ0QsSUFBSVcsS0FBS3JDLE9BQU9vQyxVQUFVLENBQUNILFNBQVNGO1FBQ3BDTSxHQUFHWixNQUFNLENBQUNVLEtBQUtHLE1BQU07UUFDckJELEtBQUtBLEdBQUdDLE1BQU07UUFDZCxJQUFJQyxLQUFLdkMsT0FBT29DLFVBQVUsQ0FBQ0gsU0FBU0Y7UUFDcENRLEdBQUdkLE1BQU0sQ0FBQyxJQUFJWCxPQUFPSCxnQkFBZ0JpQixNQUFNLENBQUNDLFNBQVMsRUFBRTtRQUN2RFUsS0FBS0EsR0FBR0QsTUFBTTtRQUVkLDRDQUE0QyxHQUM1QyxJQUFJLE9BQVFELE9BQVEsVUFDbEIsT0FBUUEsT0FBT0U7UUFDakIsd0RBQXdELEdBQ3hELElBQUl6QixPQUFPQyxRQUFRLENBQUNzQixPQUFPLENBQUNBLEdBQUdHLE1BQU0sRUFDbkMsT0FBUUgsR0FBR0ksUUFBUSxDQUFDLGNBQWNGLEdBQUdFLFFBQVEsQ0FBQztRQUVoRCxPQUFRSixHQUFHRyxNQUFNLENBQUNEO0lBQ3BCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnZvaWNlLWFwcC8uL25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvdmVyaWZ5LmpzP2M3ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHNzaHBrID0gcmVxdWlyZSgnc3NocGsnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIEhBU0hfQUxHT1MgPSB1dGlscy5IQVNIX0FMR09TO1xudmFyIFBLX0FMR09TID0gdXRpbHMuUEtfQUxHT1M7XG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gdXRpbHMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xudmFyIEh0dHBTaWduYXR1cmVFcnJvciA9IHV0aWxzLkh0dHBTaWduYXR1cmVFcnJvcjtcbnZhciB2YWxpZGF0ZUFsZ29yaXRobSA9IHV0aWxzLnZhbGlkYXRlQWxnb3JpdGhtO1xuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVmVyaWZ5IFJTQS9EU0Egc2lnbmF0dXJlIGFnYWluc3QgcHVibGljIGtleS4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcGFzcyBpblxuICAgKiBhbiBvYmplY3QgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSBgcGFyc2UoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWRTaWduYXR1cmUgdGhlIG9iamVjdCB5b3UgZ290IGZyb20gYHBhcnNlYC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YmtleSBSU0EvRFNBIHByaXZhdGUga2V5IFBFTS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn1cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZTogZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHBhcnNlZFNpZ25hdHVyZSwgcHVia2V5KSB7XG4gICAgYXNzZXJ0Lm9iamVjdChwYXJzZWRTaWduYXR1cmUsICdwYXJzZWRTaWduYXR1cmUnKTtcbiAgICBpZiAodHlwZW9mIChwdWJrZXkpID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIocHVia2V5KSlcbiAgICAgIHB1YmtleSA9IHNzaHBrLnBhcnNlS2V5KHB1YmtleSk7XG4gICAgYXNzZXJ0Lm9rKHNzaHBrLktleS5pc0tleShwdWJrZXksIFsxLCAxXSksICdwdWJrZXkgbXVzdCBiZSBhIHNzaHBrLktleScpO1xuXG4gICAgdmFyIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0pO1xuICAgIGlmIChhbGdbMF0gPT09ICdobWFjJyB8fCBhbGdbMF0gIT09IHB1YmtleS50eXBlKVxuICAgICAgcmV0dXJuIChmYWxzZSk7XG5cbiAgICB2YXIgdiA9IHB1YmtleS5jcmVhdGVWZXJpZnkoYWxnWzFdKTtcbiAgICB2LnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG4gICAgcmV0dXJuICh2LnZlcmlmeShwYXJzZWRTaWduYXR1cmUucGFyYW1zLnNpZ25hdHVyZSwgJ2Jhc2U2NCcpKTtcbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IEhNQUMgYWdhaW5zdCBzaGFyZWQgc2VjcmV0LiAgWW91IGFyZSBleHBlY3RlZCB0byBwYXNzIGluIGFuIG9iamVjdFxuICAgKiB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIGBwYXJzZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZFNpZ25hdHVyZSB0aGUgb2JqZWN0IHlvdSBnb3QgZnJvbSBgcGFyc2VgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VjcmV0IEhNQUMgc2hhcmVkIHNlY3JldC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn1cbiAgICovXG4gIHZlcmlmeUhNQUM6IGZ1bmN0aW9uIHZlcmlmeUhNQUMocGFyc2VkU2lnbmF0dXJlLCBzZWNyZXQpIHtcbiAgICBhc3NlcnQub2JqZWN0KHBhcnNlZFNpZ25hdHVyZSwgJ3BhcnNlZEhNQUMnKTtcbiAgICBhc3NlcnQuc3RyaW5nKHNlY3JldCwgJ3NlY3JldCcpO1xuXG4gICAgdmFyIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0pO1xuICAgIGlmIChhbGdbMF0gIT09ICdobWFjJylcbiAgICAgIHJldHVybiAoZmFsc2UpO1xuXG4gICAgdmFyIGhhc2hBbGcgPSBhbGdbMV0udG9VcHBlckNhc2UoKTtcblxuICAgIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgc2VjcmV0KTtcbiAgICBobWFjLnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG5cbiAgICAvKlxuICAgICAqIE5vdyBkb3VibGUtaGFzaCB0byBhdm9pZCBsZWFraW5nIHRpbWluZyBpbmZvcm1hdGlvbiAtIHRoZXJlJ3NcbiAgICAgKiBubyBlYXN5IGNvbnN0YW50LXRpbWUgY29tcGFyZSBpbiBKUywgc28gd2UgdXNlIHRoaXMgYXBwcm9hY2hcbiAgICAgKiBpbnN0ZWFkLiBTZWUgZm9yIG1vcmUgaW5mbzpcbiAgICAgKiBodHRwczovL3d3dy5pc2VjcGFydG5lcnMuY29tL2Jsb2cvMjAxMS9mZWJydWFyeS9kb3VibGUtaG1hYy1cbiAgICAgKiB2ZXJpZmljYXRpb24uYXNweFxuICAgICAqL1xuICAgIHZhciBoMSA9IGNyeXB0by5jcmVhdGVIbWFjKGhhc2hBbGcsIHNlY3JldCk7XG4gICAgaDEudXBkYXRlKGhtYWMuZGlnZXN0KCkpO1xuICAgIGgxID0gaDEuZGlnZXN0KCk7XG4gICAgdmFyIGgyID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgc2VjcmV0KTtcbiAgICBoMi51cGRhdGUobmV3IEJ1ZmZlcihwYXJzZWRTaWduYXR1cmUucGFyYW1zLnNpZ25hdHVyZSwgJ2Jhc2U2NCcpKTtcbiAgICBoMiA9IGgyLmRpZ2VzdCgpO1xuXG4gICAgLyogTm9kZSAwLjggcmV0dXJucyBzdHJpbmdzIGZyb20gLmRpZ2VzdCgpLiAqL1xuICAgIGlmICh0eXBlb2YgKGgxKSA9PT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gKGgxID09PSBoMik7XG4gICAgLyogQW5kIG5vZGUgMC4xMCBsYWNrcyB0aGUgLmVxdWFscygpIG1ldGhvZCBvbiBCdWZmZXJzLiAqL1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaDEpICYmICFoMS5lcXVhbHMpXG4gICAgICByZXR1cm4gKGgxLnRvU3RyaW5nKCdiaW5hcnknKSA9PT0gaDIudG9TdHJpbmcoJ2JpbmFyeScpKTtcblxuICAgIHJldHVybiAoaDEuZXF1YWxzKGgyKSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImNyeXB0byIsInNzaHBrIiwidXRpbHMiLCJIQVNIX0FMR09TIiwiUEtfQUxHT1MiLCJJbnZhbGlkQWxnb3JpdGhtRXJyb3IiLCJIdHRwU2lnbmF0dXJlRXJyb3IiLCJ2YWxpZGF0ZUFsZ29yaXRobSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ2ZXJpZnlTaWduYXR1cmUiLCJwYXJzZWRTaWduYXR1cmUiLCJwdWJrZXkiLCJvYmplY3QiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInBhcnNlS2V5Iiwib2siLCJLZXkiLCJpc0tleSIsImFsZyIsImFsZ29yaXRobSIsInR5cGUiLCJ2IiwiY3JlYXRlVmVyaWZ5IiwidXBkYXRlIiwic2lnbmluZ1N0cmluZyIsInZlcmlmeSIsInBhcmFtcyIsInNpZ25hdHVyZSIsInZlcmlmeUhNQUMiLCJzZWNyZXQiLCJzdHJpbmciLCJoYXNoQWxnIiwidG9VcHBlckNhc2UiLCJobWFjIiwiY3JlYXRlSG1hYyIsImgxIiwiZGlnZXN0IiwiaDIiLCJlcXVhbHMiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/http-signature/lib/verify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/http-signature/lib/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar parser = __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/http-signature/lib/parser.js\");\nvar signer = __webpack_require__(/*! ./signer */ \"(rsc)/./node_modules/http-signature/lib/signer.js\");\nvar verify = __webpack_require__(/*! ./verify */ \"(rsc)/./node_modules/http-signature/lib/verify.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/http-signature/lib/utils.js\");\n///--- API\nmodule.exports = {\n    parse: parser.parseRequest,\n    parseRequest: parser.parseRequest,\n    sign: signer.signRequest,\n    signRequest: signer.signRequest,\n    createSigner: signer.createSigner,\n    isSigner: signer.isSigner,\n    sshKeyToPEM: utils.sshKeyToPEM,\n    sshKeyFingerprint: utils.fingerprint,\n    pemToRsaSSHKey: utils.pemToRsaSSHKey,\n    verify: verify.verifySignature,\n    verifySignature: verify.verifySignature,\n    verifyHMAC: verify.verifyHMAC\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDhCQUE4Qjs7QUFFOUIsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUM7QUFDckIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUM7QUFJcEIsVUFBVTtBQUVWSSxPQUFPQyxPQUFPLEdBQUc7SUFFZkMsT0FBT1AsT0FBT1EsWUFBWTtJQUMxQkEsY0FBY1IsT0FBT1EsWUFBWTtJQUVqQ0MsTUFBTVAsT0FBT1EsV0FBVztJQUN4QkEsYUFBYVIsT0FBT1EsV0FBVztJQUMvQkMsY0FBY1QsT0FBT1MsWUFBWTtJQUNqQ0MsVUFBVVYsT0FBT1UsUUFBUTtJQUV6QkMsYUFBYVQsTUFBTVMsV0FBVztJQUM5QkMsbUJBQW1CVixNQUFNVyxXQUFXO0lBQ3BDQyxnQkFBZ0JaLE1BQU1ZLGNBQWM7SUFFcENiLFFBQVFBLE9BQU9jLGVBQWU7SUFDOUJBLGlCQUFpQmQsT0FBT2MsZUFBZTtJQUN2Q0MsWUFBWWYsT0FBT2UsVUFBVTtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi9pbmRleC5qcz82MmJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciBzaWduZXIgPSByZXF1aXJlKCcuL3NpZ25lcicpO1xudmFyIHZlcmlmeSA9IHJlcXVpcmUoJy4vdmVyaWZ5Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuXG4vLy8tLS0gQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHBhcnNlOiBwYXJzZXIucGFyc2VSZXF1ZXN0LFxuICBwYXJzZVJlcXVlc3Q6IHBhcnNlci5wYXJzZVJlcXVlc3QsXG5cbiAgc2lnbjogc2lnbmVyLnNpZ25SZXF1ZXN0LFxuICBzaWduUmVxdWVzdDogc2lnbmVyLnNpZ25SZXF1ZXN0LFxuICBjcmVhdGVTaWduZXI6IHNpZ25lci5jcmVhdGVTaWduZXIsXG4gIGlzU2lnbmVyOiBzaWduZXIuaXNTaWduZXIsXG5cbiAgc3NoS2V5VG9QRU06IHV0aWxzLnNzaEtleVRvUEVNLFxuICBzc2hLZXlGaW5nZXJwcmludDogdXRpbHMuZmluZ2VycHJpbnQsXG4gIHBlbVRvUnNhU1NIS2V5OiB1dGlscy5wZW1Ub1JzYVNTSEtleSxcblxuICB2ZXJpZnk6IHZlcmlmeS52ZXJpZnlTaWduYXR1cmUsXG4gIHZlcmlmeVNpZ25hdHVyZTogdmVyaWZ5LnZlcmlmeVNpZ25hdHVyZSxcbiAgdmVyaWZ5SE1BQzogdmVyaWZ5LnZlcmlmeUhNQUNcbn07XG4iXSwibmFtZXMiOlsicGFyc2VyIiwicmVxdWlyZSIsInNpZ25lciIsInZlcmlmeSIsInV0aWxzIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlIiwicGFyc2VSZXF1ZXN0Iiwic2lnbiIsInNpZ25SZXF1ZXN0IiwiY3JlYXRlU2lnbmVyIiwiaXNTaWduZXIiLCJzc2hLZXlUb1BFTSIsInNzaEtleUZpbmdlcnByaW50IiwiZmluZ2VycHJpbnQiLCJwZW1Ub1JzYVNTSEtleSIsInZlcmlmeVNpZ25hdHVyZSIsInZlcmlmeUhNQUMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/parser.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/http-signature/lib/utils.js\");\n///--- Globals\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar validateAlgorithm = utils.validateAlgorithm;\nvar State = {\n    New: 0,\n    Params: 1\n};\nvar ParamsState = {\n    Name: 0,\n    Quote: 1,\n    Value: 2,\n    Comma: 3\n};\n///--- Specific Errors\nfunction ExpiredRequestError(message) {\n    HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\nfunction InvalidHeaderError(message) {\n    HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\nfunction InvalidParamsError(message) {\n    HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\nfunction MissingHeaderError(message) {\n    HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\nfunction StrictParsingError(message) {\n    HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n///--- Exported API\nmodule.exports = {\n    /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"digest\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   *                   - strict: should enforce latest spec parsing\n   *                             (default: false).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {StrictParsingError} if old attributes are used in strict parsing\n   *                              mode.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */ parseRequest: function parseRequest(request, options) {\n        assert.object(request, \"request\");\n        assert.object(request.headers, \"request.headers\");\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.headers === undefined) {\n            options.headers = [\n                request.headers[\"x-date\"] ? \"x-date\" : \"date\"\n            ];\n        }\n        assert.object(options, \"options\");\n        assert.arrayOfString(options.headers, \"options.headers\");\n        assert.optionalFinite(options.clockSkew, \"options.clockSkew\");\n        var authzHeaderName = options.authorizationHeaderName || \"authorization\";\n        if (!request.headers[authzHeaderName]) {\n            throw new MissingHeaderError(\"no \" + authzHeaderName + \" header \" + \"present in the request\");\n        }\n        options.clockSkew = options.clockSkew || 300;\n        var i = 0;\n        var state = State.New;\n        var substate = ParamsState.Name;\n        var tmpName = \"\";\n        var tmpValue = \"\";\n        var parsed = {\n            scheme: \"\",\n            params: {},\n            signingString: \"\"\n        };\n        var authz = request.headers[authzHeaderName];\n        for(i = 0; i < authz.length; i++){\n            var c = authz.charAt(i);\n            switch(Number(state)){\n                case State.New:\n                    if (c !== \" \") parsed.scheme += c;\n                    else state = State.Params;\n                    break;\n                case State.Params:\n                    switch(Number(substate)){\n                        case ParamsState.Name:\n                            var code = c.charCodeAt(0);\n                            // restricted name of A-Z / a-z\n                            if (code >= 0x41 && code <= 0x5a || // A-Z\n                            code >= 0x61 && code <= 0x7a) {\n                                tmpName += c;\n                            } else if (c === \"=\") {\n                                if (tmpName.length === 0) throw new InvalidHeaderError(\"bad param format\");\n                                substate = ParamsState.Quote;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        case ParamsState.Quote:\n                            if (c === '\"') {\n                                tmpValue = \"\";\n                                substate = ParamsState.Value;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        case ParamsState.Value:\n                            if (c === '\"') {\n                                parsed.params[tmpName] = tmpValue;\n                                substate = ParamsState.Comma;\n                            } else {\n                                tmpValue += c;\n                            }\n                            break;\n                        case ParamsState.Comma:\n                            if (c === \",\") {\n                                tmpName = \"\";\n                                substate = ParamsState.Name;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        default:\n                            throw new Error(\"Invalid substate\");\n                    }\n                    break;\n                default:\n                    throw new Error(\"Invalid substate\");\n            }\n        }\n        if (!parsed.params.headers || parsed.params.headers === \"\") {\n            if (request.headers[\"x-date\"]) {\n                parsed.params.headers = [\n                    \"x-date\"\n                ];\n            } else {\n                parsed.params.headers = [\n                    \"date\"\n                ];\n            }\n        } else {\n            parsed.params.headers = parsed.params.headers.split(\" \");\n        }\n        // Minimally validate the parsed object\n        if (!parsed.scheme || parsed.scheme !== \"Signature\") throw new InvalidHeaderError('scheme was not \"Signature\"');\n        if (!parsed.params.keyId) throw new InvalidHeaderError(\"keyId was not specified\");\n        if (!parsed.params.algorithm) throw new InvalidHeaderError(\"algorithm was not specified\");\n        if (!parsed.params.signature) throw new InvalidHeaderError(\"signature was not specified\");\n        // Check the algorithm against the official list\n        parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n        try {\n            validateAlgorithm(parsed.params.algorithm);\n        } catch (e) {\n            if (e instanceof InvalidAlgorithmError) throw new InvalidParamsError(parsed.params.algorithm + \" is not \" + \"supported\");\n            else throw e;\n        }\n        // Build the signingString\n        for(i = 0; i < parsed.params.headers.length; i++){\n            var h = parsed.params.headers[i].toLowerCase();\n            parsed.params.headers[i] = h;\n            if (h === \"request-line\") {\n                if (!options.strict) {\n                    /*\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */ parsed.signingString += request.method + \" \" + request.url + \" HTTP/\" + request.httpVersion;\n                } else {\n                    /* Strict parsing doesn't allow older draft headers. */ throw new StrictParsingError(\"request-line is not a valid header \" + \"with strict parsing enabled.\");\n                }\n            } else if (h === \"(request-target)\") {\n                parsed.signingString += \"(request-target): \" + request.method.toLowerCase() + \" \" + request.url;\n            } else {\n                var value = request.headers[h];\n                if (value === undefined) throw new MissingHeaderError(h + \" was not in the request\");\n                parsed.signingString += h + \": \" + value;\n            }\n            if (i + 1 < parsed.params.headers.length) parsed.signingString += \"\\n\";\n        }\n        // Check against the constraints\n        var date;\n        if (request.headers.date || request.headers[\"x-date\"]) {\n            if (request.headers[\"x-date\"]) {\n                date = new Date(request.headers[\"x-date\"]);\n            } else {\n                date = new Date(request.headers.date);\n            }\n            var now = new Date();\n            var skew = Math.abs(now.getTime() - date.getTime());\n            if (skew > options.clockSkew * 1000) {\n                throw new ExpiredRequestError(\"clock skew of \" + skew / 1000 + \"s was greater than \" + options.clockSkew + \"s\");\n            }\n        }\n        options.headers.forEach(function(hdr) {\n            // Remember that we already checked any headers in the params\n            // were in the request, so if this passes we're good.\n            if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0) throw new MissingHeaderError(hdr + \" was not a signed header\");\n        });\n        if (options.algorithms) {\n            if (options.algorithms.indexOf(parsed.params.algorithm) === -1) throw new InvalidParamsError(parsed.params.algorithm + \" is not a supported algorithm\");\n        }\n        parsed.algorithm = parsed.params.algorithm.toUpperCase();\n        parsed.keyId = parsed.params.keyId;\n        return parsed;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvREFBb0Q7O0FBRXBELElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBSXBCLGNBQWM7QUFFZCxJQUFJRyxhQUFhRCxNQUFNQyxVQUFVO0FBQ2pDLElBQUlDLFdBQVdGLE1BQU1FLFFBQVE7QUFDN0IsSUFBSUMscUJBQXFCSCxNQUFNRyxrQkFBa0I7QUFDakQsSUFBSUMsd0JBQXdCSixNQUFNSSxxQkFBcUI7QUFDdkQsSUFBSUMsb0JBQW9CTCxNQUFNSyxpQkFBaUI7QUFFL0MsSUFBSUMsUUFBUTtJQUNWQyxLQUFLO0lBQ0xDLFFBQVE7QUFDVjtBQUVBLElBQUlDLGNBQWM7SUFDaEJDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE9BQU87QUFDVDtBQUdBLHNCQUFzQjtBQUd0QixTQUFTQyxvQkFBb0JDLE9BQU87SUFDbENaLG1CQUFtQmEsSUFBSSxDQUFDLElBQUksRUFBRUQsU0FBU0Q7QUFDekM7QUFDQWYsS0FBS2tCLFFBQVEsQ0FBQ0gscUJBQXFCWDtBQUduQyxTQUFTZSxtQkFBbUJILE9BQU87SUFDakNaLG1CQUFtQmEsSUFBSSxDQUFDLElBQUksRUFBRUQsU0FBU0c7QUFDekM7QUFDQW5CLEtBQUtrQixRQUFRLENBQUNDLG9CQUFvQmY7QUFHbEMsU0FBU2dCLG1CQUFtQkosT0FBTztJQUNqQ1osbUJBQW1CYSxJQUFJLENBQUMsSUFBSSxFQUFFRCxTQUFTSTtBQUN6QztBQUNBcEIsS0FBS2tCLFFBQVEsQ0FBQ0Usb0JBQW9CaEI7QUFHbEMsU0FBU2lCLG1CQUFtQkwsT0FBTztJQUNqQ1osbUJBQW1CYSxJQUFJLENBQUMsSUFBSSxFQUFFRCxTQUFTSztBQUN6QztBQUNBckIsS0FBS2tCLFFBQVEsQ0FBQ0csb0JBQW9C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QU0sQ0FBQ1csS0FBSztRQUNsQyxPQUFPYjtJQUNUO0FBRUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnZvaWNlLWFwcC8uL25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvcGFyc2VyLmpzPzUxOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTIgSm95ZW50LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIEhBU0hfQUxHT1MgPSB1dGlscy5IQVNIX0FMR09TO1xudmFyIFBLX0FMR09TID0gdXRpbHMuUEtfQUxHT1M7XG52YXIgSHR0cFNpZ25hdHVyZUVycm9yID0gdXRpbHMuSHR0cFNpZ25hdHVyZUVycm9yO1xudmFyIEludmFsaWRBbGdvcml0aG1FcnJvciA9IHV0aWxzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcbnZhciB2YWxpZGF0ZUFsZ29yaXRobSA9IHV0aWxzLnZhbGlkYXRlQWxnb3JpdGhtO1xuXG52YXIgU3RhdGUgPSB7XG4gIE5ldzogMCxcbiAgUGFyYW1zOiAxXG59O1xuXG52YXIgUGFyYW1zU3RhdGUgPSB7XG4gIE5hbWU6IDAsXG4gIFF1b3RlOiAxLFxuICBWYWx1ZTogMixcbiAgQ29tbWE6IDNcbn07XG5cblxuLy8vLS0tIFNwZWNpZmljIEVycm9yc1xuXG5cbmZ1bmN0aW9uIEV4cGlyZWRSZXF1ZXN0RXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBFeHBpcmVkUmVxdWVzdEVycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoRXhwaXJlZFJlcXVlc3RFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuXG5mdW5jdGlvbiBJbnZhbGlkSGVhZGVyRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBJbnZhbGlkSGVhZGVyRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhJbnZhbGlkSGVhZGVyRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cblxuZnVuY3Rpb24gSW52YWxpZFBhcmFtc0Vycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgSW52YWxpZFBhcmFtc0Vycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoSW52YWxpZFBhcmFtc0Vycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5cbmZ1bmN0aW9uIE1pc3NpbmdIZWFkZXJFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIE1pc3NpbmdIZWFkZXJFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKE1pc3NpbmdIZWFkZXJFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuZnVuY3Rpb24gU3RyaWN0UGFyc2luZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgU3RyaWN0UGFyc2luZ0Vycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RyaWN0UGFyc2luZ0Vycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlICdBdXRob3JpemF0aW9uJyBoZWFkZXIgb3V0IG9mIGFuIGh0dHAuU2VydmVyUmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIEFQSSB3aWxsIGZ1bGx5IHZhbGlkYXRlIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciwgYW5kIHRocm93XG4gICAqIG9uIGFueSBlcnJvci4gIEl0IHdpbGwgbm90IGhvd2V2ZXIgY2hlY2sgdGhlIHNpZ25hdHVyZSwgb3IgdGhlIGtleUlkIGZvcm1hdFxuICAgKiBhcyB0aG9zZSBhcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudC4gIFlvdSBjYW4gdXNlIHRoZSBvcHRpb25zIG9iamVjdFxuICAgKiB0byBwYXNzIGluIGV4dHJhIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBBcyBhIHJlc3BvbnNlIG9iamVjdCB5b3UgY2FuIGV4cGVjdCB0aGlzOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICBcInNjaGVtZVwiOiBcIlNpZ25hdHVyZVwiLFxuICAgKiAgICAgICBcInBhcmFtc1wiOiB7XG4gICAqICAgICAgICAgXCJrZXlJZFwiOiBcImZvb1wiLFxuICAgKiAgICAgICAgIFwiYWxnb3JpdGhtXCI6IFwicnNhLXNoYTI1NlwiLFxuICAgKiAgICAgICAgIFwiaGVhZGVyc1wiOiBbXG4gICAqICAgICAgICAgICBcImRhdGVcIiBvciBcIngtZGF0ZVwiLFxuICAgKiAgICAgICAgICAgXCJkaWdlc3RcIlxuICAgKiAgICAgICAgIF0sXG4gICAqICAgICAgICAgXCJzaWduYXR1cmVcIjogXCJiYXNlNjRcIlxuICAgKiAgICAgICB9LFxuICAgKiAgICAgICBcInNpZ25pbmdTdHJpbmdcIjogXCJyZWFkeSB0byBiZSBwYXNzZWQgdG8gY3J5cHRvLnZlcmlmeSgpXCJcbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgYW4gaHR0cC5TZXJ2ZXJSZXF1ZXN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdCB3aXRoOlxuICAgKiAgICAgICAgICAgICAgICAgICAtIGNsb2NrU2tldzogYWxsb3dlZCBjbG9jayBza2V3IGluIHNlY29uZHMgKGRlZmF1bHQgMzAwKS5cbiAgICogICAgICAgICAgICAgICAgICAgLSBoZWFkZXJzOiByZXF1aXJlZCBoZWFkZXIgbmFtZXMgKGRlZjogZGF0ZSBvciB4LWRhdGUpXG4gICAqICAgICAgICAgICAgICAgICAgIC0gYWxnb3JpdGhtczogYWxnb3JpdGhtcyB0byBzdXBwb3J0IChkZWZhdWx0OiBhbGwpLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHN0cmljdDogc2hvdWxkIGVuZm9yY2UgbGF0ZXN0IHNwZWMgcGFyc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBwYXJzZWQgb3V0IG9iamVjdCAoc2VlIGFib3ZlKS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBpbnZhbGlkIGlucHV0LlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkSGVhZGVyRXJyb3J9IG9uIGFuIGludmFsaWQgQXV0aG9yaXphdGlvbiBoZWFkZXIgZXJyb3IuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRQYXJhbXNFcnJvcn0gaWYgdGhlIHBhcmFtcyBpbiB0aGUgc2NoZW1lIGFyZSBpbnZhbGlkLlxuICAgKiBAdGhyb3dzIHtNaXNzaW5nSGVhZGVyRXJyb3J9IGlmIHRoZSBwYXJhbXMgaW5kaWNhdGUgYSBoZWFkZXIgbm90IHByZXNlbnQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyIGluIHRoZSByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGUgcGFyYW1zLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIG5vdCBpbiB0aGUgcGFyYW1zIGZyb20gYSByZXF1aXJlZCBoZWFkZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvcHRpb25zLlxuICAgKiBAdGhyb3dzIHtTdHJpY3RQYXJzaW5nRXJyb3J9IGlmIG9sZCBhdHRyaWJ1dGVzIGFyZSB1c2VkIGluIHN0cmljdCBwYXJzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZS5cbiAgICogQHRocm93cyB7RXhwaXJlZFJlcXVlc3RFcnJvcn0gaWYgdGhlIHZhbHVlIG9mIGRhdGUgb3IgeC1kYXRlIGV4Y2VlZHMgc2tldy5cbiAgICovXG4gIHBhcnNlUmVxdWVzdDogZnVuY3Rpb24gcGFyc2VSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQub2JqZWN0KHJlcXVlc3QsICdyZXF1ZXN0Jyk7XG4gICAgYXNzZXJ0Lm9iamVjdChyZXF1ZXN0LmhlYWRlcnMsICdyZXF1ZXN0LmhlYWRlcnMnKTtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gW3JlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10gPyAneC1kYXRlJyA6ICdkYXRlJ107XG4gICAgfVxuICAgIGFzc2VydC5vYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcbiAgICBhc3NlcnQuYXJyYXlPZlN0cmluZyhvcHRpb25zLmhlYWRlcnMsICdvcHRpb25zLmhlYWRlcnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxGaW5pdGUob3B0aW9ucy5jbG9ja1NrZXcsICdvcHRpb25zLmNsb2NrU2tldycpO1xuXG4gICAgdmFyIGF1dGh6SGVhZGVyTmFtZSA9IG9wdGlvbnMuYXV0aG9yaXphdGlvbkhlYWRlck5hbWUgfHwgJ2F1dGhvcml6YXRpb24nO1xuXG4gICAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNbYXV0aHpIZWFkZXJOYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcignbm8gJyArIGF1dGh6SGVhZGVyTmFtZSArICcgaGVhZGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJlc2VudCBpbiB0aGUgcmVxdWVzdCcpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuY2xvY2tTa2V3ID0gb3B0aW9ucy5jbG9ja1NrZXcgfHwgMzAwO1xuXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHN0YXRlID0gU3RhdGUuTmV3O1xuICAgIHZhciBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLk5hbWU7XG4gICAgdmFyIHRtcE5hbWUgPSAnJztcbiAgICB2YXIgdG1wVmFsdWUgPSAnJztcblxuICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICBzY2hlbWU6ICcnLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIHNpZ25pbmdTdHJpbmc6ICcnXG4gICAgfTtcblxuICAgIHZhciBhdXRoeiA9IHJlcXVlc3QuaGVhZGVyc1thdXRoekhlYWRlck5hbWVdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhdXRoei5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBhdXRoei5jaGFyQXQoaSk7XG5cbiAgICAgIHN3aXRjaCAoTnVtYmVyKHN0YXRlKSkge1xuXG4gICAgICBjYXNlIFN0YXRlLk5ldzpcbiAgICAgICAgaWYgKGMgIT09ICcgJykgcGFyc2VkLnNjaGVtZSArPSBjO1xuICAgICAgICBlbHNlIHN0YXRlID0gU3RhdGUuUGFyYW1zO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdGF0ZS5QYXJhbXM6XG4gICAgICAgIHN3aXRjaCAoTnVtYmVyKHN1YnN0YXRlKSkge1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuTmFtZTpcbiAgICAgICAgICB2YXIgY29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAvLyByZXN0cmljdGVkIG5hbWUgb2YgQS1aIC8gYS16XG4gICAgICAgICAgaWYgKChjb2RlID49IDB4NDEgJiYgY29kZSA8PSAweDVhKSB8fCAvLyBBLVpcbiAgICAgICAgICAgICAgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N2EpKSB7IC8vIGEtelxuICAgICAgICAgICAgdG1wTmFtZSArPSBjO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpZiAodG1wTmFtZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuUXVvdGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5RdW90ZTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgdG1wVmFsdWUgPSAnJztcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuVmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5WYWx1ZTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgcGFyc2VkLnBhcmFtc1t0bXBOYW1lXSA9IHRtcFZhbHVlO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5Db21tYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG1wVmFsdWUgKz0gYztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5Db21tYTpcbiAgICAgICAgICBpZiAoYyA9PT0gJywnKSB7XG4gICAgICAgICAgICB0bXBOYW1lID0gJyc7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLk5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnN0YXRlJyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuaGVhZGVycyB8fCBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPT09ICcnKSB7XG4gICAgICBpZiAocmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSkge1xuICAgICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPSBbJ3gtZGF0ZSddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID0gWydkYXRlJ107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9IHBhcnNlZC5wYXJhbXMuaGVhZGVycy5zcGxpdCgnICcpO1xuICAgIH1cblxuICAgIC8vIE1pbmltYWxseSB2YWxpZGF0ZSB0aGUgcGFyc2VkIG9iamVjdFxuICAgIGlmICghcGFyc2VkLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lICE9PSAnU2lnbmF0dXJlJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ3NjaGVtZSB3YXMgbm90IFwiU2lnbmF0dXJlXCInKTtcblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5rZXlJZClcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2tleUlkIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYWxnb3JpdGhtIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuc2lnbmF0dXJlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignc2lnbmF0dXJlIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICAvLyBDaGVjayB0aGUgYWxnb3JpdGhtIGFnYWluc3QgdGhlIG9mZmljaWFsIGxpc3RcbiAgICBwYXJzZWQucGFyYW1zLmFsZ29yaXRobSA9IHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCk7XG4gICAgdHJ5IHtcbiAgICAgIHZhbGlkYXRlQWxnb3JpdGhtKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEludmFsaWRBbGdvcml0aG1FcnJvcilcbiAgICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkUGFyYW1zRXJyb3IocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0gKyAnIGlzIG5vdCAnICtcbiAgICAgICAgICAnc3VwcG9ydGVkJykpO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyAoZSk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIHNpZ25pbmdTdHJpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFyc2VkLnBhcmFtcy5oZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaCA9IHBhcnNlZC5wYXJhbXMuaGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzW2ldID0gaDtcblxuICAgICAgaWYgKGggPT09ICdyZXF1ZXN0LWxpbmUnKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIFdlIGFsbG93IGhlYWRlcnMgZnJvbSB0aGUgb2xkZXIgc3BlYyBkcmFmdHMgaWYgc3RyaWN0IHBhcnNpbmcgaXNuJ3RcbiAgICAgICAgICAgKiBzcGVjaWZpZWQgaW4gb3B0aW9ucy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPVxuICAgICAgICAgICAgcmVxdWVzdC5tZXRob2QgKyAnICcgKyByZXF1ZXN0LnVybCArICcgSFRUUC8nICsgcmVxdWVzdC5odHRwVmVyc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBTdHJpY3QgcGFyc2luZyBkb2Vzbid0IGFsbG93IG9sZGVyIGRyYWZ0IGhlYWRlcnMuICovXG4gICAgICAgICAgdGhyb3cgKG5ldyBTdHJpY3RQYXJzaW5nRXJyb3IoJ3JlcXVlc3QtbGluZSBpcyBub3QgYSB2YWxpZCBoZWFkZXIgJyArXG4gICAgICAgICAgICAnd2l0aCBzdHJpY3QgcGFyc2luZyBlbmFibGVkLicpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoID09PSAnKHJlcXVlc3QtdGFyZ2V0KScpIHtcbiAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz1cbiAgICAgICAgICAnKHJlcXVlc3QtdGFyZ2V0KTogJyArIHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgKyAnICcgK1xuICAgICAgICAgIHJlcXVlc3QudXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVxdWVzdC5oZWFkZXJzW2hdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKGggKyAnIHdhcyBub3QgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz0gaCArICc6ICcgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpICsgMSkgPCBwYXJzZWQucGFyYW1zLmhlYWRlcnMubGVuZ3RoKVxuICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPSAnXFxuJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBhZ2FpbnN0IHRoZSBjb25zdHJhaW50c1xuICAgIHZhciBkYXRlO1xuICAgIGlmIChyZXF1ZXN0LmhlYWRlcnMuZGF0ZSB8fCByZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShyZXF1ZXN0LmhlYWRlcnMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgdmFyIHNrZXcgPSBNYXRoLmFicyhub3cuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lKCkpO1xuXG4gICAgICBpZiAoc2tldyA+IG9wdGlvbnMuY2xvY2tTa2V3ICogMTAwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXhwaXJlZFJlcXVlc3RFcnJvcignY2xvY2sgc2tldyBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNrZXcgLyAxMDAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzIHdhcyBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2xvY2tTa2V3ICsgJ3MnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGRyKSB7XG4gICAgICAvLyBSZW1lbWJlciB0aGF0IHdlIGFscmVhZHkgY2hlY2tlZCBhbnkgaGVhZGVycyBpbiB0aGUgcGFyYW1zXG4gICAgICAvLyB3ZXJlIGluIHRoZSByZXF1ZXN0LCBzbyBpZiB0aGlzIHBhc3NlcyB3ZSdyZSBnb29kLlxuICAgICAgaWYgKHBhcnNlZC5wYXJhbXMuaGVhZGVycy5pbmRleE9mKGhkci50b0xvd2VyQ2FzZSgpKSA8IDApXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nSGVhZGVyRXJyb3IoaGRyICsgJyB3YXMgbm90IGEgc2lnbmVkIGhlYWRlcicpO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtcykge1xuICAgICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtcy5pbmRleE9mKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtKSA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1zRXJyb3IocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgbm90IGEgc3VwcG9ydGVkIGFsZ29yaXRobScpO1xuICAgIH1cblxuICAgIHBhcnNlZC5hbGdvcml0aG0gPSBwYXJzZWQucGFyYW1zLmFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgIHBhcnNlZC5rZXlJZCA9IHBhcnNlZC5wYXJhbXMua2V5SWQ7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG59O1xuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJ1dGlsIiwidXRpbHMiLCJIQVNIX0FMR09TIiwiUEtfQUxHT1MiLCJIdHRwU2lnbmF0dXJlRXJyb3IiLCJJbnZhbGlkQWxnb3JpdGhtRXJyb3IiLCJ2YWxpZGF0ZUFsZ29yaXRobSIsIlN0YXRlIiwiTmV3IiwiUGFyYW1zIiwiUGFyYW1zU3RhdGUiLCJOYW1lIiwiUXVvdGUiLCJWYWx1ZSIsIkNvbW1hIiwiRXhwaXJlZFJlcXVlc3RFcnJvciIsIm1lc3NhZ2UiLCJjYWxsIiwiaW5oZXJpdHMiLCJJbnZhbGlkSGVhZGVyRXJyb3IiLCJJbnZhbGlkUGFyYW1zRXJyb3IiLCJNaXNzaW5nSGVhZGVyRXJyb3IiLCJTdHJpY3RQYXJzaW5nRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2VSZXF1ZXN0IiwicmVxdWVzdCIsIm9wdGlvbnMiLCJvYmplY3QiLCJoZWFkZXJzIiwidW5kZWZpbmVkIiwiYXJyYXlPZlN0cmluZyIsIm9wdGlvbmFsRmluaXRlIiwiY2xvY2tTa2V3IiwiYXV0aHpIZWFkZXJOYW1lIiwiYXV0aG9yaXphdGlvbkhlYWRlck5hbWUiLCJpIiwic3RhdGUiLCJzdWJzdGF0ZSIsInRtcE5hbWUiLCJ0bXBWYWx1ZSIsInBhcnNlZCIsInNjaGVtZSIsInBhcmFtcyIsInNpZ25pbmdTdHJpbmciLCJhdXRoeiIsImxlbmd0aCIsImMiLCJjaGFyQXQiLCJOdW1iZXIiLCJjb2RlIiwiY2hhckNvZGVBdCIsIkVycm9yIiwic3BsaXQiLCJrZXlJZCIsImFsZ29yaXRobSIsInNpZ25hdHVyZSIsInRvTG93ZXJDYXNlIiwiZSIsImgiLCJzdHJpY3QiLCJtZXRob2QiLCJ1cmwiLCJodHRwVmVyc2lvbiIsInZhbHVlIiwiZGF0ZSIsIkRhdGUiLCJub3ciLCJza2V3IiwiTWF0aCIsImFicyIsImdldFRpbWUiLCJmb3JFYWNoIiwiaGRyIiwiaW5kZXhPZiIsImFsZ29yaXRobXMiLCJ0b1VwcGVyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/signer.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/signer.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(rsc)/./node_modules/sshpk/lib/index.js\");\nvar jsprim = __webpack_require__(/*! jsprim */ \"(rsc)/./node_modules/jsprim/lib/jsprim.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/http-signature/lib/utils.js\");\nvar sprintf = (__webpack_require__(/*! util */ \"util\").format);\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar validateAlgorithm = utils.validateAlgorithm;\n///--- Globals\nvar AUTHZ_FMT = 'Signature keyId=\"%s\",algorithm=\"%s\",headers=\"%s\",signature=\"%s\"';\n///--- Specific Errors\nfunction MissingHeaderError(message) {\n    HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\nfunction StrictParsingError(message) {\n    HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n/* See createSigner() */ function RequestSigner(options) {\n    assert.object(options, \"options\");\n    var alg = [];\n    if (options.algorithm !== undefined) {\n        assert.string(options.algorithm, \"options.algorithm\");\n        alg = validateAlgorithm(options.algorithm);\n    }\n    this.rs_alg = alg;\n    /*\n   * RequestSigners come in two varieties: ones with an rs_signFunc, and ones\n   * with an rs_signer.\n   *\n   * rs_signFunc-based RequestSigners have to build up their entire signing\n   * string within the rs_lines array and give it to rs_signFunc as a single\n   * concat'd blob. rs_signer-based RequestSigners can add a line at a time to\n   * their signing state by using rs_signer.update(), thus only needing to\n   * buffer the hash function state and one line at a time.\n   */ if (options.sign !== undefined) {\n        assert.func(options.sign, \"options.sign\");\n        this.rs_signFunc = options.sign;\n    } else if (alg[0] === \"hmac\" && options.key !== undefined) {\n        assert.string(options.keyId, \"options.keyId\");\n        this.rs_keyId = options.keyId;\n        if (typeof options.key !== \"string\" && !Buffer.isBuffer(options.key)) throw new TypeError(\"options.key for HMAC must be a string or Buffer\");\n        /*\n     * Make an rs_signer for HMACs, not a rs_signFunc -- HMACs digest their\n     * data in chunks rather than requiring it all to be given in one go\n     * at the end, so they are more similar to signers than signFuncs.\n     */ this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);\n        this.rs_signer.sign = function() {\n            var digest = this.digest(\"base64\");\n            return {\n                hashAlgorithm: alg[1],\n                toString: function() {\n                    return digest;\n                }\n            };\n        };\n    } else if (options.key !== undefined) {\n        var key = options.key;\n        if (typeof key === \"string\" || Buffer.isBuffer(key)) key = sshpk.parsePrivateKey(key);\n        assert.ok(sshpk.PrivateKey.isPrivateKey(key, [\n            1,\n            2\n        ]), \"options.key must be a sshpk.PrivateKey\");\n        this.rs_key = key;\n        assert.string(options.keyId, \"options.keyId\");\n        this.rs_keyId = options.keyId;\n        if (!PK_ALGOS[key.type]) {\n            throw new InvalidAlgorithmError(key.type.toUpperCase() + \" type \" + \"keys are not supported\");\n        }\n        if (alg[0] !== undefined && key.type !== alg[0]) {\n            throw new InvalidAlgorithmError(\"options.key must be a \" + alg[0].toUpperCase() + \" key, was given a \" + key.type.toUpperCase() + \" key instead\");\n        }\n        this.rs_signer = key.createSign(alg[1]);\n    } else {\n        throw new TypeError(\"options.sign (func) or options.key is required\");\n    }\n    this.rs_headers = [];\n    this.rs_lines = [];\n}\n/**\n * Adds a header to be signed, with its value, into this signer.\n *\n * @param {String} header\n * @param {String} value\n * @return {String} value written\n */ RequestSigner.prototype.writeHeader = function(header, value) {\n    assert.string(header, \"header\");\n    header = header.toLowerCase();\n    assert.string(value, \"value\");\n    this.rs_headers.push(header);\n    if (this.rs_signFunc) {\n        this.rs_lines.push(header + \": \" + value);\n    } else {\n        var line = header + \": \" + value;\n        if (this.rs_headers.length > 0) line = \"\\n\" + line;\n        this.rs_signer.update(line);\n    }\n    return value;\n};\n/**\n * Adds a default Date header, returning its value.\n *\n * @return {String}\n */ RequestSigner.prototype.writeDateHeader = function() {\n    return this.writeHeader(\"date\", jsprim.rfc1123(new Date()));\n};\n/**\n * Adds the request target line to be signed.\n *\n * @param {String} method, HTTP method (e.g. 'get', 'post', 'put')\n * @param {String} path\n */ RequestSigner.prototype.writeTarget = function(method, path) {\n    assert.string(method, \"method\");\n    assert.string(path, \"path\");\n    method = method.toLowerCase();\n    this.writeHeader(\"(request-target)\", method + \" \" + path);\n};\n/**\n * Calculate the value for the Authorization header on this request\n * asynchronously.\n *\n * @param {Func} callback (err, authz)\n */ RequestSigner.prototype.sign = function(cb) {\n    assert.func(cb, \"callback\");\n    if (this.rs_headers.length < 1) throw new Error(\"At least one header must be signed\");\n    var alg, authz;\n    if (this.rs_signFunc) {\n        var data = this.rs_lines.join(\"\\n\");\n        var self = this;\n        this.rs_signFunc(data, function(err, sig) {\n            if (err) {\n                cb(err);\n                return;\n            }\n            try {\n                assert.object(sig, \"signature\");\n                assert.string(sig.keyId, \"signature.keyId\");\n                assert.string(sig.algorithm, \"signature.algorithm\");\n                assert.string(sig.signature, \"signature.signature\");\n                alg = validateAlgorithm(sig.algorithm);\n                authz = sprintf(AUTHZ_FMT, sig.keyId, sig.algorithm, self.rs_headers.join(\" \"), sig.signature);\n            } catch (e) {\n                cb(e);\n                return;\n            }\n            cb(null, authz);\n        });\n    } else {\n        try {\n            var sigObj = this.rs_signer.sign();\n        } catch (e) {\n            cb(e);\n            return;\n        }\n        alg = (this.rs_alg[0] || this.rs_key.type) + \"-\" + sigObj.hashAlgorithm;\n        var signature = sigObj.toString();\n        authz = sprintf(AUTHZ_FMT, this.rs_keyId, alg, this.rs_headers.join(\" \"), signature);\n        cb(null, authz);\n    }\n};\n///--- Exported API\nmodule.exports = {\n    /**\n   * Identifies whether a given object is a request signer or not.\n   *\n   * @param {Object} object, the object to identify\n   * @returns {Boolean}\n   */ isSigner: function(obj) {\n        if (typeof obj === \"object\" && obj instanceof RequestSigner) return true;\n        return false;\n    },\n    /**\n   * Creates a request signer, used to asynchronously build a signature\n   * for a request (does not have to be an http.ClientRequest).\n   *\n   * @param {Object} options, either:\n   *                   - {String} keyId\n   *                   - {String|Buffer} key\n   *                   - {String} algorithm (optional, required for HMAC)\n   *                 or:\n   *                   - {Func} sign (data, cb)\n   * @return {RequestSigner}\n   */ createSigner: function createSigner(options) {\n        return new RequestSigner(options);\n    },\n    /**\n   * Adds an 'Authorization' header to an http.ClientRequest object.\n   *\n   * Note that this API will add a Date header if it's not already set. Any\n   * other headers in the options.headers array MUST be present, or this\n   * will throw.\n   *\n   * You shouldn't need to check the return type; it's just there if you want\n   * to be pedantic.\n   *\n   * The optional flag indicates whether parsing should use strict enforcement\n   * of the version draft-cavage-http-signatures-04 of the spec or beyond.\n   * The default is to be loose and support\n   * older versions for compatibility.\n   *\n   * @param {Object} request an instance of http.ClientRequest.\n   * @param {Object} options signing parameters object:\n   *                   - {String} keyId required.\n   *                   - {String} key required (either a PEM or HMAC key).\n   *                   - {Array} headers optional; defaults to ['date'].\n   *                   - {String} algorithm optional (unless key is HMAC);\n   *                              default is the same as the sshpk default\n   *                              signing algorithm for the type of key given\n   *                   - {String} httpVersion optional; defaults to '1.1'.\n   *                   - {Boolean} strict optional; defaults to 'false'.\n   * @return {Boolean} true if Authorization (and optionally Date) were added.\n   * @throws {TypeError} on bad parameter types (input).\n   * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with\n   *                                 the given key.\n   * @throws {sshpk.KeyParseError} if key was bad.\n   * @throws {MissingHeaderError} if a header to be signed was specified but\n   *                              was not present.\n   */ signRequest: function signRequest(request, options) {\n        assert.object(request, \"request\");\n        assert.object(options, \"options\");\n        assert.optionalString(options.algorithm, \"options.algorithm\");\n        assert.string(options.keyId, \"options.keyId\");\n        assert.optionalArrayOfString(options.headers, \"options.headers\");\n        assert.optionalString(options.httpVersion, \"options.httpVersion\");\n        if (!request.getHeader(\"Date\")) request.setHeader(\"Date\", jsprim.rfc1123(new Date()));\n        if (!options.headers) options.headers = [\n            \"date\"\n        ];\n        if (!options.httpVersion) options.httpVersion = \"1.1\";\n        var alg = [];\n        if (options.algorithm) {\n            options.algorithm = options.algorithm.toLowerCase();\n            alg = validateAlgorithm(options.algorithm);\n        }\n        var i;\n        var stringToSign = \"\";\n        for(i = 0; i < options.headers.length; i++){\n            if (typeof options.headers[i] !== \"string\") throw new TypeError(\"options.headers must be an array of Strings\");\n            var h = options.headers[i].toLowerCase();\n            if (h === \"request-line\") {\n                if (!options.strict) {\n                    /**\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */ stringToSign += request.method + \" \" + request.path + \" HTTP/\" + options.httpVersion;\n                } else {\n                    /* Strict parsing doesn't allow older draft headers. */ throw new StrictParsingError(\"request-line is not a valid header \" + \"with strict parsing enabled.\");\n                }\n            } else if (h === \"(request-target)\") {\n                stringToSign += \"(request-target): \" + request.method.toLowerCase() + \" \" + request.path;\n            } else {\n                var value = request.getHeader(h);\n                if (value === undefined || value === \"\") {\n                    throw new MissingHeaderError(h + \" was not in the request\");\n                }\n                stringToSign += h + \": \" + value;\n            }\n            if (i + 1 < options.headers.length) stringToSign += \"\\n\";\n        }\n        /* This is just for unit tests. */ if (request.hasOwnProperty(\"_stringToSign\")) {\n            request._stringToSign = stringToSign;\n        }\n        var signature;\n        if (alg[0] === \"hmac\") {\n            if (typeof options.key !== \"string\" && !Buffer.isBuffer(options.key)) throw new TypeError(\"options.key must be a string or Buffer\");\n            var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);\n            hmac.update(stringToSign);\n            signature = hmac.digest(\"base64\");\n        } else {\n            var key = options.key;\n            if (typeof key === \"string\" || Buffer.isBuffer(key)) key = sshpk.parsePrivateKey(options.key);\n            assert.ok(sshpk.PrivateKey.isPrivateKey(key, [\n                1,\n                2\n            ]), \"options.key must be a sshpk.PrivateKey\");\n            if (!PK_ALGOS[key.type]) {\n                throw new InvalidAlgorithmError(key.type.toUpperCase() + \" type \" + \"keys are not supported\");\n            }\n            if (alg[0] !== undefined && key.type !== alg[0]) {\n                throw new InvalidAlgorithmError(\"options.key must be a \" + alg[0].toUpperCase() + \" key, was given a \" + key.type.toUpperCase() + \" key instead\");\n            }\n            var signer = key.createSign(alg[1]);\n            signer.update(stringToSign);\n            var sigObj = signer.sign();\n            if (!HASH_ALGOS[sigObj.hashAlgorithm]) {\n                throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + \" is not a supported hash algorithm\");\n            }\n            options.algorithm = key.type + \"-\" + sigObj.hashAlgorithm;\n            signature = sigObj.toString();\n            assert.notStrictEqual(signature, \"\", \"empty signature produced\");\n        }\n        var authzHeaderName = options.authorizationHeaderName || \"Authorization\";\n        request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(\" \"), signature));\n        return true;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3NpZ25lci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvREFBb0Q7O0FBRXBELElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlHLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ25CLElBQUlJLFFBQVFKLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlLLFNBQVNMLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlNLFFBQVFOLG1CQUFPQSxDQUFDO0FBRXBCLElBQUlPLFVBQVVQLGdEQUFzQjtBQUVwQyxJQUFJUyxhQUFhSCxNQUFNRyxVQUFVO0FBQ2pDLElBQUlDLFdBQVdKLE1BQU1JLFFBQVE7QUFDN0IsSUFBSUMsd0JBQXdCTCxNQUFNSyxxQkFBcUI7QUFDdkQsSUFBSUMscUJBQXFCTixNQUFNTSxrQkFBa0I7QUFDakQsSUFBSUMsb0JBQW9CUCxNQUFNTyxpQkFBaUI7QUFFL0MsY0FBYztBQUVkLElBQUlDLFlBQ0Y7QUFFRixzQkFBc0I7QUFFdEIsU0FBU0MsbUJBQW1CQyxPQUFPO0lBQ2pDSixtQkFBbUJLLElBQUksQ0FBQyxJQUFJLEVBQUVELFNBQVNEO0FBQ3pDO0FBQ0FaLEtBQUtlLFFBQVEsQ0FBQ0gsb0JBQW9CSDtBQUVsQyxTQUFTTyxtQkFBbUJILE9BQU87SUFDakNKLG1CQUFtQkssSUFBSSxDQUFDLElBQUksRUFBRUQsU0FBU0c7QUFDekM7QUFDQWhCLEtBQUtlLFFBQVEsQ0FBQ0Msb0JBQW9CUDtBQUVsQyxzQkFBc0IsR0FDdEIsU0FBU1EsY0FBY0MsT0FBTztJQUM1QnRCLE9BQU91QixNQUFNLENBQUNELFNBQVM7SUFFdkIsSUFBSUUsTUFBTSxFQUFFO0lBQ1osSUFBSUYsUUFBUUcsU0FBUyxLQUFLQyxXQUFXO1FBQ25DMUIsT0FBTzJCLE1BQU0sQ0FBQ0wsUUFBUUcsU0FBUyxFQUFF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QVFnRix1QkFBdUIsSUFBSTtRQUV6RGpCLFFBQVFNLFNBQVMsQ0FBQ1UsaUJBQWlCN0YsUUFBUU8sV0FDQU8sUUFBUVcsS0FBSyxFQUNiWCxRQUFRRyxTQUFTLEVBQ2pCSCxRQUFRa0UsT0FBTyxDQUFDaEIsSUFBSSxDQUFDLE1BQ3JCSTtRQUUzQyxPQUFPO0lBQ1Q7QUFFRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi9zaWduZXIuanM/YTk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBzc2hwayA9IHJlcXVpcmUoJ3NzaHBrJyk7XG52YXIganNwcmltID0gcmVxdWlyZSgnanNwcmltJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBzcHJpbnRmID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxudmFyIEhBU0hfQUxHT1MgPSB1dGlscy5IQVNIX0FMR09TO1xudmFyIFBLX0FMR09TID0gdXRpbHMuUEtfQUxHT1M7XG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gdXRpbHMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xudmFyIEh0dHBTaWduYXR1cmVFcnJvciA9IHV0aWxzLkh0dHBTaWduYXR1cmVFcnJvcjtcbnZhciB2YWxpZGF0ZUFsZ29yaXRobSA9IHV0aWxzLnZhbGlkYXRlQWxnb3JpdGhtO1xuXG4vLy8tLS0gR2xvYmFsc1xuXG52YXIgQVVUSFpfRk1UID1cbiAgJ1NpZ25hdHVyZSBrZXlJZD1cIiVzXCIsYWxnb3JpdGhtPVwiJXNcIixoZWFkZXJzPVwiJXNcIixzaWduYXR1cmU9XCIlc1wiJztcblxuLy8vLS0tIFNwZWNpZmljIEVycm9yc1xuXG5mdW5jdGlvbiBNaXNzaW5nSGVhZGVyRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBNaXNzaW5nSGVhZGVyRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhNaXNzaW5nSGVhZGVyRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbmZ1bmN0aW9uIFN0cmljdFBhcnNpbmdFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIFN0cmljdFBhcnNpbmdFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKFN0cmljdFBhcnNpbmdFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuLyogU2VlIGNyZWF0ZVNpZ25lcigpICovXG5mdW5jdGlvbiBSZXF1ZXN0U2lnbmVyKG9wdGlvbnMpIHtcbiAgYXNzZXJ0Lm9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXG4gIHZhciBhbGcgPSBbXTtcbiAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMuYWxnb3JpdGhtLCAnb3B0aW9ucy5hbGdvcml0aG0nKTtcbiAgICBhbGcgPSB2YWxpZGF0ZUFsZ29yaXRobShvcHRpb25zLmFsZ29yaXRobSk7XG4gIH1cbiAgdGhpcy5yc19hbGcgPSBhbGc7XG5cbiAgLypcbiAgICogUmVxdWVzdFNpZ25lcnMgY29tZSBpbiB0d28gdmFyaWV0aWVzOiBvbmVzIHdpdGggYW4gcnNfc2lnbkZ1bmMsIGFuZCBvbmVzXG4gICAqIHdpdGggYW4gcnNfc2lnbmVyLlxuICAgKlxuICAgKiByc19zaWduRnVuYy1iYXNlZCBSZXF1ZXN0U2lnbmVycyBoYXZlIHRvIGJ1aWxkIHVwIHRoZWlyIGVudGlyZSBzaWduaW5nXG4gICAqIHN0cmluZyB3aXRoaW4gdGhlIHJzX2xpbmVzIGFycmF5IGFuZCBnaXZlIGl0IHRvIHJzX3NpZ25GdW5jIGFzIGEgc2luZ2xlXG4gICAqIGNvbmNhdCdkIGJsb2IuIHJzX3NpZ25lci1iYXNlZCBSZXF1ZXN0U2lnbmVycyBjYW4gYWRkIGEgbGluZSBhdCBhIHRpbWUgdG9cbiAgICogdGhlaXIgc2lnbmluZyBzdGF0ZSBieSB1c2luZyByc19zaWduZXIudXBkYXRlKCksIHRodXMgb25seSBuZWVkaW5nIHRvXG4gICAqIGJ1ZmZlciB0aGUgaGFzaCBmdW5jdGlvbiBzdGF0ZSBhbmQgb25lIGxpbmUgYXQgYSB0aW1lLlxuICAgKi9cbiAgaWYgKG9wdGlvbnMuc2lnbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0LmZ1bmMob3B0aW9ucy5zaWduLCAnb3B0aW9ucy5zaWduJyk7XG4gICAgdGhpcy5yc19zaWduRnVuYyA9IG9wdGlvbnMuc2lnbjtcblxuICB9IGVsc2UgaWYgKGFsZ1swXSA9PT0gJ2htYWMnICYmIG9wdGlvbnMua2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMua2V5SWQsICdvcHRpb25zLmtleUlkJyk7XG4gICAgdGhpcy5yc19rZXlJZCA9IG9wdGlvbnMua2V5SWQ7XG5cbiAgICBpZiAodHlwZW9mIChvcHRpb25zLmtleSkgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5rZXkpKVxuICAgICAgdGhyb3cgKG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMua2V5IGZvciBITUFDIG11c3QgYmUgYSBzdHJpbmcgb3IgQnVmZmVyJykpO1xuXG4gICAgLypcbiAgICAgKiBNYWtlIGFuIHJzX3NpZ25lciBmb3IgSE1BQ3MsIG5vdCBhIHJzX3NpZ25GdW5jIC0tIEhNQUNzIGRpZ2VzdCB0aGVpclxuICAgICAqIGRhdGEgaW4gY2h1bmtzIHJhdGhlciB0aGFuIHJlcXVpcmluZyBpdCBhbGwgdG8gYmUgZ2l2ZW4gaW4gb25lIGdvXG4gICAgICogYXQgdGhlIGVuZCwgc28gdGhleSBhcmUgbW9yZSBzaW1pbGFyIHRvIHNpZ25lcnMgdGhhbiBzaWduRnVuY3MuXG4gICAgICovXG4gICAgdGhpcy5yc19zaWduZXIgPSBjcnlwdG8uY3JlYXRlSG1hYyhhbGdbMV0udG9VcHBlckNhc2UoKSwgb3B0aW9ucy5rZXkpO1xuICAgIHRoaXMucnNfc2lnbmVyLnNpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGlnZXN0ID0gdGhpcy5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgICAgcmV0dXJuICh7XG4gICAgICAgIGhhc2hBbGdvcml0aG06IGFsZ1sxXSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChkaWdlc3QpOyB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBpZiAodHlwZW9mIChrZXkpID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIoa2V5KSlcbiAgICAgIGtleSA9IHNzaHBrLnBhcnNlUHJpdmF0ZUtleShrZXkpO1xuXG4gICAgYXNzZXJ0Lm9rKHNzaHBrLlByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSwgWzEsIDJdKSxcbiAgICAgICdvcHRpb25zLmtleSBtdXN0IGJlIGEgc3NocGsuUHJpdmF0ZUtleScpO1xuICAgIHRoaXMucnNfa2V5ID0ga2V5O1xuXG4gICAgYXNzZXJ0LnN0cmluZyhvcHRpb25zLmtleUlkLCAnb3B0aW9ucy5rZXlJZCcpO1xuICAgIHRoaXMucnNfa2V5SWQgPSBvcHRpb25zLmtleUlkO1xuXG4gICAgaWYgKCFQS19BTEdPU1trZXkudHlwZV0pIHtcbiAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGtleS50eXBlLnRvVXBwZXJDYXNlKCkgKyAnIHR5cGUgJyArXG4gICAgICAgICdrZXlzIGFyZSBub3Qgc3VwcG9ydGVkJykpO1xuICAgIH1cblxuICAgIGlmIChhbGdbMF0gIT09IHVuZGVmaW5lZCAmJiBrZXkudHlwZSAhPT0gYWxnWzBdKSB7XG4gICAgICB0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcignb3B0aW9ucy5rZXkgbXVzdCBiZSBhICcgK1xuICAgICAgICBhbGdbMF0udG9VcHBlckNhc2UoKSArICcga2V5LCB3YXMgZ2l2ZW4gYSAnICtcbiAgICAgICAga2V5LnR5cGUudG9VcHBlckNhc2UoKSArICcga2V5IGluc3RlYWQnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5yc19zaWduZXIgPSBrZXkuY3JlYXRlU2lnbihhbGdbMV0pO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgKG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuc2lnbiAoZnVuYykgb3Igb3B0aW9ucy5rZXkgaXMgcmVxdWlyZWQnKSk7XG4gIH1cblxuICB0aGlzLnJzX2hlYWRlcnMgPSBbXTtcbiAgdGhpcy5yc19saW5lcyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZHMgYSBoZWFkZXIgdG8gYmUgc2lnbmVkLCB3aXRoIGl0cyB2YWx1ZSwgaW50byB0aGlzIHNpZ25lci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gdmFsdWUgd3JpdHRlblxuICovXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS53cml0ZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIsIHZhbHVlKSB7XG4gIGFzc2VydC5zdHJpbmcoaGVhZGVyLCAnaGVhZGVyJyk7XG4gIGhlYWRlciA9IGhlYWRlci50b0xvd2VyQ2FzZSgpO1xuICBhc3NlcnQuc3RyaW5nKHZhbHVlLCAndmFsdWUnKTtcblxuICB0aGlzLnJzX2hlYWRlcnMucHVzaChoZWFkZXIpO1xuXG4gIGlmICh0aGlzLnJzX3NpZ25GdW5jKSB7XG4gICAgdGhpcy5yc19saW5lcy5wdXNoKGhlYWRlciArICc6ICcgKyB2YWx1ZSk7XG5cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGluZSA9IGhlYWRlciArICc6ICcgKyB2YWx1ZTtcbiAgICBpZiAodGhpcy5yc19oZWFkZXJzLmxlbmd0aCA+IDApXG4gICAgICBsaW5lID0gJ1xcbicgKyBsaW5lO1xuICAgIHRoaXMucnNfc2lnbmVyLnVwZGF0ZShsaW5lKTtcbiAgfVxuXG4gIHJldHVybiAodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZGVmYXVsdCBEYXRlIGhlYWRlciwgcmV0dXJuaW5nIGl0cyB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLndyaXRlRGF0ZUhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLndyaXRlSGVhZGVyKCdkYXRlJywganNwcmltLnJmYzExMjMobmV3IERhdGUoKSkpKTtcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgcmVxdWVzdCB0YXJnZXQgbGluZSB0byBiZSBzaWduZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCwgSFRUUCBtZXRob2QgKGUuZy4gJ2dldCcsICdwb3N0JywgJ3B1dCcpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICovXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS53cml0ZVRhcmdldCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhdGgpIHtcbiAgYXNzZXJ0LnN0cmluZyhtZXRob2QsICdtZXRob2QnKTtcbiAgYXNzZXJ0LnN0cmluZyhwYXRoLCAncGF0aCcpO1xuICBtZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy53cml0ZUhlYWRlcignKHJlcXVlc3QtdGFyZ2V0KScsIG1ldGhvZCArICcgJyArIHBhdGgpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHZhbHVlIGZvciB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXIgb24gdGhpcyByZXF1ZXN0XG4gKiBhc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN9IGNhbGxiYWNrIChlcnIsIGF1dGh6KVxuICovXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKGNiKSB7XG4gIGFzc2VydC5mdW5jKGNiLCAnY2FsbGJhY2snKTtcblxuICBpZiAodGhpcy5yc19oZWFkZXJzLmxlbmd0aCA8IDEpXG4gICAgdGhyb3cgKG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIGhlYWRlciBtdXN0IGJlIHNpZ25lZCcpKTtcblxuICB2YXIgYWxnLCBhdXRoejtcbiAgaWYgKHRoaXMucnNfc2lnbkZ1bmMpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMucnNfbGluZXMuam9pbignXFxuJyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucnNfc2lnbkZ1bmMoZGF0YSwgZnVuY3Rpb24gKGVyciwgc2lnKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGFzc2VydC5vYmplY3Qoc2lnLCAnc2lnbmF0dXJlJyk7XG4gICAgICAgIGFzc2VydC5zdHJpbmcoc2lnLmtleUlkLCAnc2lnbmF0dXJlLmtleUlkJyk7XG4gICAgICAgIGFzc2VydC5zdHJpbmcoc2lnLmFsZ29yaXRobSwgJ3NpZ25hdHVyZS5hbGdvcml0aG0nKTtcbiAgICAgICAgYXNzZXJ0LnN0cmluZyhzaWcuc2lnbmF0dXJlLCAnc2lnbmF0dXJlLnNpZ25hdHVyZScpO1xuICAgICAgICBhbGcgPSB2YWxpZGF0ZUFsZ29yaXRobShzaWcuYWxnb3JpdGhtKTtcblxuICAgICAgICBhdXRoeiA9IHNwcmludGYoQVVUSFpfRk1ULFxuICAgICAgICAgIHNpZy5rZXlJZCxcbiAgICAgICAgICBzaWcuYWxnb3JpdGhtLFxuICAgICAgICAgIHNlbGYucnNfaGVhZGVycy5qb2luKCcgJyksXG4gICAgICAgICAgc2lnLnNpZ25hdHVyZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNiKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYihudWxsLCBhdXRoeik7XG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHNpZ09iaiA9IHRoaXMucnNfc2lnbmVyLnNpZ24oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWxnID0gKHRoaXMucnNfYWxnWzBdIHx8IHRoaXMucnNfa2V5LnR5cGUpICsgJy0nICsgc2lnT2JqLmhhc2hBbGdvcml0aG07XG4gICAgdmFyIHNpZ25hdHVyZSA9IHNpZ09iai50b1N0cmluZygpO1xuICAgIGF1dGh6ID0gc3ByaW50ZihBVVRIWl9GTVQsXG4gICAgICB0aGlzLnJzX2tleUlkLFxuICAgICAgYWxnLFxuICAgICAgdGhpcy5yc19oZWFkZXJzLmpvaW4oJyAnKSxcbiAgICAgIHNpZ25hdHVyZSk7XG4gICAgY2IobnVsbCwgYXV0aHopO1xuICB9XG59O1xuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogSWRlbnRpZmllcyB3aGV0aGVyIGEgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVxdWVzdCBzaWduZXIgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0LCB0aGUgb2JqZWN0IHRvIGlkZW50aWZ5XG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNTaWduZXI6IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIChvYmopID09PSAnb2JqZWN0JyAmJiBvYmogaW5zdGFuY2VvZiBSZXF1ZXN0U2lnbmVyKVxuICAgICAgcmV0dXJuICh0cnVlKTtcbiAgICByZXR1cm4gKGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlcXVlc3Qgc2lnbmVyLCB1c2VkIHRvIGFzeW5jaHJvbm91c2x5IGJ1aWxkIGEgc2lnbmF0dXJlXG4gICAqIGZvciBhIHJlcXVlc3QgKGRvZXMgbm90IGhhdmUgdG8gYmUgYW4gaHR0cC5DbGllbnRSZXF1ZXN0KS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMsIGVpdGhlcjpcbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBrZXlJZFxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd8QnVmZmVyfSBrZXlcbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhbGdvcml0aG0gKG9wdGlvbmFsLCByZXF1aXJlZCBmb3IgSE1BQylcbiAgICogICAgICAgICAgICAgICAgIG9yOlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtGdW5jfSBzaWduIChkYXRhLCBjYilcbiAgICogQHJldHVybiB7UmVxdWVzdFNpZ25lcn1cbiAgICovXG4gIGNyZWF0ZVNpZ25lcjogZnVuY3Rpb24gY3JlYXRlU2lnbmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG5ldyBSZXF1ZXN0U2lnbmVyKG9wdGlvbnMpKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhbiAnQXV0aG9yaXphdGlvbicgaGVhZGVyIHRvIGFuIGh0dHAuQ2xpZW50UmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIEFQSSB3aWxsIGFkZCBhIERhdGUgaGVhZGVyIGlmIGl0J3Mgbm90IGFscmVhZHkgc2V0LiBBbnlcbiAgICogb3RoZXIgaGVhZGVycyBpbiB0aGUgb3B0aW9ucy5oZWFkZXJzIGFycmF5IE1VU1QgYmUgcHJlc2VudCwgb3IgdGhpc1xuICAgKiB3aWxsIHRocm93LlxuICAgKlxuICAgKiBZb3Ugc2hvdWxkbid0IG5lZWQgdG8gY2hlY2sgdGhlIHJldHVybiB0eXBlOyBpdCdzIGp1c3QgdGhlcmUgaWYgeW91IHdhbnRcbiAgICogdG8gYmUgcGVkYW50aWMuXG4gICAqXG4gICAqIFRoZSBvcHRpb25hbCBmbGFnIGluZGljYXRlcyB3aGV0aGVyIHBhcnNpbmcgc2hvdWxkIHVzZSBzdHJpY3QgZW5mb3JjZW1lbnRcbiAgICogb2YgdGhlIHZlcnNpb24gZHJhZnQtY2F2YWdlLWh0dHAtc2lnbmF0dXJlcy0wNCBvZiB0aGUgc3BlYyBvciBiZXlvbmQuXG4gICAqIFRoZSBkZWZhdWx0IGlzIHRvIGJlIGxvb3NlIGFuZCBzdXBwb3J0XG4gICAqIG9sZGVyIHZlcnNpb25zIGZvciBjb21wYXRpYmlsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBhbiBpbnN0YW5jZSBvZiBodHRwLkNsaWVudFJlcXVlc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHNpZ25pbmcgcGFyYW1ldGVycyBvYmplY3Q6XG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30ga2V5SWQgcmVxdWlyZWQuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30ga2V5IHJlcXVpcmVkIChlaXRoZXIgYSBQRU0gb3IgSE1BQyBrZXkpLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtBcnJheX0gaGVhZGVycyBvcHRpb25hbDsgZGVmYXVsdHMgdG8gWydkYXRlJ10uXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYWxnb3JpdGhtIG9wdGlvbmFsICh1bmxlc3Mga2V5IGlzIEhNQUMpO1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgaXMgdGhlIHNhbWUgYXMgdGhlIHNzaHBrIGRlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduaW5nIGFsZ29yaXRobSBmb3IgdGhlIHR5cGUgb2Yga2V5IGdpdmVuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gaHR0cFZlcnNpb24gb3B0aW9uYWw7IGRlZmF1bHRzIHRvICcxLjEnLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBzdHJpY3Qgb3B0aW9uYWw7IGRlZmF1bHRzIHRvICdmYWxzZScuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgQXV0aG9yaXphdGlvbiAoYW5kIG9wdGlvbmFsbHkgRGF0ZSkgd2VyZSBhZGRlZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgcGFyYW1ldGVyIHR5cGVzIChpbnB1dCkuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn0gaWYgYWxnb3JpdGhtIHdhcyBiYWQgb3IgaW5jb21wYXRpYmxlIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZ2l2ZW4ga2V5LlxuICAgKiBAdGhyb3dzIHtzc2hway5LZXlQYXJzZUVycm9yfSBpZiBrZXkgd2FzIGJhZC5cbiAgICogQHRocm93cyB7TWlzc2luZ0hlYWRlckVycm9yfSBpZiBhIGhlYWRlciB0byBiZSBzaWduZWQgd2FzIHNwZWNpZmllZCBidXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBzaWduUmVxdWVzdDogZnVuY3Rpb24gc2lnblJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucykge1xuICAgIGFzc2VydC5vYmplY3QocmVxdWVzdCwgJ3JlcXVlc3QnKTtcbiAgICBhc3NlcnQub2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdGlvbnMuYWxnb3JpdGhtLCAnb3B0aW9ucy5hbGdvcml0aG0nKTtcbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMua2V5SWQsICdvcHRpb25zLmtleUlkJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsQXJyYXlPZlN0cmluZyhvcHRpb25zLmhlYWRlcnMsICdvcHRpb25zLmhlYWRlcnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5odHRwVmVyc2lvbiwgJ29wdGlvbnMuaHR0cFZlcnNpb24nKTtcblxuICAgIGlmICghcmVxdWVzdC5nZXRIZWFkZXIoJ0RhdGUnKSlcbiAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdEYXRlJywganNwcmltLnJmYzExMjMobmV3IERhdGUoKSkpO1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gWydkYXRlJ107XG4gICAgaWYgKCFvcHRpb25zLmh0dHBWZXJzaW9uKVxuICAgICAgb3B0aW9ucy5odHRwVmVyc2lvbiA9ICcxLjEnO1xuXG4gICAgdmFyIGFsZyA9IFtdO1xuICAgIGlmIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xuICAgICAgYWxnID0gdmFsaWRhdGVBbGdvcml0aG0ob3B0aW9ucy5hbGdvcml0aG0pO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBzdHJpbmdUb1NpZ24gPSAnJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5oZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIChvcHRpb25zLmhlYWRlcnNbaV0pICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5oZWFkZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgU3RyaW5ncycpO1xuXG4gICAgICB2YXIgaCA9IG9wdGlvbnMuaGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoaCA9PT0gJ3JlcXVlc3QtbGluZScpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdlIGFsbG93IGhlYWRlcnMgZnJvbSB0aGUgb2xkZXIgc3BlYyBkcmFmdHMgaWYgc3RyaWN0IHBhcnNpbmcgaXNuJ3RcbiAgICAgICAgICAgKiBzcGVjaWZpZWQgaW4gb3B0aW9ucy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBzdHJpbmdUb1NpZ24gKz1cbiAgICAgICAgICAgIHJlcXVlc3QubWV0aG9kICsgJyAnICsgcmVxdWVzdC5wYXRoICsgJyBIVFRQLycgK1xuICAgICAgICAgICAgb3B0aW9ucy5odHRwVmVyc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBTdHJpY3QgcGFyc2luZyBkb2Vzbid0IGFsbG93IG9sZGVyIGRyYWZ0IGhlYWRlcnMuICovXG4gICAgICAgICAgdGhyb3cgKG5ldyBTdHJpY3RQYXJzaW5nRXJyb3IoJ3JlcXVlc3QtbGluZSBpcyBub3QgYSB2YWxpZCBoZWFkZXIgJyArXG4gICAgICAgICAgICAnd2l0aCBzdHJpY3QgcGFyc2luZyBlbmFibGVkLicpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoID09PSAnKHJlcXVlc3QtdGFyZ2V0KScpIHtcbiAgICAgICAgc3RyaW5nVG9TaWduICs9XG4gICAgICAgICAgJyhyZXF1ZXN0LXRhcmdldCk6ICcgKyByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpICsgJyAnICtcbiAgICAgICAgICByZXF1ZXN0LnBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSByZXF1ZXN0LmdldEhlYWRlcihoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcihoICsgJyB3YXMgbm90IGluIHRoZSByZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nVG9TaWduICs9IGggKyAnOiAnICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaSArIDEpIDwgb3B0aW9ucy5oZWFkZXJzLmxlbmd0aClcbiAgICAgICAgc3RyaW5nVG9TaWduICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8qIFRoaXMgaXMganVzdCBmb3IgdW5pdCB0ZXN0cy4gKi9cbiAgICBpZiAocmVxdWVzdC5oYXNPd25Qcm9wZXJ0eSgnX3N0cmluZ1RvU2lnbicpKSB7XG4gICAgICByZXF1ZXN0Ll9zdHJpbmdUb1NpZ24gPSBzdHJpbmdUb1NpZ247XG4gICAgfVxuXG4gICAgdmFyIHNpZ25hdHVyZTtcbiAgICBpZiAoYWxnWzBdID09PSAnaG1hYycpIHtcbiAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMua2V5KSAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmtleSkpXG4gICAgICAgIHRocm93IChuZXcgVHlwZUVycm9yKCdvcHRpb25zLmtleSBtdXN0IGJlIGEgc3RyaW5nIG9yIEJ1ZmZlcicpKTtcblxuICAgICAgdmFyIGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhhbGdbMV0udG9VcHBlckNhc2UoKSwgb3B0aW9ucy5rZXkpO1xuICAgICAgaG1hYy51cGRhdGUoc3RyaW5nVG9TaWduKTtcbiAgICAgIHNpZ25hdHVyZSA9IGhtYWMuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgICBpZiAodHlwZW9mIChrZXkpID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIoa2V5KSlcbiAgICAgICAga2V5ID0gc3NocGsucGFyc2VQcml2YXRlS2V5KG9wdGlvbnMua2V5KTtcblxuICAgICAgYXNzZXJ0Lm9rKHNzaHBrLlByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSwgWzEsIDJdKSxcbiAgICAgICAgJ29wdGlvbnMua2V5IG11c3QgYmUgYSBzc2hway5Qcml2YXRlS2V5Jyk7XG5cbiAgICAgIGlmICghUEtfQUxHT1Nba2V5LnR5cGVdKSB7XG4gICAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGtleS50eXBlLnRvVXBwZXJDYXNlKCkgKyAnIHR5cGUgJyArXG4gICAgICAgICAgJ2tleXMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGdbMF0gIT09IHVuZGVmaW5lZCAmJiBrZXkudHlwZSAhPT0gYWxnWzBdKSB7XG4gICAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKCdvcHRpb25zLmtleSBtdXN0IGJlIGEgJyArXG4gICAgICAgICAgYWxnWzBdLnRvVXBwZXJDYXNlKCkgKyAnIGtleSwgd2FzIGdpdmVuIGEgJyArXG4gICAgICAgICAga2V5LnR5cGUudG9VcHBlckNhc2UoKSArICcga2V5IGluc3RlYWQnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaWduZXIgPSBrZXkuY3JlYXRlU2lnbihhbGdbMV0pO1xuICAgICAgc2lnbmVyLnVwZGF0ZShzdHJpbmdUb1NpZ24pO1xuICAgICAgdmFyIHNpZ09iaiA9IHNpZ25lci5zaWduKCk7XG4gICAgICBpZiAoIUhBU0hfQUxHT1Nbc2lnT2JqLmhhc2hBbGdvcml0aG1dKSB7XG4gICAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKHNpZ09iai5oYXNoQWxnb3JpdGhtLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICcgaXMgbm90IGEgc3VwcG9ydGVkIGhhc2ggYWxnb3JpdGhtJykpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5hbGdvcml0aG0gPSBrZXkudHlwZSArICctJyArIHNpZ09iai5oYXNoQWxnb3JpdGhtO1xuICAgICAgc2lnbmF0dXJlID0gc2lnT2JqLnRvU3RyaW5nKCk7XG4gICAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwoc2lnbmF0dXJlLCAnJywgJ2VtcHR5IHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIH1cblxuICAgIHZhciBhdXRoekhlYWRlck5hbWUgPSBvcHRpb25zLmF1dGhvcml6YXRpb25IZWFkZXJOYW1lIHx8ICdBdXRob3JpemF0aW9uJztcblxuICAgIHJlcXVlc3Quc2V0SGVhZGVyKGF1dGh6SGVhZGVyTmFtZSwgc3ByaW50ZihBVVRIWl9GTVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMua2V5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuam9pbignICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUpKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImNyeXB0byIsImh0dHAiLCJ1dGlsIiwic3NocGsiLCJqc3ByaW0iLCJ1dGlscyIsInNwcmludGYiLCJmb3JtYXQiLCJIQVNIX0FMR09TIiwiUEtfQUxHT1MiLCJJbnZhbGlkQWxnb3JpdGhtRXJyb3IiLCJIdHRwU2lnbmF0dXJlRXJyb3IiLCJ2YWxpZGF0ZUFsZ29yaXRobSIsIkFVVEhaX0ZNVCIsIk1pc3NpbmdIZWFkZXJFcnJvciIsIm1lc3NhZ2UiLCJjYWxsIiwiaW5oZXJpdHMiLCJTdHJpY3RQYXJzaW5nRXJyb3IiLCJSZXF1ZXN0U2lnbmVyIiwib3B0aW9ucyIsIm9iamVjdCIsImFsZyIsImFsZ29yaXRobSIsInVuZGVmaW5lZCIsInN0cmluZyIsInJzX2FsZyIsInNpZ24iLCJmdW5jIiwicnNfc2lnbkZ1bmMiLCJrZXkiLCJrZXlJZCIsInJzX2tleUlkIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJUeXBlRXJyb3IiLCJyc19zaWduZXIiLCJjcmVhdGVIbWFjIiwidG9VcHBlckNhc2UiLCJkaWdlc3QiLCJoYXNoQWxnb3JpdGhtIiwidG9TdHJpbmciLCJwYXJzZVByaXZhdGVLZXkiLCJvayIsIlByaXZhdGVLZXkiLCJpc1ByaXZhdGVLZXkiLCJyc19rZXkiLCJ0eXBlIiwiY3JlYXRlU2lnbiIsInJzX2hlYWRlcnMiLCJyc19saW5lcyIsInByb3RvdHlwZSIsIndyaXRlSGVhZGVyIiwiaGVhZGVyIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJsaW5lIiwibGVuZ3RoIiwidXBkYXRlIiwid3JpdGVEYXRlSGVhZGVyIiwicmZjMTEyMyIsIkRhdGUiLCJ3cml0ZVRhcmdldCIsIm1ldGhvZCIsInBhdGgiLCJjYiIsIkVycm9yIiwiYXV0aHoiLCJkYXRhIiwiam9pbiIsInNlbGYiLCJlcnIiLCJzaWciLCJzaWduYXR1cmUiLCJlIiwic2lnT2JqIiwibW9kdWxlIiwiZXhwb3J0cyIsImlzU2lnbmVyIiwib2JqIiwiY3JlYXRlU2lnbmVyIiwic2lnblJlcXVlc3QiLCJyZXF1ZXN0Iiwib3B0aW9uYWxTdHJpbmciLCJvcHRpb25hbEFycmF5T2ZTdHJpbmciLCJoZWFkZXJzIiwiaHR0cFZlcnNpb24iLCJnZXRIZWFkZXIiLCJzZXRIZWFkZXIiLCJpIiwic3RyaW5nVG9TaWduIiwiaCIsInN0cmljdCIsImhhc093blByb3BlcnR5IiwiX3N0cmluZ1RvU2lnbiIsImhtYWMiLCJzaWduZXIiLCJub3RTdHJpY3RFcXVhbCIsImF1dGh6SGVhZGVyTmFtZSIsImF1dGhvcml6YXRpb25IZWFkZXJOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/signer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/http-signature/lib/utils.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(rsc)/./node_modules/sshpk/lib/index.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar HASH_ALGOS = {\n    \"sha1\": true,\n    \"sha256\": true,\n    \"sha512\": true\n};\nvar PK_ALGOS = {\n    \"rsa\": true,\n    \"dsa\": true,\n    \"ecdsa\": true\n};\nfunction HttpSignatureError(message, caller) {\n    if (Error.captureStackTrace) Error.captureStackTrace(this, caller || HttpSignatureError);\n    this.message = message;\n    this.name = caller.name;\n}\nutil.inherits(HttpSignatureError, Error);\nfunction InvalidAlgorithmError(message) {\n    HttpSignatureError.call(this, message, InvalidAlgorithmError);\n}\nutil.inherits(InvalidAlgorithmError, HttpSignatureError);\nfunction validateAlgorithm(algorithm) {\n    var alg = algorithm.toLowerCase().split(\"-\");\n    if (alg.length !== 2) {\n        throw new InvalidAlgorithmError(alg[0].toUpperCase() + \" is not a \" + \"valid algorithm\");\n    }\n    if (alg[0] !== \"hmac\" && !PK_ALGOS[alg[0]]) {\n        throw new InvalidAlgorithmError(alg[0].toUpperCase() + \" type keys \" + \"are not supported\");\n    }\n    if (!HASH_ALGOS[alg[1]]) {\n        throw new InvalidAlgorithmError(alg[1].toUpperCase() + \" is not a \" + \"supported hash algorithm\");\n    }\n    return alg;\n}\n///--- API\nmodule.exports = {\n    HASH_ALGOS: HASH_ALGOS,\n    PK_ALGOS: PK_ALGOS,\n    HttpSignatureError: HttpSignatureError,\n    InvalidAlgorithmError: InvalidAlgorithmError,\n    validateAlgorithm: validateAlgorithm,\n    /**\n   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.\n   *\n   * The intent of this module is to interoperate with OpenSSL only,\n   * specifically the node crypto module's `verify` method.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} PEM encoded form of the RSA public key.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} on invalid ssh key formatted data.\n   */ sshKeyToPEM: function sshKeyToPEM(key) {\n        assert.string(key, \"ssh_key\");\n        var k = sshpk.parseKey(key, \"ssh\");\n        return k.toString(\"pem\");\n    },\n    /**\n   * Generates an OpenSSH fingerprint from an ssh public key.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} key fingerprint.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} if what you passed doesn't look like an ssh public key.\n   */ fingerprint: function fingerprint(key) {\n        assert.string(key, \"ssh_key\");\n        var k = sshpk.parseKey(key, \"ssh\");\n        return k.fingerprint(\"md5\").toString(\"hex\");\n    },\n    /**\n   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)\n   *\n   * The reverse of the above function.\n   */ pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {\n        assert.equal(\"string\", typeof pem, \"typeof pem\");\n        var k = sshpk.parseKey(pem, \"pem\");\n        k.comment = comment;\n        return k.toString(\"ssh\");\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9EQUFvRDs7QUFFcEQsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUM7QUFFbkIsSUFBSUcsYUFBYTtJQUNmLFFBQVE7SUFDUixVQUFVO0lBQ1YsVUFBVTtBQUNaO0FBRUEsSUFBSUMsV0FBVztJQUNiLE9BQU87SUFDUCxPQUFPO0lBQ1AsU0FBUztBQUNYO0FBRUEsU0FBU0MsbUJBQW1CQyxPQUFPLEVBQUVDLE1BQU07SUFDekMsSUFBSUMsTUFBTUMsaUJBQWlCLEVBQ3pCRCxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVGLFVBQVVGO0lBRTFDLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNmLElBQUksQ0FBQ0ksSUFBSSxHQUFHSCxPQUFPRyxJQUFJO0FBQ3pCO0FBQ0FSLEtBQUtTLFFBQVEsQ0FBQ04sb0JBQW9CRztBQUVsQyxTQUFTSSxzQkFBc0JOLE9BQU87SUFDcENELG1CQUFtQlEsSUFBSSxDQUFDLElBQUksRUFBRVAsU0FBU007QUFDekM7QUFDQVYsS0FBS1MsUUFBUSxDQUFDQyx1QkFBdUJQO0FBRXJDLFNBQVNTLGtCQUFrQkMsU0FBUztJQUNsQyxJQUFJQyxNQUFNRCxVQUFVRSxXQUFXLEdBQUdDLEtBQUssQ0FBQztJQUV4QyxJQUFJRixJQUFJRyxNQUFNLEtBQUssR0FBRztRQUNwQixNQUFPLElBQUlQLHNCQUFzQkksR0FBRyxDQUFDLEVBQUUsQ0FBQ0ksV0FBVyxLQUFLLGVBQ3REO0lBQ0o7SUFFQSxJQUFJSixHQUFHLENBQUMsRUFBRSxLQUFLLFVBQVUsQ0FBQ1osUUFBUSxDQUFDWSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDMUMsTUFBTyxJQUFJSixzQkFBc0JJLEdBQUcsQ0FBQyxFQUFFLENBQUNJLFdBQVcsS0FBSyxnQkFDdEQ7SUFDSjtJQUVBLElBQUksQ0FBQ2pCLFVBQVUsQ0FBQ2EsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ3ZCLE1BQU8sSUFBSUosc0JBQXNCSSxHQUFHLENBQUMsRUFBRSxDQUFDSSxXQUFXLEtBQUssZUFDdEQ7SUFDSjtJQUVBLE9BQVFKO0FBQ1Y7QUFFQSxVQUFVO0FBRVZLLE9BQU9DLE9BQU8sR0FBRztJQUVmbkIsWUFBWUE7SUFDWkMsVUFBVUE7SUFFVkMsb0JBQW9CQTtJQUNwQk8sdUJBQXVCQTtJQUV2QkUsbUJBQW1CQTtJQUVuQjs7Ozs7Ozs7OztHQVVDLEdBQ0RTLGFBQWEsU0FBU0EsWUFBWUMsR0FBRztRQUNuQ3pCLE9BQU8wQixNQUFNLENBQUNELEtBQUs7UUFFbkIsSUFBSUUsSUFBSXpCLE1BQU0wQixRQUFRLENBQUNILEtBQUs7UUFDNUIsT0FBUUUsRUFBRUUsUUFBUSxDQUFDO0lBQ3JCO0lBR0E7Ozs7Ozs7R0FPQyxHQUNEQyxhQUFhLFNBQVNBLFlBQVlMLEdBQUc7UUFDbkN6QixPQUFPMEIsTUFBTSxDQUFDRCxLQUFLO1FBRW5CLElBQUlFLElBQUl6QixNQUFNMEIsUUFBUSxDQUFDSCxLQUFLO1FBQzVCLE9BQVFFLEVBQUVHLFdBQVcsQ0FBQyxPQUFPRCxRQUFRLENBQUM7SUFDeEM7SUFFQTs7OztHQUlDLEdBQ0RFLGdCQUFnQixTQUFTQSxlQUFlQyxHQUFHLEVBQUVDLE9BQU87UUFDbERqQyxPQUFPa0MsS0FBSyxDQUFDLFVBQVUsT0FBUUYsS0FBTTtRQUVyQyxJQUFJTCxJQUFJekIsTUFBTTBCLFFBQVEsQ0FBQ0ksS0FBSztRQUM1QkwsRUFBRU0sT0FBTyxHQUFHQTtRQUNaLE9BQVFOLEVBQUVFLFFBQVEsQ0FBQztJQUNyQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2ljZS1hcHAvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3V0aWxzLmpzP2I2YjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTIgSm95ZW50LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBzc2hwayA9IHJlcXVpcmUoJ3NzaHBrJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIEhBU0hfQUxHT1MgPSB7XG4gICdzaGExJzogdHJ1ZSxcbiAgJ3NoYTI1Nic6IHRydWUsXG4gICdzaGE1MTInOiB0cnVlXG59O1xuXG52YXIgUEtfQUxHT1MgPSB7XG4gICdyc2EnOiB0cnVlLFxuICAnZHNhJzogdHJ1ZSxcbiAgJ2VjZHNhJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gSHR0cFNpZ25hdHVyZUVycm9yKG1lc3NhZ2UsIGNhbGxlcikge1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY2FsbGVyIHx8IEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gY2FsbGVyLm5hbWU7XG59XG51dGlsLmluaGVyaXRzKEh0dHBTaWduYXR1cmVFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBJbnZhbGlkQWxnb3JpdGhtRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhJbnZhbGlkQWxnb3JpdGhtRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQWxnb3JpdGhtKGFsZ29yaXRobSkge1xuICB2YXIgYWxnID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcblxuICBpZiAoYWxnLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZ1swXS50b1VwcGVyQ2FzZSgpICsgJyBpcyBub3QgYSAnICtcbiAgICAgICd2YWxpZCBhbGdvcml0aG0nKSk7XG4gIH1cblxuICBpZiAoYWxnWzBdICE9PSAnaG1hYycgJiYgIVBLX0FMR09TW2FsZ1swXV0pIHtcbiAgICB0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGdbMF0udG9VcHBlckNhc2UoKSArICcgdHlwZSBrZXlzICcgK1xuICAgICAgJ2FyZSBub3Qgc3VwcG9ydGVkJykpO1xuICB9XG5cbiAgaWYgKCFIQVNIX0FMR09TW2FsZ1sxXV0pIHtcbiAgICB0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGdbMV0udG9VcHBlckNhc2UoKSArICcgaXMgbm90IGEgJyArXG4gICAgICAnc3VwcG9ydGVkIGhhc2ggYWxnb3JpdGhtJykpO1xuICB9XG5cbiAgcmV0dXJuIChhbGcpO1xufVxuXG4vLy8tLS0gQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIEhBU0hfQUxHT1M6IEhBU0hfQUxHT1MsXG4gIFBLX0FMR09TOiBQS19BTEdPUyxcblxuICBIdHRwU2lnbmF0dXJlRXJyb3I6IEh0dHBTaWduYXR1cmVFcnJvcixcbiAgSW52YWxpZEFsZ29yaXRobUVycm9yOiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IsXG5cbiAgdmFsaWRhdGVBbGdvcml0aG06IHZhbGlkYXRlQWxnb3JpdGhtLFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NIIHB1YmxpYyBrZXkgKHJzYSBvbmx5KSB0byBhIFBLQ1MjOCBQRU0gZmlsZS5cbiAgICpcbiAgICogVGhlIGludGVudCBvZiB0aGlzIG1vZHVsZSBpcyB0byBpbnRlcm9wZXJhdGUgd2l0aCBPcGVuU1NMIG9ubHksXG4gICAqIHNwZWNpZmljYWxseSB0aGUgbm9kZSBjcnlwdG8gbW9kdWxlJ3MgYHZlcmlmeWAgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGFuIE9wZW5TU0ggcHVibGljIGtleS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBQRU0gZW5jb2RlZCBmb3JtIG9mIHRoZSBSU0EgcHVibGljIGtleS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBvbiBpbnZhbGlkIHNzaCBrZXkgZm9ybWF0dGVkIGRhdGEuXG4gICAqL1xuICBzc2hLZXlUb1BFTTogZnVuY3Rpb24gc3NoS2V5VG9QRU0oa2V5KSB7XG4gICAgYXNzZXJ0LnN0cmluZyhrZXksICdzc2hfa2V5Jyk7XG5cbiAgICB2YXIgayA9IHNzaHBrLnBhcnNlS2V5KGtleSwgJ3NzaCcpO1xuICAgIHJldHVybiAoay50b1N0cmluZygncGVtJykpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBPcGVuU1NIIGZpbmdlcnByaW50IGZyb20gYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGtleSBmaW5nZXJwcmludC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB3aGF0IHlvdSBwYXNzZWQgZG9lc24ndCBsb29rIGxpa2UgYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqL1xuICBmaW5nZXJwcmludDogZnVuY3Rpb24gZmluZ2VycHJpbnQoa2V5KSB7XG4gICAgYXNzZXJ0LnN0cmluZyhrZXksICdzc2hfa2V5Jyk7XG5cbiAgICB2YXIgayA9IHNzaHBrLnBhcnNlS2V5KGtleSwgJ3NzaCcpO1xuICAgIHJldHVybiAoay5maW5nZXJwcmludCgnbWQ1JykudG9TdHJpbmcoJ2hleCcpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBQS0dDUyM4IFBFTSBmaWxlIHRvIGFuIE9wZW5TU0ggcHVibGljIGtleSAocnNhKVxuICAgKlxuICAgKiBUaGUgcmV2ZXJzZSBvZiB0aGUgYWJvdmUgZnVuY3Rpb24uXG4gICAqL1xuICBwZW1Ub1JzYVNTSEtleTogZnVuY3Rpb24gcGVtVG9Sc2FTU0hLZXkocGVtLCBjb21tZW50KSB7XG4gICAgYXNzZXJ0LmVxdWFsKCdzdHJpbmcnLCB0eXBlb2YgKHBlbSksICd0eXBlb2YgcGVtJyk7XG5cbiAgICB2YXIgayA9IHNzaHBrLnBhcnNlS2V5KHBlbSwgJ3BlbScpO1xuICAgIGsuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIChrLnRvU3RyaW5nKCdzc2gnKSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsInNzaHBrIiwidXRpbCIsIkhBU0hfQUxHT1MiLCJQS19BTEdPUyIsIkh0dHBTaWduYXR1cmVFcnJvciIsIm1lc3NhZ2UiLCJjYWxsZXIiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwibmFtZSIsImluaGVyaXRzIiwiSW52YWxpZEFsZ29yaXRobUVycm9yIiwiY2FsbCIsInZhbGlkYXRlQWxnb3JpdGhtIiwiYWxnb3JpdGhtIiwiYWxnIiwidG9Mb3dlckNhc2UiLCJzcGxpdCIsImxlbmd0aCIsInRvVXBwZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyIsInNzaEtleVRvUEVNIiwia2V5Iiwic3RyaW5nIiwiayIsInBhcnNlS2V5IiwidG9TdHJpbmciLCJmaW5nZXJwcmludCIsInBlbVRvUnNhU1NIS2V5IiwicGVtIiwiY29tbWVudCIsImVxdWFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/verify.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/verify.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(rsc)/./node_modules/sshpk/lib/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/http-signature/lib/utils.js\");\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar validateAlgorithm = utils.validateAlgorithm;\n///--- Exported API\nmodule.exports = {\n    /**\n   * Verify RSA/DSA signature against public key.  You are expected to pass in\n   * an object that was returned from `parse()`.\n   *\n   * @param {Object} parsedSignature the object you got from `parse`.\n   * @param {String} pubkey RSA/DSA private key PEM.\n   * @return {Boolean} true if valid, false otherwise.\n   * @throws {TypeError} if you pass in bad arguments.\n   * @throws {InvalidAlgorithmError}\n   */ verifySignature: function verifySignature(parsedSignature, pubkey) {\n        assert.object(parsedSignature, \"parsedSignature\");\n        if (typeof pubkey === \"string\" || Buffer.isBuffer(pubkey)) pubkey = sshpk.parseKey(pubkey);\n        assert.ok(sshpk.Key.isKey(pubkey, [\n            1,\n            1\n        ]), \"pubkey must be a sshpk.Key\");\n        var alg = validateAlgorithm(parsedSignature.algorithm);\n        if (alg[0] === \"hmac\" || alg[0] !== pubkey.type) return false;\n        var v = pubkey.createVerify(alg[1]);\n        v.update(parsedSignature.signingString);\n        return v.verify(parsedSignature.params.signature, \"base64\");\n    },\n    /**\n   * Verify HMAC against shared secret.  You are expected to pass in an object\n   * that was returned from `parse()`.\n   *\n   * @param {Object} parsedSignature the object you got from `parse`.\n   * @param {String} secret HMAC shared secret.\n   * @return {Boolean} true if valid, false otherwise.\n   * @throws {TypeError} if you pass in bad arguments.\n   * @throws {InvalidAlgorithmError}\n   */ verifyHMAC: function verifyHMAC(parsedSignature, secret) {\n        assert.object(parsedSignature, \"parsedHMAC\");\n        assert.string(secret, \"secret\");\n        var alg = validateAlgorithm(parsedSignature.algorithm);\n        if (alg[0] !== \"hmac\") return false;\n        var hashAlg = alg[1].toUpperCase();\n        var hmac = crypto.createHmac(hashAlg, secret);\n        hmac.update(parsedSignature.signingString);\n        /*\n     * Now double-hash to avoid leaking timing information - there's\n     * no easy constant-time compare in JS, so we use this approach\n     * instead. See for more info:\n     * https://www.isecpartners.com/blog/2011/february/double-hmac-\n     * verification.aspx\n     */ var h1 = crypto.createHmac(hashAlg, secret);\n        h1.update(hmac.digest());\n        h1 = h1.digest();\n        var h2 = crypto.createHmac(hashAlg, secret);\n        h2.update(new Buffer(parsedSignature.params.signature, \"base64\"));\n        h2 = h2.digest();\n        /* Node 0.8 returns strings from .digest(). */ if (typeof h1 === \"string\") return h1 === h2;\n        /* And node 0.10 lacks the .equals() method on Buffers. */ if (Buffer.isBuffer(h1) && !h1.equals) return h1.toString(\"binary\") === h2.toString(\"binary\");\n        return h1.equals(h2);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3ZlcmlmeS5qcyIsIm1hcHBpbmdzIjoiQUFBQSw4QkFBOEI7O0FBRTlCLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDO0FBRXBCLElBQUlJLGFBQWFELE1BQU1DLFVBQVU7QUFDakMsSUFBSUMsV0FBV0YsTUFBTUUsUUFBUTtBQUM3QixJQUFJQyx3QkFBd0JILE1BQU1HLHFCQUFxQjtBQUN2RCxJQUFJQyxxQkFBcUJKLE1BQU1JLGtCQUFrQjtBQUNqRCxJQUFJQyxvQkFBb0JMLE1BQU1LLGlCQUFpQjtBQUUvQyxtQkFBbUI7QUFFbkJDLE9BQU9DLE9BQU8sR0FBRztJQUNmOzs7Ozs7Ozs7R0FTQyxHQUNEQyxpQkFBaUIsU0FBU0EsZ0JBQWdCQyxlQUFlLEVBQUVDLE1BQU07UUFDL0RkLE9BQU9lLE1BQU0sQ0FBQ0YsaUJBQWlCO1FBQy9CLElBQUksT0FBUUMsV0FBWSxZQUFZRSxPQUFPQyxRQUFRLENBQUNILFNBQ2xEQSxTQUFTWCxNQUFNZSxRQUFRLENBQUNKO1FBQzFCZCxPQUFPbUIsRUFBRSxDQUFDaEIsTUFBTWlCLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDUCxRQUFRO1lBQUM7WUFBRztTQUFFLEdBQUc7UUFFM0MsSUFBSVEsTUFBTWIsa0JBQWtCSSxnQkFBZ0JVLFNBQVM7UUFDckQsSUFBSUQsR0FBRyxDQUFDLEVBQUUsS0FBSyxVQUFVQSxHQUFHLENBQUMsRUFBRSxLQUFLUixPQUFPVSxJQUFJLEVBQzdDLE9BQVE7UUFFVixJQUFJQyxJQUFJWCxPQUFPWSxZQUFZLENBQUNKLEdBQUcsQ0FBQyxFQUFFO1FBQ2xDRyxFQUFFRSxNQUFNLENBQUNkLGdCQUFnQmUsYUFBYTtRQUN0QyxPQUFRSCxFQUFFSSxNQUFNLENBQUNoQixnQkFBZ0JpQixNQUFNLENBQUNDLFNBQVMsRUFBRTtJQUNyRDtJQUVBOzs7Ozs7Ozs7R0FTQyxHQUNEQyxZQUFZLFNBQVNBLFdBQVduQixlQUFlLEVBQUVvQixNQUFNO1FBQ3JEakMsT0FBT2UsTUFBTSxDQUFDRixpQkFBaUI7UUFDL0JiLE9BQU9rQyxNQUFNLENBQUNELFFBQVE7UUFFdEIsSUFBSVgsTUFBTWIsa0JBQWtCSSxnQkFBZ0JVLFNBQVM7UUFDckQsSUFBSUQsR0FBRyxDQUFDLEVBQUUsS0FBSyxRQUNiLE9BQVE7UUFFVixJQUFJYSxVQUFVYixHQUFHLENBQUMsRUFBRSxDQUFDYyxXQUFXO1FBRWhDLElBQUlDLE9BQU9uQyxPQUFPb0MsVUFBVSxDQUFDSCxTQUFTRjtRQUN0Q0ksS0FBS1YsTUFBTSxDQUFDZCxnQkFBZ0JlLGFBQWE7UUFFekM7Ozs7OztLQU1DLEdBQ0QsSUFBSVcsS0FBS3JDLE9BQU9vQyxVQUFVLENBQUNILFNBQVNGO1FBQ3BDTSxHQUFHWixNQUFNLENBQUNVLEtBQUtHLE1BQU07UUFDckJELEtBQUtBLEdBQUdDLE1BQU07UUFDZCxJQUFJQyxLQUFLdkMsT0FBT29DLFVBQVUsQ0FBQ0gsU0FBU0Y7UUFDcENRLEdBQUdkLE1BQU0sQ0FBQyxJQUFJWCxPQUFPSCxnQkFBZ0JpQixNQUFNLENBQUNDLFNBQVMsRUFBRTtRQUN2RFUsS0FBS0EsR0FBR0QsTUFBTTtRQUVkLDRDQUE0QyxHQUM1QyxJQUFJLE9BQVFELE9BQVEsVUFDbEIsT0FBUUEsT0FBT0U7UUFDakIsd0RBQXdELEdBQ3hELElBQUl6QixPQUFPQyxRQUFRLENBQUNzQixPQUFPLENBQUNBLEdBQUdHLE1BQU0sRUFDbkMsT0FBUUgsR0FBR0ksUUFBUSxDQUFDLGNBQWNGLEdBQUdFLFFBQVEsQ0FBQztRQUVoRCxPQUFRSixHQUFHRyxNQUFNLENBQUNEO0lBQ3BCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnZvaWNlLWFwcC8uL25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvdmVyaWZ5LmpzP2M3ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHNzaHBrID0gcmVxdWlyZSgnc3NocGsnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIEhBU0hfQUxHT1MgPSB1dGlscy5IQVNIX0FMR09TO1xudmFyIFBLX0FMR09TID0gdXRpbHMuUEtfQUxHT1M7XG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gdXRpbHMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xudmFyIEh0dHBTaWduYXR1cmVFcnJvciA9IHV0aWxzLkh0dHBTaWduYXR1cmVFcnJvcjtcbnZhciB2YWxpZGF0ZUFsZ29yaXRobSA9IHV0aWxzLnZhbGlkYXRlQWxnb3JpdGhtO1xuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVmVyaWZ5IFJTQS9EU0Egc2lnbmF0dXJlIGFnYWluc3QgcHVibGljIGtleS4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcGFzcyBpblxuICAgKiBhbiBvYmplY3QgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSBgcGFyc2UoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWRTaWduYXR1cmUgdGhlIG9iamVjdCB5b3UgZ290IGZyb20gYHBhcnNlYC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YmtleSBSU0EvRFNBIHByaXZhdGUga2V5IFBFTS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn1cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZTogZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHBhcnNlZFNpZ25hdHVyZSwgcHVia2V5KSB7XG4gICAgYXNzZXJ0Lm9iamVjdChwYXJzZWRTaWduYXR1cmUsICdwYXJzZWRTaWduYXR1cmUnKTtcbiAgICBpZiAodHlwZW9mIChwdWJrZXkpID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIocHVia2V5KSlcbiAgICAgIHB1YmtleSA9IHNzaHBrLnBhcnNlS2V5KHB1YmtleSk7XG4gICAgYXNzZXJ0Lm9rKHNzaHBrLktleS5pc0tleShwdWJrZXksIFsxLCAxXSksICdwdWJrZXkgbXVzdCBiZSBhIHNzaHBrLktleScpO1xuXG4gICAgdmFyIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0pO1xuICAgIGlmIChhbGdbMF0gPT09ICdobWFjJyB8fCBhbGdbMF0gIT09IHB1YmtleS50eXBlKVxuICAgICAgcmV0dXJuIChmYWxzZSk7XG5cbiAgICB2YXIgdiA9IHB1YmtleS5jcmVhdGVWZXJpZnkoYWxnWzFdKTtcbiAgICB2LnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG4gICAgcmV0dXJuICh2LnZlcmlmeShwYXJzZWRTaWduYXR1cmUucGFyYW1zLnNpZ25hdHVyZSwgJ2Jhc2U2NCcpKTtcbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IEhNQUMgYWdhaW5zdCBzaGFyZWQgc2VjcmV0LiAgWW91IGFyZSBleHBlY3RlZCB0byBwYXNzIGluIGFuIG9iamVjdFxuICAgKiB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIGBwYXJzZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZFNpZ25hdHVyZSB0aGUgb2JqZWN0IHlvdSBnb3QgZnJvbSBgcGFyc2VgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VjcmV0IEhNQUMgc2hhcmVkIHNlY3JldC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn1cbiAgICovXG4gIHZlcmlmeUhNQUM6IGZ1bmN0aW9uIHZlcmlmeUhNQUMocGFyc2VkU2lnbmF0dXJlLCBzZWNyZXQpIHtcbiAgICBhc3NlcnQub2JqZWN0KHBhcnNlZFNpZ25hdHVyZSwgJ3BhcnNlZEhNQUMnKTtcbiAgICBhc3NlcnQuc3RyaW5nKHNlY3JldCwgJ3NlY3JldCcpO1xuXG4gICAgdmFyIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0pO1xuICAgIGlmIChhbGdbMF0gIT09ICdobWFjJylcbiAgICAgIHJldHVybiAoZmFsc2UpO1xuXG4gICAgdmFyIGhhc2hBbGcgPSBhbGdbMV0udG9VcHBlckNhc2UoKTtcblxuICAgIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgc2VjcmV0KTtcbiAgICBobWFjLnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG5cbiAgICAvKlxuICAgICAqIE5vdyBkb3VibGUtaGFzaCB0byBhdm9pZCBsZWFraW5nIHRpbWluZyBpbmZvcm1hdGlvbiAtIHRoZXJlJ3NcbiAgICAgKiBubyBlYXN5IGNvbnN0YW50LXRpbWUgY29tcGFyZSBpbiBKUywgc28gd2UgdXNlIHRoaXMgYXBwcm9hY2hcbiAgICAgKiBpbnN0ZWFkLiBTZWUgZm9yIG1vcmUgaW5mbzpcbiAgICAgKiBodHRwczovL3d3dy5pc2VjcGFydG5lcnMuY29tL2Jsb2cvMjAxMS9mZWJydWFyeS9kb3VibGUtaG1hYy1cbiAgICAgKiB2ZXJpZmljYXRpb24uYXNweFxuICAgICAqL1xuICAgIHZhciBoMSA9IGNyeXB0by5jcmVhdGVIbWFjKGhhc2hBbGcsIHNlY3JldCk7XG4gICAgaDEudXBkYXRlKGhtYWMuZGlnZXN0KCkpO1xuICAgIGgxID0gaDEuZGlnZXN0KCk7XG4gICAgdmFyIGgyID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgc2VjcmV0KTtcbiAgICBoMi51cGRhdGUobmV3IEJ1ZmZlcihwYXJzZWRTaWduYXR1cmUucGFyYW1zLnNpZ25hdHVyZSwgJ2Jhc2U2NCcpKTtcbiAgICBoMiA9IGgyLmRpZ2VzdCgpO1xuXG4gICAgLyogTm9kZSAwLjggcmV0dXJucyBzdHJpbmdzIGZyb20gLmRpZ2VzdCgpLiAqL1xuICAgIGlmICh0eXBlb2YgKGgxKSA9PT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gKGgxID09PSBoMik7XG4gICAgLyogQW5kIG5vZGUgMC4xMCBsYWNrcyB0aGUgLmVxdWFscygpIG1ldGhvZCBvbiBCdWZmZXJzLiAqL1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaDEpICYmICFoMS5lcXVhbHMpXG4gICAgICByZXR1cm4gKGgxLnRvU3RyaW5nKCdiaW5hcnknKSA9PT0gaDIudG9TdHJpbmcoJ2JpbmFyeScpKTtcblxuICAgIHJldHVybiAoaDEuZXF1YWxzKGgyKSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImNyeXB0byIsInNzaHBrIiwidXRpbHMiLCJIQVNIX0FMR09TIiwiUEtfQUxHT1MiLCJJbnZhbGlkQWxnb3JpdGhtRXJyb3IiLCJIdHRwU2lnbmF0dXJlRXJyb3IiLCJ2YWxpZGF0ZUFsZ29yaXRobSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ2ZXJpZnlTaWduYXR1cmUiLCJwYXJzZWRTaWduYXR1cmUiLCJwdWJrZXkiLCJvYmplY3QiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInBhcnNlS2V5Iiwib2siLCJLZXkiLCJpc0tleSIsImFsZyIsImFsZ29yaXRobSIsInR5cGUiLCJ2IiwiY3JlYXRlVmVyaWZ5IiwidXBkYXRlIiwic2lnbmluZ1N0cmluZyIsInZlcmlmeSIsInBhcmFtcyIsInNpZ25hdHVyZSIsInZlcmlmeUhNQUMiLCJzZWNyZXQiLCJzdHJpbmciLCJoYXNoQWxnIiwidG9VcHBlckNhc2UiLCJobWFjIiwiY3JlYXRlSG1hYyIsImgxIiwiZGlnZXN0IiwiaDIiLCJlcXVhbHMiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/verify.js\n");

/***/ })

};
;