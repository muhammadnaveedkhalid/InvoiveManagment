/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uri-js";
exports.ids = ["vendor-chunks/uri-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    function merge() {\n        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++){\n            sets[_key] = arguments[_key];\n        }\n        if (sets.length > 1) {\n            sets[0] = sets[0].slice(0, -1);\n            var xl = sets.length - 1;\n            for(var x = 1; x < xl; ++x){\n                sets[x] = sets[x].slice(1, -1);\n            }\n            sets[xl] = sets[xl].slice(1);\n            return sets.join(\"\");\n        } else {\n            return sets[0];\n        }\n    }\n    function subexp(str) {\n        return \"(?:\" + str + \")\";\n    }\n    function typeOf(o) {\n        return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n    }\n    function toUpperCase(str) {\n        return str.toUpperCase();\n    }\n    function toArray(obj) {\n        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [\n            obj\n        ] : Array.prototype.slice.call(obj) : [];\n    }\n    function assign(target, source) {\n        var obj = target;\n        if (source) {\n            for(var key in source){\n                obj[key] = source[key];\n            }\n        }\n        return obj;\n    }\n    function buildExps(isIRI) {\n        var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), //case-insensitive\n        LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), //expanded\n        GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", //subset, excludes bidi control characters\n        IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", //subset\n        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$), //relaxed parsing rules\n        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n        IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n        IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"), //[ *6( h16 \":\" ) h16 ] \"::\"\n        IPV6ADDRESS$ = subexp([\n            IPV6ADDRESS1$,\n            IPV6ADDRESS2$,\n            IPV6ADDRESS3$,\n            IPV6ADDRESS4$,\n            IPV6ADDRESS5$,\n            IPV6ADDRESS6$,\n            IPV6ADDRESS7$,\n            IPV6ADDRESS8$,\n            IPV6ADDRESS9$\n        ].join(\"|\")), ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"), //RFC 6874\n        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$), //RFC 6874\n        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$), //RFC 6874, with relaxed parsing rules\n        IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), //RFC 6874\n        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), //simplified\n        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified\n        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified\n        PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n        return {\n            NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n            NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n            NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n            ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n            OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n            PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n            IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n            IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n        };\n    }\n    var URI_PROTOCOL = buildExps(false);\n    var IRI_PROTOCOL = buildExps(true);\n    var slicedToArray = function() {\n        function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n            try {\n                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                    _arr.push(_s.value);\n                    if (i && _arr.length === i) break;\n                }\n            } catch (err) {\n                _d = true;\n                _e = err;\n            } finally{\n                try {\n                    if (!_n && _i[\"return\"]) _i[\"return\"]();\n                } finally{\n                    if (_d) throw _e;\n                }\n            }\n            return _arr;\n        }\n        return function(arr, i) {\n            if (Array.isArray(arr)) {\n                return arr;\n            } else if (Symbol.iterator in Object(arr)) {\n                return sliceIterator(arr, i);\n            } else {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n            }\n        };\n    }();\n    var toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];\n            return arr2;\n        } else {\n            return Array.from(arr);\n        }\n    };\n    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n    /** Bootstring parameters */ var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128; // 0x80\n    var delimiter = \"-\"; // '\\x2D'\n    /** Regular expressions */ var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n    /** Error messages */ var errors = {\n        \"overflow\": \"Overflow: input needs wider integers to process\",\n        \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n        \"invalid-input\": \"Invalid input\"\n    };\n    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    /*--------------------------------------------------------------------------*/ /**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */ function error$1(type) {\n        throw new RangeError(errors[type]);\n    }\n    /**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */ function map(array, fn) {\n        var result = [];\n        var length = array.length;\n        while(length--){\n            result[length] = fn(array[length]);\n        }\n        return result;\n    }\n    /**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */ function mapDomain(string, fn) {\n        var parts = string.split(\"@\");\n        var result = \"\";\n        if (parts.length > 1) {\n            // In email addresses, only the domain name should be punycoded. Leave\n            // the local part (i.e. everything up to `@`) intact.\n            result = parts[0] + \"@\";\n            string = parts[1];\n        }\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, \".\");\n        var labels = string.split(\".\");\n        var encoded = map(labels, fn).join(\".\");\n        return result + encoded;\n    }\n    /**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */ function ucs2decode(string) {\n        var output = [];\n        var counter = 0;\n        var length = string.length;\n        while(counter < length){\n            var value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // It's a high surrogate, and there is a next character.\n                var extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {\n                    // Low surrogate.\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                    // It's an unmatched surrogate; only append this code unit, in case the\n                    // next code unit is the high surrogate of a surrogate pair.\n                    output.push(value);\n                    counter--;\n                }\n            } else {\n                output.push(value);\n            }\n        }\n        return output;\n    }\n    /**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */ var ucs2encode = function ucs2encode(array) {\n        return String.fromCodePoint.apply(String, toConsumableArray(array));\n    };\n    /**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */ var basicToDigit = function basicToDigit(codePoint) {\n        if (codePoint - 0x30 < 0x0A) {\n            return codePoint - 0x16;\n        }\n        if (codePoint - 0x41 < 0x1A) {\n            return codePoint - 0x41;\n        }\n        if (codePoint - 0x61 < 0x1A) {\n            return codePoint - 0x61;\n        }\n        return base;\n    };\n    /**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */ var digitToBasic = function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    /**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */ var adapt = function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for(; delta > baseMinusTMin * tMax >> 1; k += base){\n            delta = floor(delta / baseMinusTMin);\n        }\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    /**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */ var decode = function decode(input) {\n        // Don't use UCS-2.\n        var output = [];\n        var inputLength = input.length;\n        var i = 0;\n        var n = initialN;\n        var bias = initialBias;\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n        var basic = input.lastIndexOf(delimiter);\n        if (basic < 0) {\n            basic = 0;\n        }\n        for(var j = 0; j < basic; ++j){\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) {\n                error$1(\"not-basic\");\n            }\n            output.push(input.charCodeAt(j));\n        }\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            var oldi = i;\n            for(var w = 1, k = base;; k += base){\n                if (index >= inputLength) {\n                    error$1(\"invalid-input\");\n                }\n                var digit = basicToDigit(input.charCodeAt(index++));\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error$1(\"overflow\");\n                }\n                i += digit * w;\n                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (digit < t) {\n                    break;\n                }\n                var baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                    error$1(\"overflow\");\n                }\n                w *= baseMinusT;\n            }\n            var out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0);\n            // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) {\n                error$1(\"overflow\");\n            }\n            n += floor(i / out);\n            i %= out;\n            // Insert `n` at position `i` of the output.\n            output.splice(i++, 0, n);\n        }\n        return String.fromCodePoint.apply(String, output);\n    };\n    /**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */ var encode = function encode(input) {\n        var output = [];\n        // Convert the input in UCS-2 to an array of Unicode code points.\n        input = ucs2decode(input);\n        // Cache the length.\n        var inputLength = input.length;\n        // Initialize the state.\n        var n = initialN;\n        var delta = 0;\n        var bias = initialBias;\n        // Handle the basic code points.\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _currentValue2 = _step.value;\n                if (_currentValue2 < 0x80) {\n                    output.push(stringFromCharCode(_currentValue2));\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        var basicLength = output.length;\n        var handledCPCount = basicLength;\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n        // Finish the basic string with a delimiter unless it's empty.\n        if (basicLength) {\n            output.push(delimiter);\n        }\n        // Main encoding loop:\n        while(handledCPCount < inputLength){\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            var m = maxInt;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                    var currentValue = _step2.value;\n                    if (currentValue >= n && currentValue < m) {\n                        m = currentValue;\n                    }\n                }\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow.\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally{\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n            var handledCPCountPlusOne = handledCPCount + 1;\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error$1(\"overflow\");\n            }\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n            try {\n                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n                    var _currentValue = _step3.value;\n                    if (_currentValue < n && ++delta > maxInt) {\n                        error$1(\"overflow\");\n                    }\n                    if (_currentValue == n) {\n                        // Represent delta as a generalized variable-length integer.\n                        var q = delta;\n                        for(var k = base;; k += base){\n                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                            if (q < t) {\n                                break;\n                            }\n                            var qMinusT = q - t;\n                            var baseMinusT = base - t;\n                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                            q = floor(qMinusT / baseMinusT);\n                        }\n                        output.push(stringFromCharCode(digitToBasic(q, 0)));\n                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                        delta = 0;\n                        ++handledCPCount;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally{\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n            ++delta;\n            ++n;\n        }\n        return output.join(\"\");\n    };\n    /**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */ var toUnicode = function toUnicode(input) {\n        return mapDomain(input, function(string) {\n            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n        });\n    };\n    /**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */ var toASCII = function toASCII(input) {\n        return mapDomain(input, function(string) {\n            return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n        });\n    };\n    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {\n        /**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */ \"version\": \"2.1.0\",\n        /**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */ \"ucs2\": {\n            \"decode\": ucs2decode,\n            \"encode\": ucs2encode\n        },\n        \"decode\": decode,\n        \"encode\": encode,\n        \"toASCII\": toASCII,\n        \"toUnicode\": toUnicode\n    };\n    /**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */ /**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */ var SCHEMES = {};\n    function pctEncChar(chr) {\n        var c = chr.charCodeAt(0);\n        var e = void 0;\n        if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n        else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n        else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        return e;\n    }\n    function pctDecChars(str) {\n        var newStr = \"\";\n        var i = 0;\n        var il = str.length;\n        while(i < il){\n            var c = parseInt(str.substr(i + 1, 2), 16);\n            if (c < 128) {\n                newStr += String.fromCharCode(c);\n                i += 3;\n            } else if (c >= 194 && c < 224) {\n                if (il - i >= 6) {\n                    var c2 = parseInt(str.substr(i + 4, 2), 16);\n                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n                } else {\n                    newStr += str.substr(i, 6);\n                }\n                i += 6;\n            } else if (c >= 224) {\n                if (il - i >= 9) {\n                    var _c = parseInt(str.substr(i + 4, 2), 16);\n                    var c3 = parseInt(str.substr(i + 7, 2), 16);\n                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n                } else {\n                    newStr += str.substr(i, 9);\n                }\n                i += 9;\n            } else {\n                newStr += str.substr(i, 3);\n                i += 3;\n            }\n        }\n        return newStr;\n    }\n    function _normalizeComponentEncoding(components, protocol) {\n        function decodeUnreserved(str) {\n            var decStr = pctDecChars(str);\n            return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n        }\n        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        return components;\n    }\n    function _stripLeadingZeros(str) {\n        return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n    }\n    function _normalizeIPv4(host, protocol) {\n        var matches = host.match(protocol.IPV4ADDRESS) || [];\n        var _matches = slicedToArray(matches, 2), address = _matches[1];\n        if (address) {\n            return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n        } else {\n            return host;\n        }\n    }\n    function _normalizeIPv6(host, protocol) {\n        var matches = host.match(protocol.IPV6ADDRESS) || [];\n        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];\n        if (address) {\n            var _address$toLowerCase$ = address.toLowerCase().split(\"::\").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];\n            var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n            var lastFields = last.split(\":\").map(_stripLeadingZeros);\n            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n            var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n            var lastFieldsStart = lastFields.length - fieldCount;\n            var fields = Array(fieldCount);\n            for(var x = 0; x < fieldCount; ++x){\n                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || \"\";\n            }\n            if (isLastFieldIPv4Address) {\n                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n            }\n            var allZeroFields = fields.reduce(function(acc, field, index) {\n                if (!field || field === \"0\") {\n                    var lastLongest = acc[acc.length - 1];\n                    if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                        lastLongest.length++;\n                    } else {\n                        acc.push({\n                            index: index,\n                            length: 1\n                        });\n                    }\n                }\n                return acc;\n            }, []);\n            var longestZeroFields = allZeroFields.sort(function(a, b) {\n                return b.length - a.length;\n            })[0];\n            var newHost = void 0;\n            if (longestZeroFields && longestZeroFields.length > 1) {\n                var newFirst = fields.slice(0, longestZeroFields.index);\n                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n                newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n            } else {\n                newHost = fields.join(\":\");\n            }\n            if (zone) {\n                newHost += \"%\" + zone;\n            }\n            return newHost;\n        } else {\n            return host;\n        }\n    }\n    var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n    var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n    function parse(uriString) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var components = {};\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n        var matches = uriString.match(URI_PARSE);\n        if (matches) {\n            if (NO_MATCH_IS_UNDEFINED) {\n                //store each component\n                components.scheme = matches[1];\n                components.userinfo = matches[3];\n                components.host = matches[4];\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = matches[7];\n                components.fragment = matches[8];\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = matches[5];\n                }\n            } else {\n                //IE FIX for improper RegExp matching\n                //store each component\n                components.scheme = matches[1] || undefined;\n                components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n                components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n                components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n                }\n            }\n            if (components.host) {\n                //normalize IP hosts\n                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n            }\n            //determine reference type\n            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n                components.reference = \"same-document\";\n            } else if (components.scheme === undefined) {\n                components.reference = \"relative\";\n            } else if (components.fragment === undefined) {\n                components.reference = \"absolute\";\n            } else {\n                components.reference = \"uri\";\n            }\n            //check for reference errors\n            if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n                components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n            }\n            //find scheme handler\n            var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n            //check if scheme can't handle IRIs\n            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n                //if host component is a domain name\n                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                    } catch (e) {\n                        components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                }\n                //convert IRI -> URI\n                _normalizeComponentEncoding(components, URI_PROTOCOL);\n            } else {\n                //normalize encodings\n                _normalizeComponentEncoding(components, protocol);\n            }\n            //perform scheme specific parsing\n            if (schemeHandler && schemeHandler.parse) {\n                schemeHandler.parse(components, options);\n            }\n        } else {\n            components.error = components.error || \"URI can not be parsed.\";\n        }\n        return components;\n    }\n    function _recomposeAuthority(components, options) {\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        if (components.userinfo !== undefined) {\n            uriTokens.push(components.userinfo);\n            uriTokens.push(\"@\");\n        }\n        if (components.host !== undefined) {\n            //normalize IP hosts, add brackets and escape zone separator for IPv6\n            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {\n                return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n            }));\n        }\n        if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n            uriTokens.push(\":\");\n            uriTokens.push(String(components.port));\n        }\n        return uriTokens.length ? uriTokens.join(\"\") : undefined;\n    }\n    var RDS1 = /^\\.\\.?\\//;\n    var RDS2 = /^\\/\\.(\\/|$)/;\n    var RDS3 = /^\\/\\.\\.(\\/|$)/;\n    var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n    function removeDotSegments(input) {\n        var output = [];\n        while(input.length){\n            if (input.match(RDS1)) {\n                input = input.replace(RDS1, \"\");\n            } else if (input.match(RDS2)) {\n                input = input.replace(RDS2, \"/\");\n            } else if (input.match(RDS3)) {\n                input = input.replace(RDS3, \"/\");\n                output.pop();\n            } else if (input === \".\" || input === \"..\") {\n                input = \"\";\n            } else {\n                var im = input.match(RDS5);\n                if (im) {\n                    var s = im[0];\n                    input = input.slice(s.length);\n                    output.push(s);\n                } else {\n                    throw new Error(\"Unexpected dot segment condition\");\n                }\n            }\n        }\n        return output.join(\"\");\n    }\n    function serialize(components) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //perform scheme specific serialization\n        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n        if (components.host) {\n            //if host component is an IPv6 address\n            if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n        }\n        //normalize encoding\n        _normalizeComponentEncoding(components, protocol);\n        if (options.reference !== \"suffix\" && components.scheme) {\n            uriTokens.push(components.scheme);\n            uriTokens.push(\":\");\n        }\n        var authority = _recomposeAuthority(components, options);\n        if (authority !== undefined) {\n            if (options.reference !== \"suffix\") {\n                uriTokens.push(\"//\");\n            }\n            uriTokens.push(authority);\n            if (components.path && components.path.charAt(0) !== \"/\") {\n                uriTokens.push(\"/\");\n            }\n        }\n        if (components.path !== undefined) {\n            var s = components.path;\n            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n                s = removeDotSegments(s);\n            }\n            if (authority === undefined) {\n                s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n            }\n            uriTokens.push(s);\n        }\n        if (components.query !== undefined) {\n            uriTokens.push(\"?\");\n            uriTokens.push(components.query);\n        }\n        if (components.fragment !== undefined) {\n            uriTokens.push(\"#\");\n            uriTokens.push(components.fragment);\n        }\n        return uriTokens.join(\"\"); //merge tokens into a string\n    }\n    function resolveComponents(base, relative) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var skipNormalization = arguments[3];\n        var target = {};\n        if (!skipNormalization) {\n            base = parse(serialize(base, options), options); //normalize base components\n            relative = parse(serialize(relative, options), options); //normalize relative components\n        }\n        options = options || {};\n        if (!options.tolerant && relative.scheme) {\n            target.scheme = relative.scheme;\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n                //target.authority = relative.authority;\n                target.userinfo = relative.userinfo;\n                target.host = relative.host;\n                target.port = relative.port;\n                target.path = removeDotSegments(relative.path || \"\");\n                target.query = relative.query;\n            } else {\n                if (!relative.path) {\n                    target.path = base.path;\n                    if (relative.query !== undefined) {\n                        target.query = relative.query;\n                    } else {\n                        target.query = base.query;\n                    }\n                } else {\n                    if (relative.path.charAt(0) === \"/\") {\n                        target.path = removeDotSegments(relative.path);\n                    } else {\n                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                            target.path = \"/\" + relative.path;\n                        } else if (!base.path) {\n                            target.path = relative.path;\n                        } else {\n                            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                        }\n                        target.path = removeDotSegments(target.path);\n                    }\n                    target.query = relative.query;\n                }\n                //target.authority = base.authority;\n                target.userinfo = base.userinfo;\n                target.host = base.host;\n                target.port = base.port;\n            }\n            target.scheme = base.scheme;\n        }\n        target.fragment = relative.fragment;\n        return target;\n    }\n    function resolve(baseURI, relativeURI, options) {\n        var schemelessOptions = assign({\n            scheme: \"null\"\n        }, options);\n        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n    }\n    function normalize(uri, options) {\n        if (typeof uri === \"string\") {\n            uri = serialize(parse(uri, options), options);\n        } else if (typeOf(uri) === \"object\") {\n            uri = parse(serialize(uri, options), options);\n        }\n        return uri;\n    }\n    function equal(uriA, uriB, options) {\n        if (typeof uriA === \"string\") {\n            uriA = serialize(parse(uriA, options), options);\n        } else if (typeOf(uriA) === \"object\") {\n            uriA = serialize(uriA, options);\n        }\n        if (typeof uriB === \"string\") {\n            uriB = serialize(parse(uriB, options), options);\n        } else if (typeOf(uriB) === \"object\") {\n            uriB = serialize(uriB, options);\n        }\n        return uriA === uriB;\n    }\n    function escapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n    }\n    function unescapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n    }\n    var handler = {\n        scheme: \"http\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            //report missing host\n            if (!components.host) {\n                components.error = components.error || \"HTTP URIs must have a host.\";\n            }\n            return components;\n        },\n        serialize: function serialize(components, options) {\n            var secure = String(components.scheme).toLowerCase() === \"https\";\n            //normalize the default port\n            if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n                components.port = undefined;\n            }\n            //normalize the empty path\n            if (!components.path) {\n                components.path = \"/\";\n            }\n            //NOTE: We do not parse query strings for HTTP URIs\n            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n            //and not the HTTP spec.\n            return components;\n        }\n    };\n    var handler$1 = {\n        scheme: \"https\",\n        domainHost: handler.domainHost,\n        parse: handler.parse,\n        serialize: handler.serialize\n    };\n    function isSecure(wsComponents) {\n        return typeof wsComponents.secure === \"boolean\" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n    }\n    //RFC 6455\n    var handler$2 = {\n        scheme: \"ws\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            var wsComponents = components;\n            //indicate if the secure flag is set\n            wsComponents.secure = isSecure(wsComponents);\n            //construct resouce name\n            wsComponents.resourceName = (wsComponents.path || \"/\") + (wsComponents.query ? \"?\" + wsComponents.query : \"\");\n            wsComponents.path = undefined;\n            wsComponents.query = undefined;\n            return wsComponents;\n        },\n        serialize: function serialize(wsComponents, options) {\n            //normalize the default port\n            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n                wsComponents.port = undefined;\n            }\n            //ensure scheme matches secure flag\n            if (typeof wsComponents.secure === \"boolean\") {\n                wsComponents.scheme = wsComponents.secure ? \"wss\" : \"ws\";\n                wsComponents.secure = undefined;\n            }\n            //reconstruct path from resource name\n            if (wsComponents.resourceName) {\n                var _wsComponents$resourc = wsComponents.resourceName.split(\"?\"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];\n                wsComponents.path = path && path !== \"/\" ? path : undefined;\n                wsComponents.query = query;\n                wsComponents.resourceName = undefined;\n            }\n            //forbid fragment component\n            wsComponents.fragment = undefined;\n            return wsComponents;\n        }\n    };\n    var handler$3 = {\n        scheme: \"wss\",\n        domainHost: handler$2.domainHost,\n        parse: handler$2.parse,\n        serialize: handler$2.serialize\n    };\n    var O = {};\n    var isIRI = true;\n    //RFC 3986\n    var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n    var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n    var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n    //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n    //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n    //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n    //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n    //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n    //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n    var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n    var VCHAR$$ = merge(QTEXT$$, '[\\\\\"\\\\\\\\]');\n    var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n    var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n    var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n    var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n    var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n    var NOT_HFVALUE = NOT_HFNAME;\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(UNRESERVED) ? str : decStr;\n    }\n    var handler$4 = {\n        scheme: \"mailto\",\n        parse: function parse$$1(components, options) {\n            var mailtoComponents = components;\n            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n            mailtoComponents.path = undefined;\n            if (mailtoComponents.query) {\n                var unknownHeaders = false;\n                var headers = {};\n                var hfields = mailtoComponents.query.split(\"&\");\n                for(var x = 0, xl = hfields.length; x < xl; ++x){\n                    var hfield = hfields[x].split(\"=\");\n                    switch(hfield[0]){\n                        case \"to\":\n                            var toAddrs = hfield[1].split(\",\");\n                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x){\n                                to.push(toAddrs[_x]);\n                            }\n                            break;\n                        case \"subject\":\n                            mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                            break;\n                        case \"body\":\n                            mailtoComponents.body = unescapeComponent(hfield[1], options);\n                            break;\n                        default:\n                            unknownHeaders = true;\n                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                            break;\n                    }\n                }\n                if (unknownHeaders) mailtoComponents.headers = headers;\n            }\n            mailtoComponents.query = undefined;\n            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){\n                var addr = to[_x2].split(\"@\");\n                addr[0] = unescapeComponent(addr[0]);\n                if (!options.unicodeSupport) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                    } catch (e) {\n                        mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                } else {\n                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n                }\n                to[_x2] = addr.join(\"@\");\n            }\n            return mailtoComponents;\n        },\n        serialize: function serialize$$1(mailtoComponents, options) {\n            var components = mailtoComponents;\n            var to = toArray(mailtoComponents.to);\n            if (to) {\n                for(var x = 0, xl = to.length; x < xl; ++x){\n                    var toAddr = String(to[x]);\n                    var atIdx = toAddr.lastIndexOf(\"@\");\n                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                    var domain = toAddr.slice(atIdx + 1);\n                    //convert IDN via punycode\n                    try {\n                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                    } catch (e) {\n                        components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                    }\n                    to[x] = localPart + \"@\" + domain;\n                }\n                components.path = to.join(\",\");\n            }\n            var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n            if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n            if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n            var fields = [];\n            for(var name in headers){\n                if (headers[name] !== O[name]) {\n                    fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n                }\n            }\n            if (fields.length) {\n                components.query = fields.join(\"&\");\n            }\n            return components;\n        }\n    };\n    var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n    //RFC 2141\n    var handler$5 = {\n        scheme: \"urn\",\n        parse: function parse$$1(components, options) {\n            var matches = components.path && components.path.match(URN_PARSE);\n            var urnComponents = components;\n            if (matches) {\n                var scheme = options.scheme || urnComponents.scheme || \"urn\";\n                var nid = matches[1].toLowerCase();\n                var nss = matches[2];\n                var urnScheme = scheme + \":\" + (options.nid || nid);\n                var schemeHandler = SCHEMES[urnScheme];\n                urnComponents.nid = nid;\n                urnComponents.nss = nss;\n                urnComponents.path = undefined;\n                if (schemeHandler) {\n                    urnComponents = schemeHandler.parse(urnComponents, options);\n                }\n            } else {\n                urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n            }\n            return urnComponents;\n        },\n        serialize: function serialize$$1(urnComponents, options) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = urnComponents.nid;\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            if (schemeHandler) {\n                urnComponents = schemeHandler.serialize(urnComponents, options);\n            }\n            var uriComponents = urnComponents;\n            var nss = urnComponents.nss;\n            uriComponents.path = (nid || options.nid) + \":\" + nss;\n            return uriComponents;\n        }\n    };\n    var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n    //RFC 4122\n    var handler$6 = {\n        scheme: \"urn:uuid\",\n        parse: function parse(urnComponents, options) {\n            var uuidComponents = urnComponents;\n            uuidComponents.uuid = uuidComponents.nss;\n            uuidComponents.nss = undefined;\n            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n                uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n            }\n            return uuidComponents;\n        },\n        serialize: function serialize(uuidComponents, options) {\n            var urnComponents = uuidComponents;\n            //normalize UUID\n            urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n            return urnComponents;\n        }\n    };\n    SCHEMES[handler.scheme] = handler;\n    SCHEMES[handler$1.scheme] = handler$1;\n    SCHEMES[handler$2.scheme] = handler$2;\n    SCHEMES[handler$3.scheme] = handler$3;\n    SCHEMES[handler$4.scheme] = handler$4;\n    SCHEMES[handler$5.scheme] = handler$5;\n    SCHEMES[handler$6.scheme] = handler$6;\n    exports1.SCHEMES = SCHEMES;\n    exports1.pctEncChar = pctEncChar;\n    exports1.pctDecChars = pctDecChars;\n    exports1.parse = parse;\n    exports1.removeDotSegments = removeDotSegments;\n    exports1.serialize = serialize;\n    exports1.resolveComponents = resolveComponents;\n    exports1.resolve = resolve;\n    exports1.normalize = normalize;\n    exports1.equal = equal;\n    exports1.escapeComponent = escapeComponent;\n    exports1.unescapeComponent = unescapeComponent;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=uri.all.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpLWpzL2Rpc3QvZXM1L3VyaS5hbGwuanMiLCJtYXBwaW5ncyI6IkFBQUEsNEZBQTRGLEdBQzNGLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN6QixLQUFpRCxHQUFjQSxRQUFRQyxXQUN2RSxDQUN3QztBQUN6QyxHQUFFLElBQUksRUFBRyxTQUFVQSxRQUFPO0lBQUk7SUFFOUIsU0FBU0s7UUFDTCxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBT0MsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1lBQ2pGRixJQUFJLENBQUNFLEtBQUssR0FBR0osU0FBUyxDQUFDSSxLQUFLO1FBQ2hDO1FBRUEsSUFBSUYsS0FBS0QsTUFBTSxHQUFHLEdBQUc7WUFDakJDLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLENBQUNHLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDNUIsSUFBSUMsS0FBS0osS0FBS0QsTUFBTSxHQUFHO1lBQ3ZCLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJRCxJQUFJLEVBQUVDLEVBQUc7Z0JBQ3pCTCxJQUFJLENBQUNLLEVBQUUsR0FBR0wsSUFBSSxDQUFDSyxFQUFFLENBQUNGLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDaEM7WUFDQUgsSUFBSSxDQUFDSSxHQUFHLEdBQUdKLElBQUksQ0FBQ0ksR0FBRyxDQUFDRCxLQUFLLENBQUM7WUFDMUIsT0FBT0gsS0FBS00sSUFBSSxDQUFDO1FBQ3JCLE9BQU87WUFDSCxPQUFPTixJQUFJLENBQUMsRUFBRTtRQUNsQjtJQUNKO0lBQ0EsU0FBU08sT0FBT0MsR0FBRztRQUNmLE9BQU8sUUFBUUEsTUFBTTtJQUN6QjtJQUNBLFNBQVNDLE9BQU9DLENBQUM7UUFDYixPQUFPQSxNQUFNQyxZQUFZLGNBQWNELE1BQU0sT0FBTyxTQUFTRSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTCxHQUFHTSxLQUFLLENBQUMsS0FBS0MsR0FBRyxHQUFHRCxLQUFLLENBQUMsS0FBS0UsS0FBSyxHQUFHQyxXQUFXO0lBQ2xKO0lBQ0EsU0FBU0MsWUFBWVosR0FBRztRQUNwQixPQUFPQSxJQUFJWSxXQUFXO0lBQzFCO0lBQ0EsU0FBU0MsUUFBUUMsR0FBRztRQUNoQixPQUFPQSxRQUFRWCxhQUFhVyxRQUFRLE9BQU9BLGVBQWVyQixRQUFRcUIsTUFBTSxPQUFPQSxJQUFJdkIsTUFBTSxLQUFLLFlBQVl1QixJQUFJTixLQUFLLElBQUlNLElBQUlDLFdBQVcsSUFBSUQsSUFBSVAsSUFBSSxHQUFHO1lBQUNPO1NBQUksR0FBR3JCLE1BQU1ZLFNBQVMsQ0FBQ1YsS0FBSyxDQUFDWSxJQUFJLENBQUNPLE9BQU8sRUFBRTtJQUNyTTtJQUNBLFNBQVNFLE9BQU9DLE1BQU0sRUFBRUMsTUFBTTtRQUMxQixJQUFJSixNQUFNRztRQUNWLElBQUlDLFFBQVE7WUFDUixJQUFLLElBQUlDLE9BQU9ELE9BQVE7Z0JBQ3BCSixHQUFHLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO1lBQzFCO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0lBRUEsU0FBU00sVUFBVUMsS0FBSztRQUNwQixJQUFJQyxVQUFVLFlBQ1ZDLE1BQU0sV0FDTkMsVUFBVSxTQUNWQyxXQUFXLFdBQ1hDLFdBQVd0QyxNQUFNb0MsU0FBUyxhQUMxQixrQkFBa0I7UUFDdEJHLE9BQU8sV0FDSEMsT0FBTyxXQUNQQyxlQUFlOUIsT0FBT0EsT0FBTyxZQUFZMkIsV0FBVyxNQUFNQSxXQUFXQSxXQUFXLE1BQU1BLFdBQVdBLFlBQVksTUFBTTNCLE9BQU8sZ0JBQWdCMkIsV0FBVyxNQUFNQSxXQUFXQSxZQUFZLE1BQU0zQixPQUFPLE1BQU0yQixXQUFXQSxZQUNoTixVQUFVO1FBQ2RJLGVBQWUsMkJBQ1hDLGVBQWUsdUNBQ2ZDLGFBQWE1QyxNQUFNMEMsY0FBY0MsZUFDakNFLFlBQVlaLFFBQVEsZ0ZBQWdGLE1BQ3BHLDBDQUEwQztRQUM5Q2EsYUFBYWIsUUFBUSxzQkFBc0IsTUFDdkMsUUFBUTtRQUNaYyxlQUFlL0MsTUFBTWtDLFNBQVNFLFNBQVMsa0JBQWtCUyxZQUNyREcsVUFBVXJDLE9BQU91QixVQUFVbEMsTUFBTWtDLFNBQVNFLFNBQVMsaUJBQWlCLE1BQ3BFYSxZQUFZdEMsT0FBT0EsT0FBTzhCLGVBQWUsTUFBTXpDLE1BQU0rQyxjQUFjSixjQUFjLFlBQVksTUFDN0ZPLGFBQWF2QyxPQUFPQSxPQUFPLGFBQWEsTUFBTUEsT0FBTyxXQUFXeUIsV0FBVyxNQUFNekIsT0FBTyxNQUFNeUIsVUFBVUEsV0FBVyxNQUFNekIsT0FBTyxVQUFVeUIsV0FBVyxNQUFNQSxVQUMzSmUscUJBQXFCeEMsT0FBT0EsT0FBTyxhQUFhLE1BQU1BLE9BQU8sV0FBV3lCLFdBQVcsTUFBTXpCLE9BQU8sTUFBTXlCLFVBQVVBLFdBQVcsTUFBTXpCLE9BQU8sWUFBWXlCLFdBQVcsVUFBVUEsVUFDekssdUJBQXVCO1FBQzNCZ0IsZUFBZXpDLE9BQU93QyxxQkFBcUIsUUFBUUEscUJBQXFCLFFBQVFBLHFCQUFxQixRQUFRQSxxQkFDekdFLE9BQU8xQyxPQUFPMkIsV0FBVyxVQUN6QmdCLFFBQVEzQyxPQUFPQSxPQUFPMEMsT0FBTyxRQUFRQSxRQUFRLE1BQU1ELGVBQ25ERyxnQkFBZ0I1QyxPQUFPQSxPQUFPMEMsT0FBTyxTQUFTLFFBQVFDLFFBQ3RELDhDQUE4QztRQUNsREUsZ0JBQWdCN0MsT0FBTyxXQUFXQSxPQUFPMEMsT0FBTyxTQUFTLFFBQVFDLFFBQzdELDhDQUE4QztRQUNsREcsZ0JBQWdCOUMsT0FBT0EsT0FBTzBDLFFBQVEsWUFBWTFDLE9BQU8wQyxPQUFPLFNBQVMsUUFBUUMsUUFDN0UsOENBQThDO1FBQ2xESSxnQkFBZ0IvQyxPQUFPQSxPQUFPQSxPQUFPMEMsT0FBTyxTQUFTLFVBQVVBLFFBQVEsWUFBWTFDLE9BQU8wQyxPQUFPLFNBQVMsUUFBUUMsUUFDOUcsOENBQThDO1FBQ2xESyxnQkFBZ0JoRCxPQUFPQSxPQUFPQSxPQUFPMEMsT0FBTyxTQUFTLFVBQVVBLFFBQVEsWUFBWTFDLE9BQU8wQyxPQUFPLFNBQVMsUUFBUUMsUUFDOUcsOENBQThDO1FBQ2xETSxnQkFBZ0JqRCxPQUFPQSxPQUFPQSxPQUFPMEMsT0FBTyxTQUFTLFVBQVVBLFFBQVEsWUFBWUEsT0FBTyxRQUFRQyxRQUM5Riw4Q0FBOEM7UUFDbERPLGdCQUFnQmxELE9BQU9BLE9BQU9BLE9BQU8wQyxPQUFPLFNBQVMsVUFBVUEsUUFBUSxZQUFZQyxRQUMvRSw4Q0FBOEM7UUFDbERRLGdCQUFnQm5ELE9BQU9BLE9BQU9BLE9BQU8wQyxPQUFPLFNBQVMsVUFBVUEsUUFBUSxZQUFZQSxPQUMvRSw2Q0FBNkM7UUFDakRVLGdCQUFnQnBELE9BQU9BLE9BQU9BLE9BQU8wQyxPQUFPLFNBQVMsVUFBVUEsUUFBUSxZQUNuRSw0QkFBNEI7UUFDaENXLGVBQWVyRCxPQUFPO1lBQUM0QztZQUFlQztZQUFlQztZQUFlQztZQUFlQztZQUFlQztZQUFlQztZQUFlQztZQUFlQztTQUFjLENBQUNyRCxJQUFJLENBQUMsT0FDL0p1RCxVQUFVdEQsT0FBT0EsT0FBT29DLGVBQWUsTUFBTU4sZ0JBQWdCLE1BQzdELFVBQVU7UUFDZHlCLGFBQWF2RCxPQUFPcUQsZUFBZSxVQUFVQyxVQUN6QyxVQUFVO1FBQ2RFLHFCQUFxQnhELE9BQU9xRCxlQUFlckQsT0FBTyxpQkFBaUIyQixXQUFXLFVBQVUyQixVQUNwRixzQ0FBc0M7UUFDMUNHLGFBQWF6RCxPQUFPLFNBQVMyQixXQUFXLFNBQVN0QyxNQUFNK0MsY0FBY0osY0FBYyxXQUFXLE1BQzFGMEIsY0FBYzFELE9BQU8sUUFBUUEsT0FBT3dELHFCQUFxQixNQUFNSCxlQUFlLE1BQU1JLGNBQWMsUUFDbEcsVUFBVTtRQUNkRSxZQUFZM0QsT0FBT0EsT0FBTzhCLGVBQWUsTUFBTXpDLE1BQU0rQyxjQUFjSixpQkFBaUIsTUFDaEY0QixRQUFRNUQsT0FBTzBELGNBQWMsTUFBTWpCLGVBQWUsUUFBUWtCLFlBQVksTUFBTSxNQUFNQSxZQUNsRkUsUUFBUTdELE9BQU95QixVQUFVLE1BQ3pCcUMsYUFBYTlELE9BQU9BLE9BQU9zQyxZQUFZLE9BQU8sTUFBTXNCLFFBQVE1RCxPQUFPLFFBQVE2RCxTQUFTLE1BQ3BGRSxTQUFTL0QsT0FBTzhCLGVBQWUsTUFBTXpDLE1BQU0rQyxjQUFjSixjQUFjLGNBQ3ZFZ0MsV0FBV2hFLE9BQU8rRCxTQUFTLE1BQzNCRSxjQUFjakUsT0FBTytELFNBQVMsTUFDOUJHLGlCQUFpQmxFLE9BQU9BLE9BQU84QixlQUFlLE1BQU16QyxNQUFNK0MsY0FBY0osY0FBYyxZQUFZLE1BQ2xHbUMsZ0JBQWdCbkUsT0FBT0EsT0FBTyxRQUFRZ0UsWUFBWSxNQUNsREksaUJBQWlCcEUsT0FBTyxRQUFRQSxPQUFPaUUsY0FBY0UsaUJBQWlCLE1BQ3RFLFlBQVk7UUFDaEJFLGlCQUFpQnJFLE9BQU9rRSxpQkFBaUJDLGdCQUNyQyxZQUFZO1FBQ2hCRyxpQkFBaUJ0RSxPQUFPaUUsY0FBY0UsZ0JBQ2xDLFlBQVk7UUFDaEJJLGNBQWMsUUFBUVIsU0FBUyxLQUMzQlMsUUFBUXhFLE9BQU9tRSxnQkFBZ0IsTUFBTUMsaUJBQWlCLE1BQU1DLGlCQUFpQixNQUFNQyxpQkFBaUIsTUFBTUMsY0FDMUdFLFNBQVN6RSxPQUFPQSxPQUFPK0QsU0FBUyxNQUFNMUUsTUFBTSxZQUFZOEMsZUFBZSxNQUN2RXVDLFlBQVkxRSxPQUFPQSxPQUFPK0QsU0FBUyxlQUFlLE1BQ2xEWSxhQUFhM0UsT0FBT0EsT0FBTyxXQUFXOEQsYUFBYUssaUJBQWlCLE1BQU1DLGlCQUFpQixNQUFNRSxpQkFBaUIsTUFBTUMsY0FDeEhLLE9BQU81RSxPQUFPcUMsVUFBVSxRQUFRc0MsYUFBYTNFLE9BQU8sUUFBUXlFLFVBQVUsTUFBTXpFLE9BQU8sUUFBUTBFLGFBQWEsTUFDeEdHLGlCQUFpQjdFLE9BQU9BLE9BQU8sV0FBVzhELGFBQWFLLGlCQUFpQixNQUFNQyxpQkFBaUIsTUFBTUMsaUJBQWlCLE1BQU1FLGNBQzVITyxZQUFZOUUsT0FBTzZFLGlCQUFpQjdFLE9BQU8sUUFBUXlFLFVBQVUsTUFBTXpFLE9BQU8sUUFBUTBFLGFBQWEsTUFDL0ZLLGlCQUFpQi9FLE9BQU80RSxPQUFPLE1BQU1FLFlBQ3JDRSxnQkFBZ0JoRixPQUFPcUMsVUFBVSxRQUFRc0MsYUFBYTNFLE9BQU8sUUFBUXlFLFVBQVUsTUFDL0VRLGVBQWUsT0FBTzVDLFVBQVUsU0FBU3JDLE9BQU9BLE9BQU8sWUFBWUEsT0FBTyxNQUFNc0MsWUFBWSxRQUFRLE9BQU9zQixRQUFRLE1BQU01RCxPQUFPLFNBQVM2RCxRQUFRLE9BQU8sUUFBUSxPQUFPTSxnQkFBZ0IsTUFBTUMsaUJBQWlCLE1BQU1FLGlCQUFpQixNQUFNQyxjQUFjLE9BQU92RSxPQUFPLFNBQVN5RSxTQUFTLE9BQU8sTUFBTXpFLE9BQU8sU0FBUzBFLFlBQVksT0FBTyxNQUN6VVEsZ0JBQWdCLFdBQVdsRixPQUFPQSxPQUFPLFlBQVlBLE9BQU8sTUFBTXNDLFlBQVksUUFBUSxPQUFPc0IsUUFBUSxNQUFNNUQsT0FBTyxTQUFTNkQsUUFBUSxPQUFPLFFBQVEsT0FBT00sZ0JBQWdCLE1BQU1DLGlCQUFpQixNQUFNQyxpQkFBaUIsTUFBTUUsY0FBYyxPQUFPdkUsT0FBTyxTQUFTeUUsU0FBUyxPQUFPLE1BQU16RSxPQUFPLFNBQVMwRSxZQUFZLE9BQU8sTUFDM1RTLGdCQUFnQixPQUFPOUMsVUFBVSxTQUFTckMsT0FBT0EsT0FBTyxZQUFZQSxPQUFPLE1BQU1zQyxZQUFZLFFBQVEsT0FBT3NCLFFBQVEsTUFBTTVELE9BQU8sU0FBUzZELFFBQVEsT0FBTyxRQUFRLE9BQU9NLGdCQUFnQixNQUFNQyxpQkFBaUIsTUFBTUUsaUJBQWlCLE1BQU1DLGNBQWMsT0FBT3ZFLE9BQU8sU0FBU3lFLFNBQVMsT0FBTyxNQUNqU1csZUFBZSxNQUFNcEYsT0FBTyxTQUFTMEUsWUFBWSxPQUFPLE1BQ3hEVyxpQkFBaUIsTUFBTXJGLE9BQU8sTUFBTXNDLFlBQVksUUFBUSxPQUFPc0IsUUFBUSxNQUFNNUQsT0FBTyxTQUFTNkQsUUFBUSxPQUFPO1FBQ2hILE9BQU87WUFDSHlCLFlBQVksSUFBSUMsT0FBT2xHLE1BQU0sT0FBT2tDLFNBQVNFLFNBQVMsZ0JBQWdCO1lBQ3RFK0QsY0FBYyxJQUFJRCxPQUFPbEcsTUFBTSxhQUFhK0MsY0FBY0osZUFBZTtZQUN6RXlELFVBQVUsSUFBSUYsT0FBT2xHLE1BQU0sbUJBQW1CK0MsY0FBY0osZUFBZTtZQUMzRTBELFVBQVUsSUFBSUgsT0FBT2xHLE1BQU0sbUJBQW1CK0MsY0FBY0osZUFBZTtZQUMzRTJELG1CQUFtQixJQUFJSixPQUFPbEcsTUFBTSxnQkFBZ0IrQyxjQUFjSixlQUFlO1lBQ2pGNEQsV0FBVyxJQUFJTCxPQUFPbEcsTUFBTSxVQUFVK0MsY0FBY0osY0FBYyxrQkFBa0JHLGFBQWE7WUFDakcwRCxjQUFjLElBQUlOLE9BQU9sRyxNQUFNLFVBQVUrQyxjQUFjSixjQUFjLG1CQUFtQjtZQUN4RjhELFFBQVEsSUFBSVAsT0FBT2xHLE1BQU0sT0FBTytDLGNBQWNKLGVBQWU7WUFDN0QrRCxZQUFZLElBQUlSLE9BQU9uRCxjQUFjO1lBQ3JDNEQsYUFBYSxJQUFJVCxPQUFPbEcsTUFBTSxVQUFVK0MsY0FBY0gsYUFBYTtZQUNuRWdFLGFBQWEsSUFBSVYsT0FBT3pELGNBQWM7WUFDdENvRSxhQUFhLElBQUlYLE9BQU8sT0FBTzlDLGVBQWU7WUFDOUMwRCxhQUFhLElBQUlaLE9BQU8sV0FBV2xDLGVBQWUsTUFBTXJELE9BQU9BLE9BQU8saUJBQWlCMkIsV0FBVyxVQUFVLE1BQU0yQixVQUFVLE9BQU8sVUFBVSxzQ0FBc0M7UUFDdkw7SUFDSjtJQUNBLElBQUk4QyxlQUFlL0UsVUFBVTtJQUU3QixJQUFJZ0YsZUFBZWhGLFVBQVU7SUFFN0IsSUFBSWlGLGdCQUFnQjtRQUNsQixTQUFTQyxjQUFjQyxHQUFHLEVBQUVDLENBQUM7WUFDM0IsSUFBSUMsT0FBTyxFQUFFO1lBQ2IsSUFBSUMsS0FBSztZQUNULElBQUlDLEtBQUs7WUFDVCxJQUFJQyxLQUFLekc7WUFFVCxJQUFJO2dCQUNGLElBQUssSUFBSTBHLEtBQUtOLEdBQUcsQ0FBQ08sT0FBT0MsUUFBUSxDQUFDLElBQUlDLElBQUksQ0FBRU4sQ0FBQUEsS0FBSyxDQUFDTSxLQUFLSCxHQUFHSSxJQUFJLEVBQUMsRUFBR0MsSUFBSSxHQUFHUixLQUFLLEtBQU07b0JBQ2xGRCxLQUFLVSxJQUFJLENBQUNILEdBQUdJLEtBQUs7b0JBRWxCLElBQUlaLEtBQUtDLEtBQUtsSCxNQUFNLEtBQUtpSCxHQUFHO2dCQUM5QjtZQUNGLEVBQUUsT0FBT2EsS0FBSztnQkFDWlYsS0FBSztnQkFDTEMsS0FBS1M7WUFDUCxTQUFVO2dCQUNSLElBQUk7b0JBQ0YsSUFBSSxDQUFDWCxNQUFNRyxFQUFFLENBQUMsU0FBUyxFQUFFQSxFQUFFLENBQUMsU0FBUztnQkFDdkMsU0FBVTtvQkFDUixJQUFJRixJQUFJLE1BQU1DO2dCQUNoQjtZQUNGO1lBRUEsT0FBT0g7UUFDVDtRQUVBLE9BQU8sU0FBVUYsR0FBRyxFQUFFQyxDQUFDO1lBQ3JCLElBQUkvRyxNQUFNNkgsT0FBTyxDQUFDZixNQUFNO2dCQUN0QixPQUFPQTtZQUNULE9BQU8sSUFBSU8sT0FBT0MsUUFBUSxJQUFJM0csT0FBT21HLE1BQU07Z0JBQ3pDLE9BQU9ELGNBQWNDLEtBQUtDO1lBQzVCLE9BQU87Z0JBQ0wsTUFBTSxJQUFJZSxVQUFVO1lBQ3RCO1FBQ0Y7SUFDRjtJQWNBLElBQUlDLG9CQUFvQixTQUFVakIsR0FBRztRQUNuQyxJQUFJOUcsTUFBTTZILE9BQU8sQ0FBQ2YsTUFBTTtZQUN0QixJQUFLLElBQUlDLElBQUksR0FBR2lCLE9BQU9oSSxNQUFNOEcsSUFBSWhILE1BQU0sR0FBR2lILElBQUlELElBQUloSCxNQUFNLEVBQUVpSCxJQUFLaUIsSUFBSSxDQUFDakIsRUFBRSxHQUFHRCxHQUFHLENBQUNDLEVBQUU7WUFFL0UsT0FBT2lCO1FBQ1QsT0FBTztZQUNMLE9BQU9oSSxNQUFNaUksSUFBSSxDQUFDbkI7UUFDcEI7SUFDRjtJQUVBLCtDQUErQyxHQUUvQyxJQUFJb0IsU0FBUyxZQUFZLDRCQUE0QjtJQUVyRCwwQkFBMEIsR0FDMUIsSUFBSUMsT0FBTztJQUNYLElBQUlDLE9BQU87SUFDWCxJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsT0FBTztJQUNYLElBQUlDLE9BQU87SUFDWCxJQUFJQyxjQUFjO0lBQ2xCLElBQUlDLFdBQVcsS0FBSyxPQUFPO0lBQzNCLElBQUlDLFlBQVksS0FBSyxTQUFTO0lBRTlCLHdCQUF3QixHQUN4QixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMsZ0JBQWdCLGNBQWMsa0JBQWtCO0lBQ3BELElBQUlDLGtCQUFrQiw2QkFBNkIsc0JBQXNCO0lBRXpFLG1CQUFtQixHQUNuQixJQUFJQyxTQUFTO1FBQ1osWUFBWTtRQUNaLGFBQWE7UUFDYixpQkFBaUI7SUFDbEI7SUFFQSwwQkFBMEIsR0FDMUIsSUFBSUMsZ0JBQWdCWixPQUFPQztJQUMzQixJQUFJWSxRQUFRQyxLQUFLRCxLQUFLO0lBQ3RCLElBQUlFLHFCQUFxQkMsT0FBT0MsWUFBWTtJQUU1Qyw0RUFBNEUsR0FFNUU7Ozs7O0NBS0MsR0FDRCxTQUFTQyxRQUFRQyxJQUFJO1FBQ3BCLE1BQU0sSUFBSUMsV0FBV1QsTUFBTSxDQUFDUSxLQUFLO0lBQ2xDO0lBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNFLElBQUlDLEtBQUssRUFBRUMsRUFBRTtRQUNyQixJQUFJQyxTQUFTLEVBQUU7UUFDZixJQUFJN0osU0FBUzJKLE1BQU0zSixNQUFNO1FBQ3pCLE1BQU9BLFNBQVU7WUFDaEI2SixNQUFNLENBQUM3SixPQUFPLEdBQUc0SixHQUFHRCxLQUFLLENBQUMzSixPQUFPO1FBQ2xDO1FBQ0EsT0FBTzZKO0lBQ1I7SUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQyxVQUFVQyxNQUFNLEVBQUVILEVBQUU7UUFDNUIsSUFBSUksUUFBUUQsT0FBTzlJLEtBQUssQ0FBQztRQUN6QixJQUFJNEksU0FBUztRQUNiLElBQUlHLE1BQU1oSyxNQUFNLEdBQUcsR0FBRztZQUNyQixzRUFBc0U7WUFDdEUscURBQXFEO1lBQ3JENkosU0FBU0csS0FBSyxDQUFDLEVBQUUsR0FBRztZQUNwQkQsU0FBU0MsS0FBSyxDQUFDLEVBQUU7UUFDbEI7UUFDQSx1REFBdUQ7UUFDdkRELFNBQVNBLE9BQU9FLE9BQU8sQ0FBQ2xCLGlCQUFpQjtRQUN6QyxJQUFJbUIsU0FBU0gsT0FBTzlJLEtBQUssQ0FBQztRQUMxQixJQUFJa0osVUFBVVQsSUFBSVEsUUFBUU4sSUFBSXJKLElBQUksQ0FBQztRQUNuQyxPQUFPc0osU0FBU007SUFDakI7SUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTQyxXQUFXTCxNQUFNO1FBQ3pCLElBQUlNLFNBQVMsRUFBRTtRQUNmLElBQUlDLFVBQVU7UUFDZCxJQUFJdEssU0FBUytKLE9BQU8vSixNQUFNO1FBQzFCLE1BQU9zSyxVQUFVdEssT0FBUTtZQUN4QixJQUFJNkgsUUFBUWtDLE9BQU9RLFVBQVUsQ0FBQ0Q7WUFDOUIsSUFBSXpDLFNBQVMsVUFBVUEsU0FBUyxVQUFVeUMsVUFBVXRLLFFBQVE7Z0JBQzNELHdEQUF3RDtnQkFDeEQsSUFBSXdLLFFBQVFULE9BQU9RLFVBQVUsQ0FBQ0Q7Z0JBQzlCLElBQUksQ0FBQ0UsUUFBUSxNQUFLLEtBQU0sUUFBUTtvQkFDL0IsaUJBQWlCO29CQUNqQkgsT0FBT3pDLElBQUksQ0FBQyxDQUFDLENBQUNDLFFBQVEsS0FBSSxLQUFNLEVBQUMsSUFBTTJDLENBQUFBLFFBQVEsS0FBSSxJQUFLO2dCQUN6RCxPQUFPO29CQUNOLHVFQUF1RTtvQkFDdkUsNERBQTREO29CQUM1REgsT0FBT3pDLElBQUksQ0FBQ0M7b0JBQ1p5QztnQkFDRDtZQUNELE9BQU87Z0JBQ05ELE9BQU96QyxJQUFJLENBQUNDO1lBQ2I7UUFDRDtRQUNBLE9BQU93QztJQUNSO0lBRUE7Ozs7Ozs7Q0FPQyxHQUNELElBQUlJLGFBQWEsU0FBU0EsV0FBV2QsS0FBSztRQUN6QyxPQUFPTixPQUFPcUIsYUFBYSxDQUFDQyxLQUFLLENBQUN0QixRQUFRcEIsa0JBQWtCMEI7SUFDN0Q7SUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELElBQUlpQixlQUFlLFNBQVNBLGFBQWFDLFNBQVM7UUFDakQsSUFBSUEsWUFBWSxPQUFPLE1BQU07WUFDNUIsT0FBT0EsWUFBWTtRQUNwQjtRQUNBLElBQUlBLFlBQVksT0FBTyxNQUFNO1lBQzVCLE9BQU9BLFlBQVk7UUFDcEI7UUFDQSxJQUFJQSxZQUFZLE9BQU8sTUFBTTtZQUM1QixPQUFPQSxZQUFZO1FBQ3BCO1FBQ0EsT0FBT3hDO0lBQ1I7SUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsSUFBSXlDLGVBQWUsU0FBU0EsYUFBYUMsS0FBSyxFQUFFQyxJQUFJO1FBQ25ELG1DQUFtQztRQUNuQywyQkFBMkI7UUFDM0IsT0FBT0QsUUFBUSxLQUFLLEtBQU1BLENBQUFBLFFBQVEsRUFBQyxJQUFNLEVBQUNDLFFBQVEsTUFBTTtJQUN6RDtJQUVBOzs7O0NBSUMsR0FDRCxJQUFJQyxRQUFRLFNBQVNBLE1BQU1DLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxTQUFTO1FBQ3JELElBQUlDLElBQUk7UUFDUkgsUUFBUUUsWUFBWWxDLE1BQU1nQyxRQUFRekMsUUFBUXlDLFNBQVM7UUFDbkRBLFNBQVNoQyxNQUFNZ0MsUUFBUUM7UUFDdkIsTUFBOEJELFFBQVFqQyxnQkFBZ0JWLFFBQVEsR0FBRzhDLEtBQUtoRCxLQUFNO1lBQzNFNkMsUUFBUWhDLE1BQU1nQyxRQUFRakM7UUFDdkI7UUFDQSxPQUFPQyxNQUFNbUMsSUFBSSxDQUFDcEMsZ0JBQWdCLEtBQUtpQyxRQUFTQSxDQUFBQSxRQUFRMUMsSUFBRztJQUM1RDtJQUVBOzs7Ozs7Q0FNQyxHQUNELElBQUk4QyxTQUFTLFNBQVNBLE9BQU9DLEtBQUs7UUFDakMsbUJBQW1CO1FBQ25CLElBQUlsQixTQUFTLEVBQUU7UUFDZixJQUFJbUIsY0FBY0QsTUFBTXZMLE1BQU07UUFDOUIsSUFBSWlILElBQUk7UUFDUixJQUFJd0UsSUFBSTlDO1FBQ1IsSUFBSStDLE9BQU9oRDtRQUVYLHdFQUF3RTtRQUN4RSx1RUFBdUU7UUFDdkUsNkNBQTZDO1FBRTdDLElBQUlpRCxRQUFRSixNQUFNSyxXQUFXLENBQUNoRDtRQUM5QixJQUFJK0MsUUFBUSxHQUFHO1lBQ2RBLFFBQVE7UUFDVDtRQUVBLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixPQUFPLEVBQUVFLEVBQUc7WUFDL0IsaUNBQWlDO1lBQ2pDLElBQUlOLE1BQU1oQixVQUFVLENBQUNzQixNQUFNLE1BQU07Z0JBQ2hDdEMsUUFBUTtZQUNUO1lBQ0FjLE9BQU96QyxJQUFJLENBQUMyRCxNQUFNaEIsVUFBVSxDQUFDc0I7UUFDOUI7UUFFQSw0RUFBNEU7UUFDNUUsd0RBQXdEO1FBRXhELElBQUssSUFBSUMsUUFBUUgsUUFBUSxJQUFJQSxRQUFRLElBQUksR0FBR0csUUFBUU4sYUFBYyx1QkFBdUIsR0FBRTtZQUUxRiw2REFBNkQ7WUFDN0QsNkRBQTZEO1lBQzdELDJEQUEyRDtZQUMzRCw4REFBOEQ7WUFDOUQsc0NBQXNDO1lBQ3RDLElBQUlPLE9BQU85RTtZQUNYLElBQUssSUFBSStFLElBQUksR0FBR1gsSUFBSWhELE9BQXlCZ0QsS0FBS2hELEtBQU07Z0JBRXZELElBQUl5RCxTQUFTTixhQUFhO29CQUN6QmpDLFFBQVE7Z0JBQ1Q7Z0JBRUEsSUFBSXdCLFFBQVFILGFBQWFXLE1BQU1oQixVQUFVLENBQUN1QjtnQkFFMUMsSUFBSWYsU0FBUzFDLFFBQVEwQyxRQUFRN0IsTUFBTSxDQUFDZCxTQUFTbkIsQ0FBQUEsSUFBSytFLElBQUk7b0JBQ3JEekMsUUFBUTtnQkFDVDtnQkFFQXRDLEtBQUs4RCxRQUFRaUI7Z0JBQ2IsSUFBSUMsSUFBSVosS0FBS0ssT0FBT3BELE9BQU8rQyxLQUFLSyxPQUFPbkQsT0FBT0EsT0FBTzhDLElBQUlLO2dCQUV6RCxJQUFJWCxRQUFRa0IsR0FBRztvQkFDZDtnQkFDRDtnQkFFQSxJQUFJQyxhQUFhN0QsT0FBTzREO2dCQUN4QixJQUFJRCxJQUFJOUMsTUFBTWQsU0FBUzhELGFBQWE7b0JBQ25DM0MsUUFBUTtnQkFDVDtnQkFFQXlDLEtBQUtFO1lBQ047WUFFQSxJQUFJQyxNQUFNOUIsT0FBT3JLLE1BQU0sR0FBRztZQUMxQjBMLE9BQU9ULE1BQU1oRSxJQUFJOEUsTUFBTUksS0FBS0osUUFBUTtZQUVwQyxxREFBcUQ7WUFDckQscURBQXFEO1lBQ3JELElBQUk3QyxNQUFNakMsSUFBSWtGLE9BQU8vRCxTQUFTcUQsR0FBRztnQkFDaENsQyxRQUFRO1lBQ1Q7WUFFQWtDLEtBQUt2QyxNQUFNakMsSUFBSWtGO1lBQ2ZsRixLQUFLa0Y7WUFFTCw0Q0FBNEM7WUFDNUM5QixPQUFPK0IsTUFBTSxDQUFDbkYsS0FBSyxHQUFHd0U7UUFDdkI7UUFFQSxPQUFPcEMsT0FBT3FCLGFBQWEsQ0FBQ0MsS0FBSyxDQUFDdEIsUUFBUWdCO0lBQzNDO0lBRUE7Ozs7OztDQU1DLEdBQ0QsSUFBSWdDLFNBQVMsU0FBU0EsT0FBT2QsS0FBSztRQUNqQyxJQUFJbEIsU0FBUyxFQUFFO1FBRWYsaUVBQWlFO1FBQ2pFa0IsUUFBUW5CLFdBQVdtQjtRQUVuQixvQkFBb0I7UUFDcEIsSUFBSUMsY0FBY0QsTUFBTXZMLE1BQU07UUFFOUIsd0JBQXdCO1FBQ3hCLElBQUl5TCxJQUFJOUM7UUFDUixJQUFJdUMsUUFBUTtRQUNaLElBQUlRLE9BQU9oRDtRQUVYLGdDQUFnQztRQUNoQyxJQUFJNEQsNEJBQTRCO1FBQ2hDLElBQUlDLG9CQUFvQjtRQUN4QixJQUFJQyxpQkFBaUI1TDtRQUVyQixJQUFJO1lBQ0gsSUFBSyxJQUFJNkwsWUFBWWxCLEtBQUssQ0FBQ2hFLE9BQU9DLFFBQVEsQ0FBQyxJQUFJa0YsT0FBTyxDQUFFSixDQUFBQSw0QkFBNEIsQ0FBQ0ksUUFBUUQsVUFBVS9FLElBQUksRUFBQyxFQUFHQyxJQUFJLEdBQUcyRSw0QkFBNEIsS0FBTTtnQkFDdkosSUFBSUssaUJBQWlCRCxNQUFNN0UsS0FBSztnQkFFaEMsSUFBSThFLGlCQUFpQixNQUFNO29CQUMxQnRDLE9BQU96QyxJQUFJLENBQUN3QixtQkFBbUJ1RDtnQkFDaEM7WUFDRDtRQUNELEVBQUUsT0FBTzdFLEtBQUs7WUFDYnlFLG9CQUFvQjtZQUNwQkMsaUJBQWlCMUU7UUFDbEIsU0FBVTtZQUNULElBQUk7Z0JBQ0gsSUFBSSxDQUFDd0UsNkJBQTZCRyxVQUFVRyxNQUFNLEVBQUU7b0JBQ25ESCxVQUFVRyxNQUFNO2dCQUNqQjtZQUNELFNBQVU7Z0JBQ1QsSUFBSUwsbUJBQW1CO29CQUN0QixNQUFNQztnQkFDUDtZQUNEO1FBQ0Q7UUFFQSxJQUFJSyxjQUFjeEMsT0FBT3JLLE1BQU07UUFDL0IsSUFBSThNLGlCQUFpQkQ7UUFFckIsd0VBQXdFO1FBQ3hFLG9EQUFvRDtRQUVwRCw4REFBOEQ7UUFDOUQsSUFBSUEsYUFBYTtZQUNoQnhDLE9BQU96QyxJQUFJLENBQUNnQjtRQUNiO1FBRUEsc0JBQXNCO1FBQ3RCLE1BQU9rRSxpQkFBaUJ0QixZQUFhO1lBRXBDLHlFQUF5RTtZQUN6RSxjQUFjO1lBQ2QsSUFBSXVCLElBQUkzRTtZQUNSLElBQUk0RSw2QkFBNkI7WUFDakMsSUFBSUMscUJBQXFCO1lBQ3pCLElBQUlDLGtCQUFrQnRNO1lBRXRCLElBQUk7Z0JBQ0gsSUFBSyxJQUFJdU0sYUFBYTVCLEtBQUssQ0FBQ2hFLE9BQU9DLFFBQVEsQ0FBQyxJQUFJNEYsUUFBUSxDQUFFSixDQUFBQSw2QkFBNkIsQ0FBQ0ksU0FBU0QsV0FBV3pGLElBQUksRUFBQyxFQUFHQyxJQUFJLEdBQUdxRiw2QkFBNkIsS0FBTTtvQkFDN0osSUFBSUssZUFBZUQsT0FBT3ZGLEtBQUs7b0JBRS9CLElBQUl3RixnQkFBZ0I1QixLQUFLNEIsZUFBZU4sR0FBRzt3QkFDMUNBLElBQUlNO29CQUNMO2dCQUNEO1lBRUEseUVBQXlFO1lBQ3pFLDhCQUE4QjtZQUMvQixFQUFFLE9BQU92RixLQUFLO2dCQUNibUYscUJBQXFCO2dCQUNyQkMsa0JBQWtCcEY7WUFDbkIsU0FBVTtnQkFDVCxJQUFJO29CQUNILElBQUksQ0FBQ2tGLDhCQUE4QkcsV0FBV1AsTUFBTSxFQUFFO3dCQUNyRE8sV0FBV1AsTUFBTTtvQkFDbEI7Z0JBQ0QsU0FBVTtvQkFDVCxJQUFJSyxvQkFBb0I7d0JBQ3ZCLE1BQU1DO29CQUNQO2dCQUNEO1lBQ0Q7WUFFQSxJQUFJSSx3QkFBd0JSLGlCQUFpQjtZQUM3QyxJQUFJQyxJQUFJdEIsSUFBSXZDLE1BQU0sQ0FBQ2QsU0FBUzhDLEtBQUksSUFBS29DLHdCQUF3QjtnQkFDNUQvRCxRQUFRO1lBQ1Q7WUFFQTJCLFNBQVMsQ0FBQzZCLElBQUl0QixDQUFBQSxJQUFLNkI7WUFDbkI3QixJQUFJc0I7WUFFSixJQUFJUSw2QkFBNkI7WUFDakMsSUFBSUMscUJBQXFCO1lBQ3pCLElBQUlDLGtCQUFrQjdNO1lBRXRCLElBQUk7Z0JBQ0gsSUFBSyxJQUFJOE0sYUFBYW5DLEtBQUssQ0FBQ2hFLE9BQU9DLFFBQVEsQ0FBQyxJQUFJbUcsUUFBUSxDQUFFSixDQUFBQSw2QkFBNkIsQ0FBQ0ksU0FBU0QsV0FBV2hHLElBQUksRUFBQyxFQUFHQyxJQUFJLEdBQUc0Riw2QkFBNkIsS0FBTTtvQkFDN0osSUFBSUssZ0JBQWdCRCxPQUFPOUYsS0FBSztvQkFFaEMsSUFBSStGLGdCQUFnQm5DLEtBQUssRUFBRVAsUUFBUTlDLFFBQVE7d0JBQzFDbUIsUUFBUTtvQkFDVDtvQkFDQSxJQUFJcUUsaUJBQWlCbkMsR0FBRzt3QkFDdkIsNERBQTREO3dCQUM1RCxJQUFJb0MsSUFBSTNDO3dCQUNSLElBQUssSUFBSUcsSUFBSWhELE9BQXlCZ0QsS0FBS2hELEtBQU07NEJBQ2hELElBQUk0RCxJQUFJWixLQUFLSyxPQUFPcEQsT0FBTytDLEtBQUtLLE9BQU9uRCxPQUFPQSxPQUFPOEMsSUFBSUs7NEJBQ3pELElBQUltQyxJQUFJNUIsR0FBRztnQ0FDVjs0QkFDRDs0QkFDQSxJQUFJNkIsVUFBVUQsSUFBSTVCOzRCQUNsQixJQUFJQyxhQUFhN0QsT0FBTzREOzRCQUN4QjVCLE9BQU96QyxJQUFJLENBQUN3QixtQkFBbUIwQixhQUFhbUIsSUFBSTZCLFVBQVU1QixZQUFZOzRCQUN0RTJCLElBQUkzRSxNQUFNNEUsVUFBVTVCO3dCQUNyQjt3QkFFQTdCLE9BQU96QyxJQUFJLENBQUN3QixtQkFBbUIwQixhQUFhK0MsR0FBRzt3QkFDL0NuQyxPQUFPVCxNQUFNQyxPQUFPb0MsdUJBQXVCUixrQkFBa0JEO3dCQUM3RDNCLFFBQVE7d0JBQ1IsRUFBRTRCO29CQUNIO2dCQUNEO1lBQ0QsRUFBRSxPQUFPaEYsS0FBSztnQkFDYjBGLHFCQUFxQjtnQkFDckJDLGtCQUFrQjNGO1lBQ25CLFNBQVU7Z0JBQ1QsSUFBSTtvQkFDSCxJQUFJLENBQUN5Riw4QkFBOEJHLFdBQVdkLE1BQU0sRUFBRTt3QkFDckRjLFdBQVdkLE1BQU07b0JBQ2xCO2dCQUNELFNBQVU7b0JBQ1QsSUFBSVksb0JBQW9CO3dCQUN2QixNQUFNQztvQkFDUDtnQkFDRDtZQUNEO1lBRUEsRUFBRXZDO1lBQ0YsRUFBRU87UUFDSDtRQUNBLE9BQU9wQixPQUFPOUosSUFBSSxDQUFDO0lBQ3BCO0lBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELElBQUl3TixZQUFZLFNBQVNBLFVBQVV4QyxLQUFLO1FBQ3ZDLE9BQU96QixVQUFVeUIsT0FBTyxTQUFVeEIsTUFBTTtZQUN2QyxPQUFPbEIsY0FBY21GLElBQUksQ0FBQ2pFLFVBQVV1QixPQUFPdkIsT0FBTzNKLEtBQUssQ0FBQyxHQUFHZ0IsV0FBVyxNQUFNMkk7UUFDN0U7SUFDRDtJQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxJQUFJa0UsVUFBVSxTQUFTQSxRQUFRMUMsS0FBSztRQUNuQyxPQUFPekIsVUFBVXlCLE9BQU8sU0FBVXhCLE1BQU07WUFDdkMsT0FBT2pCLGNBQWNrRixJQUFJLENBQUNqRSxVQUFVLFNBQVNzQyxPQUFPdEMsVUFBVUE7UUFDL0Q7SUFDRDtJQUVBLDRFQUE0RSxHQUU1RSwwQkFBMEIsR0FDMUIsSUFBSW1FLFdBQVc7UUFDZDs7OztFQUlDLEdBQ0QsV0FBVztRQUNYOzs7Ozs7RUFNQyxHQUNELFFBQVE7WUFDUCxVQUFVOUQ7WUFDVixVQUFVSztRQUNYO1FBQ0EsVUFBVWE7UUFDVixVQUFVZTtRQUNWLFdBQVc0QjtRQUNYLGFBQWFGO0lBQ2Q7SUFFQTs7Ozs7O0NBTUMsR0FDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQkMsR0FDRCxJQUFJSSxVQUFVLENBQUM7SUFDZixTQUFTQyxXQUFXQyxHQUFHO1FBQ25CLElBQUlDLElBQUlELElBQUk5RCxVQUFVLENBQUM7UUFDdkIsSUFBSWdFLElBQUksS0FBSztRQUNiLElBQUlELElBQUksSUFBSUMsSUFBSSxPQUFPRCxFQUFFdk4sUUFBUSxDQUFDLElBQUlNLFdBQVc7YUFBUSxJQUFJaU4sSUFBSSxLQUFLQyxJQUFJLE1BQU1ELEVBQUV2TixRQUFRLENBQUMsSUFBSU0sV0FBVzthQUFRLElBQUlpTixJQUFJLE1BQU1DLElBQUksTUFBTSxDQUFDRCxLQUFLLElBQUksR0FBRSxFQUFHdk4sUUFBUSxDQUFDLElBQUlNLFdBQVcsS0FBSyxNQUFNLENBQUNpTixJQUFJLEtBQUssR0FBRSxFQUFHdk4sUUFBUSxDQUFDLElBQUlNLFdBQVc7YUFBUWtOLElBQUksTUFBTSxDQUFDRCxLQUFLLEtBQUssR0FBRSxFQUFHdk4sUUFBUSxDQUFDLElBQUlNLFdBQVcsS0FBSyxNQUFNLENBQUNpTixLQUFLLElBQUksS0FBSyxHQUFFLEVBQUd2TixRQUFRLENBQUMsSUFBSU0sV0FBVyxLQUFLLE1BQU0sQ0FBQ2lOLElBQUksS0FBSyxHQUFFLEVBQUd2TixRQUFRLENBQUMsSUFBSU0sV0FBVztRQUN0WSxPQUFPa047SUFDWDtJQUNBLFNBQVNDLFlBQVkvTixHQUFHO1FBQ3BCLElBQUlnTyxTQUFTO1FBQ2IsSUFBSXhILElBQUk7UUFDUixJQUFJeUgsS0FBS2pPLElBQUlULE1BQU07UUFDbkIsTUFBT2lILElBQUl5SCxHQUFJO1lBQ1gsSUFBSUosSUFBSUssU0FBU2xPLElBQUltTyxNQUFNLENBQUMzSCxJQUFJLEdBQUcsSUFBSTtZQUN2QyxJQUFJcUgsSUFBSSxLQUFLO2dCQUNURyxVQUFVcEYsT0FBT0MsWUFBWSxDQUFDZ0Y7Z0JBQzlCckgsS0FBSztZQUNULE9BQU8sSUFBSXFILEtBQUssT0FBT0EsSUFBSSxLQUFLO2dCQUM1QixJQUFJSSxLQUFLekgsS0FBSyxHQUFHO29CQUNiLElBQUk0SCxLQUFLRixTQUFTbE8sSUFBSW1PLE1BQU0sQ0FBQzNILElBQUksR0FBRyxJQUFJO29CQUN4Q3dILFVBQVVwRixPQUFPQyxZQUFZLENBQUMsQ0FBQ2dGLElBQUksRUFBQyxLQUFNLElBQUlPLEtBQUs7Z0JBQ3ZELE9BQU87b0JBQ0hKLFVBQVVoTyxJQUFJbU8sTUFBTSxDQUFDM0gsR0FBRztnQkFDNUI7Z0JBQ0FBLEtBQUs7WUFDVCxPQUFPLElBQUlxSCxLQUFLLEtBQUs7Z0JBQ2pCLElBQUlJLEtBQUt6SCxLQUFLLEdBQUc7b0JBQ2IsSUFBSTZILEtBQUtILFNBQVNsTyxJQUFJbU8sTUFBTSxDQUFDM0gsSUFBSSxHQUFHLElBQUk7b0JBQ3hDLElBQUk4SCxLQUFLSixTQUFTbE8sSUFBSW1PLE1BQU0sQ0FBQzNILElBQUksR0FBRyxJQUFJO29CQUN4Q3dILFVBQVVwRixPQUFPQyxZQUFZLENBQUMsQ0FBQ2dGLElBQUksRUFBQyxLQUFNLEtBQUssQ0FBQ1EsS0FBSyxFQUFDLEtBQU0sSUFBSUMsS0FBSztnQkFDekUsT0FBTztvQkFDSE4sVUFBVWhPLElBQUltTyxNQUFNLENBQUMzSCxHQUFHO2dCQUM1QjtnQkFDQUEsS0FBSztZQUNULE9BQU87Z0JBQ0h3SCxVQUFVaE8sSUFBSW1PLE1BQU0sQ0FBQzNILEdBQUc7Z0JBQ3hCQSxLQUFLO1lBQ1Q7UUFDSjtRQUNBLE9BQU93SDtJQUNYO0lBQ0EsU0FBU08sNEJBQTRCQyxVQUFVLEVBQUVDLFFBQVE7UUFDckQsU0FBU0MsaUJBQWlCMU8sR0FBRztZQUN6QixJQUFJMk8sU0FBU1osWUFBWS9OO1lBQ3pCLE9BQU8sQ0FBQzJPLE9BQU9DLEtBQUssQ0FBQ0gsU0FBUzNJLFVBQVUsSUFBSTlGLE1BQU0yTztRQUN0RDtRQUNBLElBQUlILFdBQVdLLE1BQU0sRUFBRUwsV0FBV0ssTUFBTSxHQUFHakcsT0FBTzRGLFdBQVdLLE1BQU0sRUFBRXJGLE9BQU8sQ0FBQ2lGLFNBQVN6SSxXQUFXLEVBQUUwSSxrQkFBa0IvTixXQUFXLEdBQUc2SSxPQUFPLENBQUNpRixTQUFTcEosVUFBVSxFQUFFO1FBQ2hLLElBQUltSixXQUFXTSxRQUFRLEtBQUszTyxXQUFXcU8sV0FBV00sUUFBUSxHQUFHbEcsT0FBTzRGLFdBQVdNLFFBQVEsRUFBRXRGLE9BQU8sQ0FBQ2lGLFNBQVN6SSxXQUFXLEVBQUUwSSxrQkFBa0JsRixPQUFPLENBQUNpRixTQUFTbEosWUFBWSxFQUFFb0ksWUFBWW5FLE9BQU8sQ0FBQ2lGLFNBQVN6SSxXQUFXLEVBQUVwRjtRQUNsTixJQUFJNE4sV0FBV08sSUFBSSxLQUFLNU8sV0FBV3FPLFdBQVdPLElBQUksR0FBR25HLE9BQU80RixXQUFXTyxJQUFJLEVBQUV2RixPQUFPLENBQUNpRixTQUFTekksV0FBVyxFQUFFMEksa0JBQWtCL04sV0FBVyxHQUFHNkksT0FBTyxDQUFDaUYsU0FBU2pKLFFBQVEsRUFBRW1JLFlBQVluRSxPQUFPLENBQUNpRixTQUFTekksV0FBVyxFQUFFcEY7UUFDaE4sSUFBSTROLFdBQVdRLElBQUksS0FBSzdPLFdBQVdxTyxXQUFXUSxJQUFJLEdBQUdwRyxPQUFPNEYsV0FBV1EsSUFBSSxFQUFFeEYsT0FBTyxDQUFDaUYsU0FBU3pJLFdBQVcsRUFBRTBJLGtCQUFrQmxGLE9BQU8sQ0FBQ2dGLFdBQVdLLE1BQU0sR0FBR0osU0FBU2hKLFFBQVEsR0FBR2dKLFNBQVMvSSxpQkFBaUIsRUFBRWlJLFlBQVluRSxPQUFPLENBQUNpRixTQUFTekksV0FBVyxFQUFFcEY7UUFDblAsSUFBSTROLFdBQVdTLEtBQUssS0FBSzlPLFdBQVdxTyxXQUFXUyxLQUFLLEdBQUdyRyxPQUFPNEYsV0FBV1MsS0FBSyxFQUFFekYsT0FBTyxDQUFDaUYsU0FBU3pJLFdBQVcsRUFBRTBJLGtCQUFrQmxGLE9BQU8sQ0FBQ2lGLFNBQVM5SSxTQUFTLEVBQUVnSSxZQUFZbkUsT0FBTyxDQUFDaUYsU0FBU3pJLFdBQVcsRUFBRXBGO1FBQ3RNLElBQUk0TixXQUFXVSxRQUFRLEtBQUsvTyxXQUFXcU8sV0FBV1UsUUFBUSxHQUFHdEcsT0FBTzRGLFdBQVdVLFFBQVEsRUFBRTFGLE9BQU8sQ0FBQ2lGLFNBQVN6SSxXQUFXLEVBQUUwSSxrQkFBa0JsRixPQUFPLENBQUNpRixTQUFTN0ksWUFBWSxFQUFFK0gsWUFBWW5FLE9BQU8sQ0FBQ2lGLFNBQVN6SSxXQUFXLEVBQUVwRjtRQUNsTixPQUFPNE47SUFDWDtJQUVBLFNBQVNXLG1CQUFtQm5QLEdBQUc7UUFDM0IsT0FBT0EsSUFBSXdKLE9BQU8sQ0FBQyxXQUFXLFNBQVM7SUFDM0M7SUFDQSxTQUFTNEYsZUFBZUwsSUFBSSxFQUFFTixRQUFRO1FBQ2xDLElBQUlZLFVBQVVOLEtBQUtILEtBQUssQ0FBQ0gsU0FBU3hJLFdBQVcsS0FBSyxFQUFFO1FBRXBELElBQUlxSixXQUFXakosY0FBY2dKLFNBQVMsSUFDbENFLFVBQVVELFFBQVEsQ0FBQyxFQUFFO1FBRXpCLElBQUlDLFNBQVM7WUFDVCxPQUFPQSxRQUFRL08sS0FBSyxDQUFDLEtBQUt5SSxHQUFHLENBQUNrRyxvQkFBb0JyUCxJQUFJLENBQUM7UUFDM0QsT0FBTztZQUNILE9BQU9pUDtRQUNYO0lBQ0o7SUFDQSxTQUFTUyxlQUFlVCxJQUFJLEVBQUVOLFFBQVE7UUFDbEMsSUFBSVksVUFBVU4sS0FBS0gsS0FBSyxDQUFDSCxTQUFTdkksV0FBVyxLQUFLLEVBQUU7UUFFcEQsSUFBSXVKLFlBQVlwSixjQUFjZ0osU0FBUyxJQUNuQ0UsVUFBVUUsU0FBUyxDQUFDLEVBQUUsRUFDdEJDLE9BQU9ELFNBQVMsQ0FBQyxFQUFFO1FBRXZCLElBQUlGLFNBQVM7WUFDVCxJQUFJSSx3QkFBd0JKLFFBQVE1TyxXQUFXLEdBQUdILEtBQUssQ0FBQyxNQUFNb1AsT0FBTyxJQUNqRUMseUJBQXlCeEosY0FBY3NKLHVCQUF1QixJQUM5REcsT0FBT0Qsc0JBQXNCLENBQUMsRUFBRSxFQUNoQ0UsUUFBUUYsc0JBQXNCLENBQUMsRUFBRTtZQUVyQyxJQUFJRyxjQUFjRCxRQUFRQSxNQUFNdlAsS0FBSyxDQUFDLEtBQUt5SSxHQUFHLENBQUNrRyxzQkFBc0IsRUFBRTtZQUN2RSxJQUFJYyxhQUFhSCxLQUFLdFAsS0FBSyxDQUFDLEtBQUt5SSxHQUFHLENBQUNrRztZQUNyQyxJQUFJZSx5QkFBeUJ6QixTQUFTeEksV0FBVyxDQUFDc0gsSUFBSSxDQUFDMEMsVUFBVSxDQUFDQSxXQUFXMVEsTUFBTSxHQUFHLEVBQUU7WUFDeEYsSUFBSTRRLGFBQWFELHlCQUF5QixJQUFJO1lBQzlDLElBQUlFLGtCQUFrQkgsV0FBVzFRLE1BQU0sR0FBRzRRO1lBQzFDLElBQUlFLFNBQVM1USxNQUFNMFE7WUFDbkIsSUFBSyxJQUFJdFEsSUFBSSxHQUFHQSxJQUFJc1EsWUFBWSxFQUFFdFEsRUFBRztnQkFDakN3USxNQUFNLENBQUN4USxFQUFFLEdBQUdtUSxXQUFXLENBQUNuUSxFQUFFLElBQUlvUSxVQUFVLENBQUNHLGtCQUFrQnZRLEVBQUUsSUFBSTtZQUNyRTtZQUNBLElBQUlxUSx3QkFBd0I7Z0JBQ3hCRyxNQUFNLENBQUNGLGFBQWEsRUFBRSxHQUFHZixlQUFlaUIsTUFBTSxDQUFDRixhQUFhLEVBQUUsRUFBRTFCO1lBQ3BFO1lBQ0EsSUFBSTZCLGdCQUFnQkQsT0FBT0UsTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUMsS0FBSyxFQUFFcEYsS0FBSztnQkFDekQsSUFBSSxDQUFDb0YsU0FBU0EsVUFBVSxLQUFLO29CQUN6QixJQUFJQyxjQUFjRixHQUFHLENBQUNBLElBQUlqUixNQUFNLEdBQUcsRUFBRTtvQkFDckMsSUFBSW1SLGVBQWVBLFlBQVlyRixLQUFLLEdBQUdxRixZQUFZblIsTUFBTSxLQUFLOEwsT0FBTzt3QkFDakVxRixZQUFZblIsTUFBTTtvQkFDdEIsT0FBTzt3QkFDSGlSLElBQUlySixJQUFJLENBQUM7NEJBQUVrRSxPQUFPQTs0QkFBTzlMLFFBQVE7d0JBQUU7b0JBQ3ZDO2dCQUNKO2dCQUNBLE9BQU9pUjtZQUNYLEdBQUcsRUFBRTtZQUNMLElBQUlHLG9CQUFvQkwsY0FBY00sSUFBSSxDQUFDLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztnQkFDckQsT0FBT0EsRUFBRXZSLE1BQU0sR0FBR3NSLEVBQUV0UixNQUFNO1lBQzlCLEVBQUUsQ0FBQyxFQUFFO1lBQ0wsSUFBSXdSLFVBQVUsS0FBSztZQUNuQixJQUFJSixxQkFBcUJBLGtCQUFrQnBSLE1BQU0sR0FBRyxHQUFHO2dCQUNuRCxJQUFJeVIsV0FBV1gsT0FBTzFRLEtBQUssQ0FBQyxHQUFHZ1Isa0JBQWtCdEYsS0FBSztnQkFDdEQsSUFBSTRGLFVBQVVaLE9BQU8xUSxLQUFLLENBQUNnUixrQkFBa0J0RixLQUFLLEdBQUdzRixrQkFBa0JwUixNQUFNO2dCQUM3RXdSLFVBQVVDLFNBQVNsUixJQUFJLENBQUMsT0FBTyxPQUFPbVIsUUFBUW5SLElBQUksQ0FBQztZQUN2RCxPQUFPO2dCQUNIaVIsVUFBVVYsT0FBT3ZRLElBQUksQ0FBQztZQUMxQjtZQUNBLElBQUk0UCxNQUFNO2dCQUNOcUIsV0FBVyxNQUFNckI7WUFDckI7WUFDQSxPQUFPcUI7UUFDWCxPQUFPO1lBQ0gsT0FBT2hDO1FBQ1g7SUFDSjtJQUNBLElBQUltQyxZQUFZO0lBQ2hCLElBQUlDLHdCQUF3QixHQUFHdkMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEtBQUt6TztJQUNyRCxTQUFTaVIsTUFBTUMsU0FBUztRQUNwQixJQUFJQyxVQUFVaFMsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUthLFlBQVliLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUVuRixJQUFJa1AsYUFBYSxDQUFDO1FBQ2xCLElBQUlDLFdBQVc2QyxRQUFRQyxHQUFHLEtBQUssUUFBUW5MLGVBQWVEO1FBQ3RELElBQUltTCxRQUFRRSxTQUFTLEtBQUssVUFBVUgsWUFBWSxDQUFDQyxRQUFRekMsTUFBTSxHQUFHeUMsUUFBUXpDLE1BQU0sR0FBRyxNQUFNLEVBQUMsSUFBSyxPQUFPd0M7UUFDdEcsSUFBSWhDLFVBQVVnQyxVQUFVekMsS0FBSyxDQUFDc0M7UUFDOUIsSUFBSTdCLFNBQVM7WUFDVCxJQUFJOEIsdUJBQXVCO2dCQUN2QixzQkFBc0I7Z0JBQ3RCM0MsV0FBV0ssTUFBTSxHQUFHUSxPQUFPLENBQUMsRUFBRTtnQkFDOUJiLFdBQVdNLFFBQVEsR0FBR08sT0FBTyxDQUFDLEVBQUU7Z0JBQ2hDYixXQUFXTyxJQUFJLEdBQUdNLE9BQU8sQ0FBQyxFQUFFO2dCQUM1QmIsV0FBV2lELElBQUksR0FBR3ZELFNBQVNtQixPQUFPLENBQUMsRUFBRSxFQUFFO2dCQUN2Q2IsV0FBV1EsSUFBSSxHQUFHSyxPQUFPLENBQUMsRUFBRSxJQUFJO2dCQUNoQ2IsV0FBV1MsS0FBSyxHQUFHSSxPQUFPLENBQUMsRUFBRTtnQkFDN0JiLFdBQVdVLFFBQVEsR0FBR0csT0FBTyxDQUFDLEVBQUU7Z0JBQ2hDLGlCQUFpQjtnQkFDakIsSUFBSXFDLE1BQU1sRCxXQUFXaUQsSUFBSSxHQUFHO29CQUN4QmpELFdBQVdpRCxJQUFJLEdBQUdwQyxPQUFPLENBQUMsRUFBRTtnQkFDaEM7WUFDSixPQUFPO2dCQUNILHFDQUFxQztnQkFDckMsc0JBQXNCO2dCQUN0QmIsV0FBV0ssTUFBTSxHQUFHUSxPQUFPLENBQUMsRUFBRSxJQUFJbFA7Z0JBQ2xDcU8sV0FBV00sUUFBUSxHQUFHdUMsVUFBVU0sT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJdEMsT0FBTyxDQUFDLEVBQUUsR0FBR2xQO2dCQUNuRXFPLFdBQVdPLElBQUksR0FBR3NDLFVBQVVNLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSXRDLE9BQU8sQ0FBQyxFQUFFLEdBQUdsUDtnQkFDaEVxTyxXQUFXaUQsSUFBSSxHQUFHdkQsU0FBU21CLE9BQU8sQ0FBQyxFQUFFLEVBQUU7Z0JBQ3ZDYixXQUFXUSxJQUFJLEdBQUdLLE9BQU8sQ0FBQyxFQUFFLElBQUk7Z0JBQ2hDYixXQUFXUyxLQUFLLEdBQUdvQyxVQUFVTSxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUl0QyxPQUFPLENBQUMsRUFBRSxHQUFHbFA7Z0JBQ2hFcU8sV0FBV1UsUUFBUSxHQUFHbUMsVUFBVU0sT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJdEMsT0FBTyxDQUFDLEVBQUUsR0FBR2xQO2dCQUNuRSxpQkFBaUI7Z0JBQ2pCLElBQUl1UixNQUFNbEQsV0FBV2lELElBQUksR0FBRztvQkFDeEJqRCxXQUFXaUQsSUFBSSxHQUFHSixVQUFVekMsS0FBSyxDQUFDLG1DQUFtQ1MsT0FBTyxDQUFDLEVBQUUsR0FBR2xQO2dCQUN0RjtZQUNKO1lBQ0EsSUFBSXFPLFdBQVdPLElBQUksRUFBRTtnQkFDakIsb0JBQW9CO2dCQUNwQlAsV0FBV08sSUFBSSxHQUFHUyxlQUFlSixlQUFlWixXQUFXTyxJQUFJLEVBQUVOLFdBQVdBO1lBQ2hGO1lBQ0EsMEJBQTBCO1lBQzFCLElBQUlELFdBQVdLLE1BQU0sS0FBSzFPLGFBQWFxTyxXQUFXTSxRQUFRLEtBQUszTyxhQUFhcU8sV0FBV08sSUFBSSxLQUFLNU8sYUFBYXFPLFdBQVdpRCxJQUFJLEtBQUt0UixhQUFhLENBQUNxTyxXQUFXUSxJQUFJLElBQUlSLFdBQVdTLEtBQUssS0FBSzlPLFdBQVc7Z0JBQzlMcU8sV0FBV2dELFNBQVMsR0FBRztZQUMzQixPQUFPLElBQUloRCxXQUFXSyxNQUFNLEtBQUsxTyxXQUFXO2dCQUN4Q3FPLFdBQVdnRCxTQUFTLEdBQUc7WUFDM0IsT0FBTyxJQUFJaEQsV0FBV1UsUUFBUSxLQUFLL08sV0FBVztnQkFDMUNxTyxXQUFXZ0QsU0FBUyxHQUFHO1lBQzNCLE9BQU87Z0JBQ0hoRCxXQUFXZ0QsU0FBUyxHQUFHO1lBQzNCO1lBQ0EsNEJBQTRCO1lBQzVCLElBQUlGLFFBQVFFLFNBQVMsSUFBSUYsUUFBUUUsU0FBUyxLQUFLLFlBQVlGLFFBQVFFLFNBQVMsS0FBS2hELFdBQVdnRCxTQUFTLEVBQUU7Z0JBQ25HaEQsV0FBV29ELEtBQUssR0FBR3BELFdBQVdvRCxLQUFLLElBQUksa0JBQWtCTixRQUFRRSxTQUFTLEdBQUc7WUFDakY7WUFDQSxxQkFBcUI7WUFDckIsSUFBSUssZ0JBQWdCbkUsT0FBTyxDQUFDLENBQUM0RCxRQUFRekMsTUFBTSxJQUFJTCxXQUFXSyxNQUFNLElBQUksRUFBQyxFQUFHbE8sV0FBVyxHQUFHO1lBQ3RGLG1DQUFtQztZQUNuQyxJQUFJLENBQUMyUSxRQUFRUSxjQUFjLElBQUssRUFBQ0QsaUJBQWlCLENBQUNBLGNBQWNDLGNBQWMsR0FBRztnQkFDOUUsb0NBQW9DO2dCQUNwQyxJQUFJdEQsV0FBV08sSUFBSSxJQUFLdUMsQ0FBQUEsUUFBUVMsVUFBVSxJQUFJRixpQkFBaUJBLGNBQWNFLFVBQVUsR0FBRztvQkFDdEYsa0NBQWtDO29CQUNsQyxJQUFJO3dCQUNBdkQsV0FBV08sSUFBSSxHQUFHdEIsU0FBU0QsT0FBTyxDQUFDZ0IsV0FBV08sSUFBSSxDQUFDdkYsT0FBTyxDQUFDaUYsU0FBU3pJLFdBQVcsRUFBRStILGFBQWFwTixXQUFXO29CQUM3RyxFQUFFLE9BQU9tTixHQUFHO3dCQUNSVSxXQUFXb0QsS0FBSyxHQUFHcEQsV0FBV29ELEtBQUssSUFBSSxvRUFBb0U5RDtvQkFDL0c7Z0JBQ0o7Z0JBQ0Esb0JBQW9CO2dCQUNwQlMsNEJBQTRCQyxZQUFZckk7WUFDNUMsT0FBTztnQkFDSCxxQkFBcUI7Z0JBQ3JCb0ksNEJBQTRCQyxZQUFZQztZQUM1QztZQUNBLGlDQUFpQztZQUNqQyxJQUFJb0QsaUJBQWlCQSxjQUFjVCxLQUFLLEVBQUU7Z0JBQ3RDUyxjQUFjVCxLQUFLLENBQUM1QyxZQUFZOEM7WUFDcEM7UUFDSixPQUFPO1lBQ0g5QyxXQUFXb0QsS0FBSyxHQUFHcEQsV0FBV29ELEtBQUssSUFBSTtRQUMzQztRQUNBLE9BQU9wRDtJQUNYO0lBRUEsU0FBU3dELG9CQUFvQnhELFVBQVUsRUFBRThDLE9BQU87UUFDNUMsSUFBSTdDLFdBQVc2QyxRQUFRQyxHQUFHLEtBQUssUUFBUW5MLGVBQWVEO1FBQ3RELElBQUk4TCxZQUFZLEVBQUU7UUFDbEIsSUFBSXpELFdBQVdNLFFBQVEsS0FBSzNPLFdBQVc7WUFDbkM4UixVQUFVOUssSUFBSSxDQUFDcUgsV0FBV00sUUFBUTtZQUNsQ21ELFVBQVU5SyxJQUFJLENBQUM7UUFDbkI7UUFDQSxJQUFJcUgsV0FBV08sSUFBSSxLQUFLNU8sV0FBVztZQUMvQixxRUFBcUU7WUFDckU4UixVQUFVOUssSUFBSSxDQUFDcUksZUFBZUosZUFBZXhHLE9BQU80RixXQUFXTyxJQUFJLEdBQUdOLFdBQVdBLFVBQVVqRixPQUFPLENBQUNpRixTQUFTdkksV0FBVyxFQUFFLFNBQVVnTSxDQUFDLEVBQUVDLEVBQUUsRUFBRUMsRUFBRTtnQkFDeEksT0FBTyxNQUFNRCxLQUFNQyxDQUFBQSxLQUFLLFFBQVFBLEtBQUssRUFBQyxJQUFLO1lBQy9DO1FBQ0o7UUFDQSxJQUFJLE9BQU81RCxXQUFXaUQsSUFBSSxLQUFLLFlBQVksT0FBT2pELFdBQVdpRCxJQUFJLEtBQUssVUFBVTtZQUM1RVEsVUFBVTlLLElBQUksQ0FBQztZQUNmOEssVUFBVTlLLElBQUksQ0FBQ3lCLE9BQU80RixXQUFXaUQsSUFBSTtRQUN6QztRQUNBLE9BQU9RLFVBQVUxUyxNQUFNLEdBQUcwUyxVQUFVblMsSUFBSSxDQUFDLE1BQU1LO0lBQ25EO0lBRUEsSUFBSWtTLE9BQU87SUFDWCxJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsT0FBTztJQUNYLElBQUlDLE9BQU87SUFDWCxTQUFTQyxrQkFBa0IzSCxLQUFLO1FBQzVCLElBQUlsQixTQUFTLEVBQUU7UUFDZixNQUFPa0IsTUFBTXZMLE1BQU0sQ0FBRTtZQUNqQixJQUFJdUwsTUFBTThELEtBQUssQ0FBQ3lELE9BQU87Z0JBQ25CdkgsUUFBUUEsTUFBTXRCLE9BQU8sQ0FBQzZJLE1BQU07WUFDaEMsT0FBTyxJQUFJdkgsTUFBTThELEtBQUssQ0FBQzBELE9BQU87Z0JBQzFCeEgsUUFBUUEsTUFBTXRCLE9BQU8sQ0FBQzhJLE1BQU07WUFDaEMsT0FBTyxJQUFJeEgsTUFBTThELEtBQUssQ0FBQzJELE9BQU87Z0JBQzFCekgsUUFBUUEsTUFBTXRCLE9BQU8sQ0FBQytJLE1BQU07Z0JBQzVCM0ksT0FBT25KLEdBQUc7WUFDZCxPQUFPLElBQUlxSyxVQUFVLE9BQU9BLFVBQVUsTUFBTTtnQkFDeENBLFFBQVE7WUFDWixPQUFPO2dCQUNILElBQUk0SCxLQUFLNUgsTUFBTThELEtBQUssQ0FBQzREO2dCQUNyQixJQUFJRSxJQUFJO29CQUNKLElBQUlDLElBQUlELEVBQUUsQ0FBQyxFQUFFO29CQUNiNUgsUUFBUUEsTUFBTW5MLEtBQUssQ0FBQ2dULEVBQUVwVCxNQUFNO29CQUM1QnFLLE9BQU96QyxJQUFJLENBQUN3TDtnQkFDaEIsT0FBTztvQkFDSCxNQUFNLElBQUlDLE1BQU07Z0JBQ3BCO1lBQ0o7UUFDSjtRQUNBLE9BQU9oSixPQUFPOUosSUFBSSxDQUFDO0lBQ3ZCO0lBRUEsU0FBUytTLFVBQVVyRSxVQUFVO1FBQ3pCLElBQUk4QyxVQUFVaFMsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUthLFlBQVliLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUVuRixJQUFJbVAsV0FBVzZDLFFBQVFDLEdBQUcsR0FBR25MLGVBQWVEO1FBQzVDLElBQUk4TCxZQUFZLEVBQUU7UUFDbEIscUJBQXFCO1FBQ3JCLElBQUlKLGdCQUFnQm5FLE9BQU8sQ0FBQyxDQUFDNEQsUUFBUXpDLE1BQU0sSUFBSUwsV0FBV0ssTUFBTSxJQUFJLEVBQUMsRUFBR2xPLFdBQVcsR0FBRztRQUN0Rix1Q0FBdUM7UUFDdkMsSUFBSWtSLGlCQUFpQkEsY0FBY2dCLFNBQVMsRUFBRWhCLGNBQWNnQixTQUFTLENBQUNyRSxZQUFZOEM7UUFDbEYsSUFBSTlDLFdBQVdPLElBQUksRUFBRTtZQUNqQixzQ0FBc0M7WUFDdEMsSUFBSU4sU0FBU3ZJLFdBQVcsQ0FBQ3FILElBQUksQ0FBQ2lCLFdBQVdPLElBQUksR0FBRyxDQUFDLE9BSTVDLElBQUl1QyxRQUFRUyxVQUFVLElBQUlGLGlCQUFpQkEsY0FBY0UsVUFBVSxFQUFFO2dCQUNsRSwwQkFBMEI7Z0JBQzFCLElBQUk7b0JBQ0F2RCxXQUFXTyxJQUFJLEdBQUcsQ0FBQ3VDLFFBQVFDLEdBQUcsR0FBRzlELFNBQVNELE9BQU8sQ0FBQ2dCLFdBQVdPLElBQUksQ0FBQ3ZGLE9BQU8sQ0FBQ2lGLFNBQVN6SSxXQUFXLEVBQUUrSCxhQUFhcE4sV0FBVyxNQUFNOE0sU0FBU0gsU0FBUyxDQUFDa0IsV0FBV08sSUFBSTtnQkFDcEssRUFBRSxPQUFPakIsR0FBRztvQkFDUlUsV0FBV29ELEtBQUssR0FBR3BELFdBQVdvRCxLQUFLLElBQUksZ0RBQWlELEVBQUNOLFFBQVFDLEdBQUcsR0FBRyxVQUFVLFNBQVEsSUFBSyxvQkFBb0J6RDtnQkFDdEo7WUFDSjtRQUNSO1FBQ0Esb0JBQW9CO1FBQ3BCUyw0QkFBNEJDLFlBQVlDO1FBQ3hDLElBQUk2QyxRQUFRRSxTQUFTLEtBQUssWUFBWWhELFdBQVdLLE1BQU0sRUFBRTtZQUNyRG9ELFVBQVU5SyxJQUFJLENBQUNxSCxXQUFXSyxNQUFNO1lBQ2hDb0QsVUFBVTlLLElBQUksQ0FBQztRQUNuQjtRQUNBLElBQUkyTCxZQUFZZCxvQkFBb0J4RCxZQUFZOEM7UUFDaEQsSUFBSXdCLGNBQWMzUyxXQUFXO1lBQ3pCLElBQUltUixRQUFRRSxTQUFTLEtBQUssVUFBVTtnQkFDaENTLFVBQVU5SyxJQUFJLENBQUM7WUFDbkI7WUFDQThLLFVBQVU5SyxJQUFJLENBQUMyTDtZQUNmLElBQUl0RSxXQUFXUSxJQUFJLElBQUlSLFdBQVdRLElBQUksQ0FBQytELE1BQU0sQ0FBQyxPQUFPLEtBQUs7Z0JBQ3REZCxVQUFVOUssSUFBSSxDQUFDO1lBQ25CO1FBQ0o7UUFDQSxJQUFJcUgsV0FBV1EsSUFBSSxLQUFLN08sV0FBVztZQUMvQixJQUFJd1MsSUFBSW5FLFdBQVdRLElBQUk7WUFDdkIsSUFBSSxDQUFDc0MsUUFBUTBCLFlBQVksSUFBSyxFQUFDbkIsaUJBQWlCLENBQUNBLGNBQWNtQixZQUFZLEdBQUc7Z0JBQzFFTCxJQUFJRixrQkFBa0JFO1lBQzFCO1lBQ0EsSUFBSUcsY0FBYzNTLFdBQVc7Z0JBQ3pCd1MsSUFBSUEsRUFBRW5KLE9BQU8sQ0FBQyxTQUFTLFNBQVMseUNBQXlDO1lBQzdFO1lBQ0F5SSxVQUFVOUssSUFBSSxDQUFDd0w7UUFDbkI7UUFDQSxJQUFJbkUsV0FBV1MsS0FBSyxLQUFLOU8sV0FBVztZQUNoQzhSLFVBQVU5SyxJQUFJLENBQUM7WUFDZjhLLFVBQVU5SyxJQUFJLENBQUNxSCxXQUFXUyxLQUFLO1FBQ25DO1FBQ0EsSUFBSVQsV0FBV1UsUUFBUSxLQUFLL08sV0FBVztZQUNuQzhSLFVBQVU5SyxJQUFJLENBQUM7WUFDZjhLLFVBQVU5SyxJQUFJLENBQUNxSCxXQUFXVSxRQUFRO1FBQ3RDO1FBQ0EsT0FBTytDLFVBQVVuUyxJQUFJLENBQUMsS0FBSyw0QkFBNEI7SUFDM0Q7SUFFQSxTQUFTbVQsa0JBQWtCckwsSUFBSSxFQUFFc0wsUUFBUTtRQUNyQyxJQUFJNUIsVUFBVWhTLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLYSxZQUFZYixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSTZULG9CQUFvQjdULFNBQVMsQ0FBQyxFQUFFO1FBRXBDLElBQUkyQixTQUFTLENBQUM7UUFDZCxJQUFJLENBQUNrUyxtQkFBbUI7WUFDcEJ2TCxPQUFPd0osTUFBTXlCLFVBQVVqTCxNQUFNMEosVUFBVUEsVUFBVSwyQkFBMkI7WUFDNUU0QixXQUFXOUIsTUFBTXlCLFVBQVVLLFVBQVU1QixVQUFVQSxVQUFVLCtCQUErQjtRQUM1RjtRQUNBQSxVQUFVQSxXQUFXLENBQUM7UUFDdEIsSUFBSSxDQUFDQSxRQUFROEIsUUFBUSxJQUFJRixTQUFTckUsTUFBTSxFQUFFO1lBQ3RDNU4sT0FBTzROLE1BQU0sR0FBR3FFLFNBQVNyRSxNQUFNO1lBQy9CLHdDQUF3QztZQUN4QzVOLE9BQU82TixRQUFRLEdBQUdvRSxTQUFTcEUsUUFBUTtZQUNuQzdOLE9BQU84TixJQUFJLEdBQUdtRSxTQUFTbkUsSUFBSTtZQUMzQjlOLE9BQU93USxJQUFJLEdBQUd5QixTQUFTekIsSUFBSTtZQUMzQnhRLE9BQU8rTixJQUFJLEdBQUd5RCxrQkFBa0JTLFNBQVNsRSxJQUFJLElBQUk7WUFDakQvTixPQUFPZ08sS0FBSyxHQUFHaUUsU0FBU2pFLEtBQUs7UUFDakMsT0FBTztZQUNILElBQUlpRSxTQUFTcEUsUUFBUSxLQUFLM08sYUFBYStTLFNBQVNuRSxJQUFJLEtBQUs1TyxhQUFhK1MsU0FBU3pCLElBQUksS0FBS3RSLFdBQVc7Z0JBQy9GLHdDQUF3QztnQkFDeENjLE9BQU82TixRQUFRLEdBQUdvRSxTQUFTcEUsUUFBUTtnQkFDbkM3TixPQUFPOE4sSUFBSSxHQUFHbUUsU0FBU25FLElBQUk7Z0JBQzNCOU4sT0FBT3dRLElBQUksR0FBR3lCLFNBQVN6QixJQUFJO2dCQUMzQnhRLE9BQU8rTixJQUFJLEdBQUd5RCxrQkFBa0JTLFNBQVNsRSxJQUFJLElBQUk7Z0JBQ2pEL04sT0FBT2dPLEtBQUssR0FBR2lFLFNBQVNqRSxLQUFLO1lBQ2pDLE9BQU87Z0JBQ0gsSUFBSSxDQUFDaUUsU0FBU2xFLElBQUksRUFBRTtvQkFDaEIvTixPQUFPK04sSUFBSSxHQUFHcEgsS0FBS29ILElBQUk7b0JBQ3ZCLElBQUlrRSxTQUFTakUsS0FBSyxLQUFLOU8sV0FBVzt3QkFDOUJjLE9BQU9nTyxLQUFLLEdBQUdpRSxTQUFTakUsS0FBSztvQkFDakMsT0FBTzt3QkFDSGhPLE9BQU9nTyxLQUFLLEdBQUdySCxLQUFLcUgsS0FBSztvQkFDN0I7Z0JBQ0osT0FBTztvQkFDSCxJQUFJaUUsU0FBU2xFLElBQUksQ0FBQytELE1BQU0sQ0FBQyxPQUFPLEtBQUs7d0JBQ2pDOVIsT0FBTytOLElBQUksR0FBR3lELGtCQUFrQlMsU0FBU2xFLElBQUk7b0JBQ2pELE9BQU87d0JBQ0gsSUFBSSxDQUFDcEgsS0FBS2tILFFBQVEsS0FBSzNPLGFBQWF5SCxLQUFLbUgsSUFBSSxLQUFLNU8sYUFBYXlILEtBQUs2SixJQUFJLEtBQUt0UixTQUFRLEtBQU0sQ0FBQ3lILEtBQUtvSCxJQUFJLEVBQUU7NEJBQ25HL04sT0FBTytOLElBQUksR0FBRyxNQUFNa0UsU0FBU2xFLElBQUk7d0JBQ3JDLE9BQU8sSUFBSSxDQUFDcEgsS0FBS29ILElBQUksRUFBRTs0QkFDbkIvTixPQUFPK04sSUFBSSxHQUFHa0UsU0FBU2xFLElBQUk7d0JBQy9CLE9BQU87NEJBQ0gvTixPQUFPK04sSUFBSSxHQUFHcEgsS0FBS29ILElBQUksQ0FBQ3JQLEtBQUssQ0FBQyxHQUFHaUksS0FBS29ILElBQUksQ0FBQzdELFdBQVcsQ0FBQyxPQUFPLEtBQUsrSCxTQUFTbEUsSUFBSTt3QkFDcEY7d0JBQ0EvTixPQUFPK04sSUFBSSxHQUFHeUQsa0JBQWtCeFIsT0FBTytOLElBQUk7b0JBQy9DO29CQUNBL04sT0FBT2dPLEtBQUssR0FBR2lFLFNBQVNqRSxLQUFLO2dCQUNqQztnQkFDQSxvQ0FBb0M7Z0JBQ3BDaE8sT0FBTzZOLFFBQVEsR0FBR2xILEtBQUtrSCxRQUFRO2dCQUMvQjdOLE9BQU84TixJQUFJLEdBQUduSCxLQUFLbUgsSUFBSTtnQkFDdkI5TixPQUFPd1EsSUFBSSxHQUFHN0osS0FBSzZKLElBQUk7WUFDM0I7WUFDQXhRLE9BQU80TixNQUFNLEdBQUdqSCxLQUFLaUgsTUFBTTtRQUMvQjtRQUNBNU4sT0FBT2lPLFFBQVEsR0FBR2dFLFNBQVNoRSxRQUFRO1FBQ25DLE9BQU9qTztJQUNYO0lBRUEsU0FBU29TLFFBQVFDLE9BQU8sRUFBRUMsV0FBVyxFQUFFakMsT0FBTztRQUMxQyxJQUFJa0Msb0JBQW9CeFMsT0FBTztZQUFFNk4sUUFBUTtRQUFPLEdBQUd5QztRQUNuRCxPQUFPdUIsVUFBVUksa0JBQWtCN0IsTUFBTWtDLFNBQVNFLG9CQUFvQnBDLE1BQU1tQyxhQUFhQyxvQkFBb0JBLG1CQUFtQixPQUFPQTtJQUMzSTtJQUVBLFNBQVNDLFVBQVVDLEdBQUcsRUFBRXBDLE9BQU87UUFDM0IsSUFBSSxPQUFPb0MsUUFBUSxVQUFVO1lBQ3pCQSxNQUFNYixVQUFVekIsTUFBTXNDLEtBQUtwQyxVQUFVQTtRQUN6QyxPQUFPLElBQUlyUixPQUFPeVQsU0FBUyxVQUFVO1lBQ2pDQSxNQUFNdEMsTUFBTXlCLFVBQVVhLEtBQUtwQyxVQUFVQTtRQUN6QztRQUNBLE9BQU9vQztJQUNYO0lBRUEsU0FBU0MsTUFBTUMsSUFBSSxFQUFFQyxJQUFJLEVBQUV2QyxPQUFPO1FBQzlCLElBQUksT0FBT3NDLFNBQVMsVUFBVTtZQUMxQkEsT0FBT2YsVUFBVXpCLE1BQU13QyxNQUFNdEMsVUFBVUE7UUFDM0MsT0FBTyxJQUFJclIsT0FBTzJULFVBQVUsVUFBVTtZQUNsQ0EsT0FBT2YsVUFBVWUsTUFBTXRDO1FBQzNCO1FBQ0EsSUFBSSxPQUFPdUMsU0FBUyxVQUFVO1lBQzFCQSxPQUFPaEIsVUFBVXpCLE1BQU15QyxNQUFNdkMsVUFBVUE7UUFDM0MsT0FBTyxJQUFJclIsT0FBTzRULFVBQVUsVUFBVTtZQUNsQ0EsT0FBT2hCLFVBQVVnQixNQUFNdkM7UUFDM0I7UUFDQSxPQUFPc0MsU0FBU0M7SUFDcEI7SUFFQSxTQUFTQyxnQkFBZ0I5VCxHQUFHLEVBQUVzUixPQUFPO1FBQ2pDLE9BQU90UixPQUFPQSxJQUFJTSxRQUFRLEdBQUdrSixPQUFPLENBQUMsQ0FBQzhILFdBQVcsQ0FBQ0EsUUFBUUMsR0FBRyxHQUFHcEwsYUFBYU4sTUFBTSxHQUFHTyxhQUFhUCxNQUFNLEVBQUU4SDtJQUMvRztJQUVBLFNBQVNvRyxrQkFBa0IvVCxHQUFHLEVBQUVzUixPQUFPO1FBQ25DLE9BQU90UixPQUFPQSxJQUFJTSxRQUFRLEdBQUdrSixPQUFPLENBQUMsQ0FBQzhILFdBQVcsQ0FBQ0EsUUFBUUMsR0FBRyxHQUFHcEwsYUFBYUgsV0FBVyxHQUFHSSxhQUFhSixXQUFXLEVBQUUrSDtJQUN6SDtJQUVBLElBQUlpRyxVQUFVO1FBQ1ZuRixRQUFRO1FBQ1JrRCxZQUFZO1FBQ1pYLE9BQU8sU0FBU0EsTUFBTTVDLFVBQVUsRUFBRThDLE9BQU87WUFDckMscUJBQXFCO1lBQ3JCLElBQUksQ0FBQzlDLFdBQVdPLElBQUksRUFBRTtnQkFDbEJQLFdBQVdvRCxLQUFLLEdBQUdwRCxXQUFXb0QsS0FBSyxJQUFJO1lBQzNDO1lBQ0EsT0FBT3BEO1FBQ1g7UUFDQXFFLFdBQVcsU0FBU0EsVUFBVXJFLFVBQVUsRUFBRThDLE9BQU87WUFDN0MsSUFBSTJDLFNBQVNyTCxPQUFPNEYsV0FBV0ssTUFBTSxFQUFFbE8sV0FBVyxPQUFPO1lBQ3pELDRCQUE0QjtZQUM1QixJQUFJNk4sV0FBV2lELElBQUksS0FBTXdDLENBQUFBLFNBQVMsTUFBTSxFQUFDLEtBQU16RixXQUFXaUQsSUFBSSxLQUFLLElBQUk7Z0JBQ25FakQsV0FBV2lELElBQUksR0FBR3RSO1lBQ3RCO1lBQ0EsMEJBQTBCO1lBQzFCLElBQUksQ0FBQ3FPLFdBQVdRLElBQUksRUFBRTtnQkFDbEJSLFdBQVdRLElBQUksR0FBRztZQUN0QjtZQUNBLG1EQUFtRDtZQUNuRCxvRUFBb0U7WUFDcEUsd0JBQXdCO1lBQ3hCLE9BQU9SO1FBQ1g7SUFDSjtJQUVBLElBQUkwRixZQUFZO1FBQ1pyRixRQUFRO1FBQ1JrRCxZQUFZaUMsUUFBUWpDLFVBQVU7UUFDOUJYLE9BQU80QyxRQUFRNUMsS0FBSztRQUNwQnlCLFdBQVdtQixRQUFRbkIsU0FBUztJQUNoQztJQUVBLFNBQVNzQixTQUFTQyxZQUFZO1FBQzFCLE9BQU8sT0FBT0EsYUFBYUgsTUFBTSxLQUFLLFlBQVlHLGFBQWFILE1BQU0sR0FBR3JMLE9BQU93TCxhQUFhdkYsTUFBTSxFQUFFbE8sV0FBVyxPQUFPO0lBQzFIO0lBQ0EsVUFBVTtJQUNWLElBQUkwVCxZQUFZO1FBQ1p4RixRQUFRO1FBQ1JrRCxZQUFZO1FBQ1pYLE9BQU8sU0FBU0EsTUFBTTVDLFVBQVUsRUFBRThDLE9BQU87WUFDckMsSUFBSThDLGVBQWU1RjtZQUNuQixvQ0FBb0M7WUFDcEM0RixhQUFhSCxNQUFNLEdBQUdFLFNBQVNDO1lBQy9CLHdCQUF3QjtZQUN4QkEsYUFBYUUsWUFBWSxHQUFHLENBQUNGLGFBQWFwRixJQUFJLElBQUksR0FBRSxJQUFNb0YsQ0FBQUEsYUFBYW5GLEtBQUssR0FBRyxNQUFNbUYsYUFBYW5GLEtBQUssR0FBRyxFQUFDO1lBQzNHbUYsYUFBYXBGLElBQUksR0FBRzdPO1lBQ3BCaVUsYUFBYW5GLEtBQUssR0FBRzlPO1lBQ3JCLE9BQU9pVTtRQUNYO1FBQ0F2QixXQUFXLFNBQVNBLFVBQVV1QixZQUFZLEVBQUU5QyxPQUFPO1lBQy9DLDRCQUE0QjtZQUM1QixJQUFJOEMsYUFBYTNDLElBQUksS0FBTTBDLENBQUFBLFNBQVNDLGdCQUFnQixNQUFNLEVBQUMsS0FBTUEsYUFBYTNDLElBQUksS0FBSyxJQUFJO2dCQUN2RjJDLGFBQWEzQyxJQUFJLEdBQUd0UjtZQUN4QjtZQUNBLG1DQUFtQztZQUNuQyxJQUFJLE9BQU9pVSxhQUFhSCxNQUFNLEtBQUssV0FBVztnQkFDMUNHLGFBQWF2RixNQUFNLEdBQUd1RixhQUFhSCxNQUFNLEdBQUcsUUFBUTtnQkFDcERHLGFBQWFILE1BQU0sR0FBRzlUO1lBQzFCO1lBQ0EscUNBQXFDO1lBQ3JDLElBQUlpVSxhQUFhRSxZQUFZLEVBQUU7Z0JBQzNCLElBQUlDLHdCQUF3QkgsYUFBYUUsWUFBWSxDQUFDOVQsS0FBSyxDQUFDLE1BQ3hEZ1UseUJBQXlCbk8sY0FBY2tPLHVCQUF1QixJQUM5RHZGLE9BQU93RixzQkFBc0IsQ0FBQyxFQUFFLEVBQ2hDdkYsUUFBUXVGLHNCQUFzQixDQUFDLEVBQUU7Z0JBRXJDSixhQUFhcEYsSUFBSSxHQUFHQSxRQUFRQSxTQUFTLE1BQU1BLE9BQU83TztnQkFDbERpVSxhQUFhbkYsS0FBSyxHQUFHQTtnQkFDckJtRixhQUFhRSxZQUFZLEdBQUduVTtZQUNoQztZQUNBLDJCQUEyQjtZQUMzQmlVLGFBQWFsRixRQUFRLEdBQUcvTztZQUN4QixPQUFPaVU7UUFDWDtJQUNKO0lBRUEsSUFBSUssWUFBWTtRQUNaNUYsUUFBUTtRQUNSa0QsWUFBWXNDLFVBQVV0QyxVQUFVO1FBQ2hDWCxPQUFPaUQsVUFBVWpELEtBQUs7UUFDdEJ5QixXQUFXd0IsVUFBVXhCLFNBQVM7SUFDbEM7SUFFQSxJQUFJNkIsSUFBSSxDQUFDO0lBQ1QsSUFBSXJULFFBQVE7SUFDWixVQUFVO0lBQ1YsSUFBSWMsZUFBZSwyQkFBNEJkLENBQUFBLFFBQVEsOEVBQThFLEVBQUMsSUFBSztJQUMzSSxJQUFJSyxXQUFXLGVBQWUsa0JBQWtCO0lBQ2hELElBQUlHLGVBQWU5QixPQUFPQSxPQUFPLFlBQVkyQixXQUFXLE1BQU1BLFdBQVdBLFdBQVcsTUFBTUEsV0FBV0EsWUFBWSxNQUFNM0IsT0FBTyxnQkFBZ0IyQixXQUFXLE1BQU1BLFdBQVdBLFlBQVksTUFBTTNCLE9BQU8sTUFBTTJCLFdBQVdBLFlBQVksVUFBVTtJQUMxTyxxRUFBcUU7SUFDckUseUZBQXlGO0lBQ3pGLCtCQUErQjtJQUMvQix1R0FBdUc7SUFDdkcsK0dBQStHO0lBQy9HLGtDQUFrQztJQUNsQywrQkFBK0I7SUFDL0Isd0dBQXdHO0lBQ3hHLDhFQUE4RTtJQUM5RSw4RkFBOEY7SUFDOUYsbUdBQW1HO0lBQ25HLElBQUlpVCxVQUFVO0lBQ2QsSUFBSUMsVUFBVTtJQUNkLElBQUlDLFVBQVV6VixNQUFNd1YsU0FBUztJQUM3QixJQUFJRSxnQkFBZ0I7SUFDcEIsSUFBSWhQLGFBQWEsSUFBSVIsT0FBT25ELGNBQWM7SUFDMUMsSUFBSTZELGNBQWMsSUFBSVYsT0FBT3pELGNBQWM7SUFDM0MsSUFBSWtULGlCQUFpQixJQUFJelAsT0FBT2xHLE1BQU0sT0FBT3VWLFNBQVMsU0FBUyxTQUFTRSxVQUFVO0lBQ2xGLElBQUlHLGFBQWEsSUFBSTFQLE9BQU9sRyxNQUFNLE9BQU8rQyxjQUFjMlMsZ0JBQWdCO0lBQ3ZFLElBQUlHLGNBQWNEO0lBQ2xCLFNBQVN0RyxpQkFBaUIxTyxHQUFHO1FBQ3pCLElBQUkyTyxTQUFTWixZQUFZL047UUFDekIsT0FBTyxDQUFDMk8sT0FBT0MsS0FBSyxDQUFDOUksY0FBYzlGLE1BQU0yTztJQUM3QztJQUNBLElBQUl1RyxZQUFZO1FBQ1pyRyxRQUFRO1FBQ1J1QyxPQUFPLFNBQVMrRCxTQUFTM0csVUFBVSxFQUFFOEMsT0FBTztZQUN4QyxJQUFJOEQsbUJBQW1CNUc7WUFDdkIsSUFBSTZHLEtBQUtELGlCQUFpQkMsRUFBRSxHQUFHRCxpQkFBaUJwRyxJQUFJLEdBQUdvRyxpQkFBaUJwRyxJQUFJLENBQUN4TyxLQUFLLENBQUMsT0FBTyxFQUFFO1lBQzVGNFUsaUJBQWlCcEcsSUFBSSxHQUFHN087WUFDeEIsSUFBSWlWLGlCQUFpQm5HLEtBQUssRUFBRTtnQkFDeEIsSUFBSXFHLGlCQUFpQjtnQkFDckIsSUFBSUMsVUFBVSxDQUFDO2dCQUNmLElBQUlDLFVBQVVKLGlCQUFpQm5HLEtBQUssQ0FBQ3pPLEtBQUssQ0FBQztnQkFDM0MsSUFBSyxJQUFJWCxJQUFJLEdBQUdELEtBQUs0VixRQUFRalcsTUFBTSxFQUFFTSxJQUFJRCxJQUFJLEVBQUVDLEVBQUc7b0JBQzlDLElBQUk0VixTQUFTRCxPQUFPLENBQUMzVixFQUFFLENBQUNXLEtBQUssQ0FBQztvQkFDOUIsT0FBUWlWLE1BQU0sQ0FBQyxFQUFFO3dCQUNiLEtBQUs7NEJBQ0QsSUFBSUMsVUFBVUQsTUFBTSxDQUFDLEVBQUUsQ0FBQ2pWLEtBQUssQ0FBQzs0QkFDOUIsSUFBSyxJQUFJbVYsS0FBSyxHQUFHQyxNQUFNRixRQUFRblcsTUFBTSxFQUFFb1csS0FBS0MsS0FBSyxFQUFFRCxHQUFJO2dDQUNuRE4sR0FBR2xPLElBQUksQ0FBQ3VPLE9BQU8sQ0FBQ0MsR0FBRzs0QkFDdkI7NEJBQ0E7d0JBQ0osS0FBSzs0QkFDRFAsaUJBQWlCUyxPQUFPLEdBQUc5QixrQkFBa0IwQixNQUFNLENBQUMsRUFBRSxFQUFFbkU7NEJBQ3hEO3dCQUNKLEtBQUs7NEJBQ0Q4RCxpQkFBaUJVLElBQUksR0FBRy9CLGtCQUFrQjBCLE1BQU0sQ0FBQyxFQUFFLEVBQUVuRTs0QkFDckQ7d0JBQ0o7NEJBQ0lnRSxpQkFBaUI7NEJBQ2pCQyxPQUFPLENBQUN4QixrQkFBa0IwQixNQUFNLENBQUMsRUFBRSxFQUFFbkUsU0FBUyxHQUFHeUMsa0JBQWtCMEIsTUFBTSxDQUFDLEVBQUUsRUFBRW5FOzRCQUM5RTtvQkFDUjtnQkFDSjtnQkFDQSxJQUFJZ0UsZ0JBQWdCRixpQkFBaUJHLE9BQU8sR0FBR0E7WUFDbkQ7WUFDQUgsaUJBQWlCbkcsS0FBSyxHQUFHOU87WUFDekIsSUFBSyxJQUFJNFYsTUFBTSxHQUFHQyxPQUFPWCxHQUFHOVYsTUFBTSxFQUFFd1csTUFBTUMsTUFBTSxFQUFFRCxJQUFLO2dCQUNuRCxJQUFJRSxPQUFPWixFQUFFLENBQUNVLElBQUksQ0FBQ3ZWLEtBQUssQ0FBQztnQkFDekJ5VixJQUFJLENBQUMsRUFBRSxHQUFHbEMsa0JBQWtCa0MsSUFBSSxDQUFDLEVBQUU7Z0JBQ25DLElBQUksQ0FBQzNFLFFBQVFRLGNBQWMsRUFBRTtvQkFDekIsa0NBQWtDO29CQUNsQyxJQUFJO3dCQUNBbUUsSUFBSSxDQUFDLEVBQUUsR0FBR3hJLFNBQVNELE9BQU8sQ0FBQ3VHLGtCQUFrQmtDLElBQUksQ0FBQyxFQUFFLEVBQUUzRSxTQUFTM1EsV0FBVztvQkFDOUUsRUFBRSxPQUFPbU4sR0FBRzt3QkFDUnNILGlCQUFpQnhELEtBQUssR0FBR3dELGlCQUFpQnhELEtBQUssSUFBSSw2RUFBNkU5RDtvQkFDcEk7Z0JBQ0osT0FBTztvQkFDSG1JLElBQUksQ0FBQyxFQUFFLEdBQUdsQyxrQkFBa0JrQyxJQUFJLENBQUMsRUFBRSxFQUFFM0UsU0FBUzNRLFdBQVc7Z0JBQzdEO2dCQUNBMFUsRUFBRSxDQUFDVSxJQUFJLEdBQUdFLEtBQUtuVyxJQUFJLENBQUM7WUFDeEI7WUFDQSxPQUFPc1Y7UUFDWDtRQUNBdkMsV0FBVyxTQUFTcUQsYUFBYWQsZ0JBQWdCLEVBQUU5RCxPQUFPO1lBQ3RELElBQUk5QyxhQUFhNEc7WUFDakIsSUFBSUMsS0FBS3hVLFFBQVF1VSxpQkFBaUJDLEVBQUU7WUFDcEMsSUFBSUEsSUFBSTtnQkFDSixJQUFLLElBQUl4VixJQUFJLEdBQUdELEtBQUt5VixHQUFHOVYsTUFBTSxFQUFFTSxJQUFJRCxJQUFJLEVBQUVDLEVBQUc7b0JBQ3pDLElBQUlzVyxTQUFTdk4sT0FBT3lNLEVBQUUsQ0FBQ3hWLEVBQUU7b0JBQ3pCLElBQUl1VyxRQUFRRCxPQUFPaEwsV0FBVyxDQUFDO29CQUMvQixJQUFJa0wsWUFBWUYsT0FBT3hXLEtBQUssQ0FBQyxHQUFHeVcsT0FBTzVNLE9BQU8sQ0FBQ3hELGFBQWEwSSxrQkFBa0JsRixPQUFPLENBQUN4RCxhQUFhcEYsYUFBYTRJLE9BQU8sQ0FBQ3VMLGdCQUFnQnBIO29CQUN4SSxJQUFJMkksU0FBU0gsT0FBT3hXLEtBQUssQ0FBQ3lXLFFBQVE7b0JBQ2xDLDBCQUEwQjtvQkFDMUIsSUFBSTt3QkFDQUUsU0FBUyxDQUFDaEYsUUFBUUMsR0FBRyxHQUFHOUQsU0FBU0QsT0FBTyxDQUFDdUcsa0JBQWtCdUMsUUFBUWhGLFNBQVMzUSxXQUFXLE1BQU04TSxTQUFTSCxTQUFTLENBQUNnSjtvQkFDcEgsRUFBRSxPQUFPeEksR0FBRzt3QkFDUlUsV0FBV29ELEtBQUssR0FBR3BELFdBQVdvRCxLQUFLLElBQUkseURBQTBELEVBQUNOLFFBQVFDLEdBQUcsR0FBRyxVQUFVLFNBQVEsSUFBSyxvQkFBb0J6RDtvQkFDL0o7b0JBQ0F1SCxFQUFFLENBQUN4VixFQUFFLEdBQUd3VyxZQUFZLE1BQU1DO2dCQUM5QjtnQkFDQTlILFdBQVdRLElBQUksR0FBR3FHLEdBQUd2VixJQUFJLENBQUM7WUFDOUI7WUFDQSxJQUFJeVYsVUFBVUgsaUJBQWlCRyxPQUFPLEdBQUdILGlCQUFpQkcsT0FBTyxJQUFJLENBQUM7WUFDdEUsSUFBSUgsaUJBQWlCUyxPQUFPLEVBQUVOLE9BQU8sQ0FBQyxVQUFVLEdBQUdILGlCQUFpQlMsT0FBTztZQUMzRSxJQUFJVCxpQkFBaUJVLElBQUksRUFBRVAsT0FBTyxDQUFDLE9BQU8sR0FBR0gsaUJBQWlCVSxJQUFJO1lBQ2xFLElBQUl6RixTQUFTLEVBQUU7WUFDZixJQUFLLElBQUlrRyxRQUFRaEIsUUFBUztnQkFDdEIsSUFBSUEsT0FBTyxDQUFDZ0IsS0FBSyxLQUFLN0IsQ0FBQyxDQUFDNkIsS0FBSyxFQUFFO29CQUMzQmxHLE9BQU9sSixJQUFJLENBQUNvUCxLQUFLL00sT0FBTyxDQUFDeEQsYUFBYTBJLGtCQUFrQmxGLE9BQU8sQ0FBQ3hELGFBQWFwRixhQUFhNEksT0FBTyxDQUFDd0wsWUFBWXJILGNBQWMsTUFBTTRILE9BQU8sQ0FBQ2dCLEtBQUssQ0FBQy9NLE9BQU8sQ0FBQ3hELGFBQWEwSSxrQkFBa0JsRixPQUFPLENBQUN4RCxhQUFhcEYsYUFBYTRJLE9BQU8sQ0FBQ3lMLGFBQWF0SDtnQkFDbFA7WUFDSjtZQUNBLElBQUkwQyxPQUFPOVEsTUFBTSxFQUFFO2dCQUNmaVAsV0FBV1MsS0FBSyxHQUFHb0IsT0FBT3ZRLElBQUksQ0FBQztZQUNuQztZQUNBLE9BQU8wTztRQUNYO0lBQ0o7SUFFQSxJQUFJZ0ksWUFBWTtJQUNoQixVQUFVO0lBQ1YsSUFBSUMsWUFBWTtRQUNaNUgsUUFBUTtRQUNSdUMsT0FBTyxTQUFTK0QsU0FBUzNHLFVBQVUsRUFBRThDLE9BQU87WUFDeEMsSUFBSWpDLFVBQVViLFdBQVdRLElBQUksSUFBSVIsV0FBV1EsSUFBSSxDQUFDSixLQUFLLENBQUM0SDtZQUN2RCxJQUFJRSxnQkFBZ0JsSTtZQUNwQixJQUFJYSxTQUFTO2dCQUNULElBQUlSLFNBQVN5QyxRQUFRekMsTUFBTSxJQUFJNkgsY0FBYzdILE1BQU0sSUFBSTtnQkFDdkQsSUFBSThILE1BQU10SCxPQUFPLENBQUMsRUFBRSxDQUFDMU8sV0FBVztnQkFDaEMsSUFBSWlXLE1BQU12SCxPQUFPLENBQUMsRUFBRTtnQkFDcEIsSUFBSXdILFlBQVloSSxTQUFTLE1BQU95QyxDQUFBQSxRQUFRcUYsR0FBRyxJQUFJQSxHQUFFO2dCQUNqRCxJQUFJOUUsZ0JBQWdCbkUsT0FBTyxDQUFDbUosVUFBVTtnQkFDdENILGNBQWNDLEdBQUcsR0FBR0E7Z0JBQ3BCRCxjQUFjRSxHQUFHLEdBQUdBO2dCQUNwQkYsY0FBYzFILElBQUksR0FBRzdPO2dCQUNyQixJQUFJMFIsZUFBZTtvQkFDZjZFLGdCQUFnQjdFLGNBQWNULEtBQUssQ0FBQ3NGLGVBQWVwRjtnQkFDdkQ7WUFDSixPQUFPO2dCQUNIb0YsY0FBYzlFLEtBQUssR0FBRzhFLGNBQWM5RSxLQUFLLElBQUk7WUFDakQ7WUFDQSxPQUFPOEU7UUFDWDtRQUNBN0QsV0FBVyxTQUFTcUQsYUFBYVEsYUFBYSxFQUFFcEYsT0FBTztZQUNuRCxJQUFJekMsU0FBU3lDLFFBQVF6QyxNQUFNLElBQUk2SCxjQUFjN0gsTUFBTSxJQUFJO1lBQ3ZELElBQUk4SCxNQUFNRCxjQUFjQyxHQUFHO1lBQzNCLElBQUlFLFlBQVloSSxTQUFTLE1BQU95QyxDQUFBQSxRQUFRcUYsR0FBRyxJQUFJQSxHQUFFO1lBQ2pELElBQUk5RSxnQkFBZ0JuRSxPQUFPLENBQUNtSixVQUFVO1lBQ3RDLElBQUloRixlQUFlO2dCQUNmNkUsZ0JBQWdCN0UsY0FBY2dCLFNBQVMsQ0FBQzZELGVBQWVwRjtZQUMzRDtZQUNBLElBQUl3RixnQkFBZ0JKO1lBQ3BCLElBQUlFLE1BQU1GLGNBQWNFLEdBQUc7WUFDM0JFLGNBQWM5SCxJQUFJLEdBQUcsQ0FBQzJILE9BQU9yRixRQUFRcUYsR0FBRyxJQUFJLE1BQU1DO1lBQ2xELE9BQU9FO1FBQ1g7SUFDSjtJQUVBLElBQUlDLE9BQU87SUFDWCxVQUFVO0lBQ1YsSUFBSUMsWUFBWTtRQUNabkksUUFBUTtRQUNSdUMsT0FBTyxTQUFTQSxNQUFNc0YsYUFBYSxFQUFFcEYsT0FBTztZQUN4QyxJQUFJMkYsaUJBQWlCUDtZQUNyQk8sZUFBZUMsSUFBSSxHQUFHRCxlQUFlTCxHQUFHO1lBQ3hDSyxlQUFlTCxHQUFHLEdBQUd6VztZQUNyQixJQUFJLENBQUNtUixRQUFROEIsUUFBUSxJQUFLLEVBQUM2RCxlQUFlQyxJQUFJLElBQUksQ0FBQ0QsZUFBZUMsSUFBSSxDQUFDdEksS0FBSyxDQUFDbUksS0FBSSxHQUFJO2dCQUNqRkUsZUFBZXJGLEtBQUssR0FBR3FGLGVBQWVyRixLQUFLLElBQUk7WUFDbkQ7WUFDQSxPQUFPcUY7UUFDWDtRQUNBcEUsV0FBVyxTQUFTQSxVQUFVb0UsY0FBYyxFQUFFM0YsT0FBTztZQUNqRCxJQUFJb0YsZ0JBQWdCTztZQUNwQixnQkFBZ0I7WUFDaEJQLGNBQWNFLEdBQUcsR0FBRyxDQUFDSyxlQUFlQyxJQUFJLElBQUksRUFBQyxFQUFHdlcsV0FBVztZQUMzRCxPQUFPK1Y7UUFDWDtJQUNKO0lBRUFoSixPQUFPLENBQUNzRyxRQUFRbkYsTUFBTSxDQUFDLEdBQUdtRjtJQUMxQnRHLE9BQU8sQ0FBQ3dHLFVBQVVyRixNQUFNLENBQUMsR0FBR3FGO0lBQzVCeEcsT0FBTyxDQUFDMkcsVUFBVXhGLE1BQU0sQ0FBQyxHQUFHd0Y7SUFDNUIzRyxPQUFPLENBQUMrRyxVQUFVNUYsTUFBTSxDQUFDLEdBQUc0RjtJQUM1Qi9HLE9BQU8sQ0FBQ3dILFVBQVVyRyxNQUFNLENBQUMsR0FBR3FHO0lBQzVCeEgsT0FBTyxDQUFDK0ksVUFBVTVILE1BQU0sQ0FBQyxHQUFHNEg7SUFDNUIvSSxPQUFPLENBQUNzSixVQUFVbkksTUFBTSxDQUFDLEdBQUdtSTtJQUU1QmpZLFNBQVEyTyxPQUFPLEdBQUdBO0lBQ2xCM08sU0FBUTRPLFVBQVUsR0FBR0E7SUFDckI1TyxTQUFRZ1AsV0FBVyxHQUFHQTtJQUN0QmhQLFNBQVFxUyxLQUFLLEdBQUdBO0lBQ2hCclMsU0FBUTBULGlCQUFpQixHQUFHQTtJQUM1QjFULFNBQVE4VCxTQUFTLEdBQUdBO0lBQ3BCOVQsU0FBUWtVLGlCQUFpQixHQUFHQTtJQUM1QmxVLFNBQVFzVSxPQUFPLEdBQUdBO0lBQ2xCdFUsU0FBUTBVLFNBQVMsR0FBR0E7SUFDcEIxVSxTQUFRNFUsS0FBSyxHQUFHQTtJQUNoQjVVLFNBQVErVSxlQUFlLEdBQUdBO0lBQzFCL1UsU0FBUWdWLGlCQUFpQixHQUFHQTtJQUU1QjNULE9BQU8rVyxjQUFjLENBQUNwWSxVQUFTLGNBQWM7UUFBRXFJLE9BQU87SUFBSztBQUUzRCxJQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzP2U3ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFVSSS5qcyB2NC40LjEgKGMpIDIwMTEgR2FyeSBDb3VydC4gTGljZW5zZTogaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qcyAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLlVSSSA9IGdsb2JhbC5VUkkgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzZXRzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHNldHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHNldHMubGVuZ3RoID4gMSkge1xuICAgICAgICBzZXRzWzBdID0gc2V0c1swXS5zbGljZSgwLCAtMSk7XG4gICAgICAgIHZhciB4bCA9IHNldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICBzZXRzW3hdID0gc2V0c1t4XS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0c1t4bF0gPSBzZXRzW3hsXS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIHNldHMuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNldHNbMF07XG4gICAgfVxufVxuZnVuY3Rpb24gc3ViZXhwKHN0cikge1xuICAgIHJldHVybiBcIig/OlwiICsgc3RyICsgXCIpXCI7XG59XG5mdW5jdGlvbiB0eXBlT2Yobykge1xuICAgIHJldHVybiBvID09PSB1bmRlZmluZWQgPyBcInVuZGVmaW5lZFwiIDogbyA9PT0gbnVsbCA/IFwibnVsbFwiIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNwbGl0KFwiIFwiKS5wb3AoKS5zcGxpdChcIl1cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsID8gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiB0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBvYmouc3BsaXQgfHwgb2JqLnNldEludGVydmFsIHx8IG9iai5jYWxsID8gW29ial0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopIDogW107XG59XG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB2YXIgb2JqID0gdGFyZ2V0O1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBidWlsZEV4cHMoaXNJUkkpIHtcbiAgICB2YXIgQUxQSEEkJCA9IFwiW0EtWmEtel1cIixcbiAgICAgICAgQ1IkID0gXCJbXFxcXHgwRF1cIixcbiAgICAgICAgRElHSVQkJCA9IFwiWzAtOV1cIixcbiAgICAgICAgRFFVT1RFJCQgPSBcIltcXFxceDIyXVwiLFxuICAgICAgICBIRVhESUckJCA9IG1lcmdlKERJR0lUJCQsIFwiW0EtRmEtZl1cIiksXG4gICAgICAgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuICAgIExGJCQgPSBcIltcXFxceDBBXVwiLFxuICAgICAgICBTUCQkID0gXCJbXFxcXHgyMF1cIixcbiAgICAgICAgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpLFxuICAgICAgICAvL2V4cGFuZGVkXG4gICAgR0VOX0RFTElNUyQkID0gXCJbXFxcXDpcXFxcL1xcXFw/XFxcXCNcXFxcW1xcXFxdXFxcXEBdXCIsXG4gICAgICAgIFNVQl9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJlxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXD1dXCIsXG4gICAgICAgIFJFU0VSVkVEJCQgPSBtZXJnZShHRU5fREVMSU1TJCQsIFNVQl9ERUxJTVMkJCksXG4gICAgICAgIFVDU0NIQVIkJCA9IGlzSVJJID8gXCJbXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXVwiIDogXCJbXVwiLFxuICAgICAgICAvL3N1YnNldCwgZXhjbHVkZXMgYmlkaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBJUFJJVkFURSQkID0gaXNJUkkgPyBcIltcXFxcdUUwMDAtXFxcXHVGOEZGXVwiIDogXCJbXVwiLFxuICAgICAgICAvL3N1YnNldFxuICAgIFVOUkVTRVJWRUQkJCA9IG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwtXFxcXC5cXFxcX1xcXFx+XVwiLCBVQ1NDSEFSJCQpLFxuICAgICAgICBTQ0hFTUUkID0gc3ViZXhwKEFMUEhBJCQgKyBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpICsgXCIqXCIpLFxuICAgICAgICBVU0VSSU5GTyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSkgKyBcIipcIiksXG4gICAgICAgIERFQ19PQ1RFVCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCJbMS05XVwiICsgRElHSVQkJCkgKyBcInxcIiArIERJR0lUJCQpLFxuICAgICAgICBERUNfT0NURVRfUkVMQVhFRCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIwP1sxLTldXCIgKyBESUdJVCQkKSArIFwifDA/MD9cIiArIERJR0lUJCQpLFxuICAgICAgICAvL3JlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVjRBRERSRVNTJCA9IHN1YmV4cChERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQpLFxuICAgICAgICBIMTYkID0gc3ViZXhwKEhFWERJRyQkICsgXCJ7MSw0fVwiKSxcbiAgICAgICAgTFMzMiQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIgKyBIMTYkKSArIFwifFwiICsgSVBWNEFERFJFU1MkKSxcbiAgICAgICAgSVBWNkFERFJFU1MxJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns2fVwiICsgTFMzMiQpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzIkID0gc3ViZXhwKFwiXFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NX1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgXCI6OlwiIDUoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzMkID0gc3ViZXhwKHN1YmV4cChIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezR9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M0JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwxfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInszfVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjEoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAzKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M1JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwyfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInsyfVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjIoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAyKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M2JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwzfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBIMTYkICsgXCJcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG4gICAgSVBWNkFERFJFU1M3JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw0fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqNCggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBsczMyXG4gICAgSVBWNkFERFJFU1M4JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw1fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBIMTYkKSxcbiAgICAgICAgLy9bICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuICAgIElQVjZBRERSRVNTOSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiKSxcbiAgICAgICAgLy9bICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcbiAgICBJUFY2QUREUkVTUyQgPSBzdWJleHAoW0lQVjZBRERSRVNTMSQsIElQVjZBRERSRVNTMiQsIElQVjZBRERSRVNTMyQsIElQVjZBRERSRVNTNCQsIElQVjZBRERSRVNTNSQsIElQVjZBRERSRVNTNiQsIElQVjZBRERSRVNTNyQsIElQVjZBRERSRVNTOCQsIElQVjZBRERSRVNTOSRdLmpvaW4oXCJ8XCIpKSxcbiAgICAgICAgWk9ORUlEJCA9IHN1YmV4cChzdWJleHAoVU5SRVNFUlZFRCQkICsgXCJ8XCIgKyBQQ1RfRU5DT0RFRCQpICsgXCIrXCIpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgSVBWNkFERFJaJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBcIlxcXFwlMjVcIiArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgSVBWNkFERFJaX1JFTEFYRUQkID0gc3ViZXhwKElQVjZBRERSRVNTJCArIHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgWk9ORUlEJCksXG4gICAgICAgIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgSVBWRlVUVVJFJCA9IHN1YmV4cChcIlt2Vl1cIiArIEhFWERJRyQkICsgXCIrXFxcXC5cIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikgKyBcIitcIiksXG4gICAgICAgIElQX0xJVEVSQUwkID0gc3ViZXhwKFwiXFxcXFtcIiArIHN1YmV4cChJUFY2QUREUlpfUkVMQVhFRCQgKyBcInxcIiArIElQVjZBRERSRVNTJCArIFwifFwiICsgSVBWRlVUVVJFJCkgKyBcIlxcXFxdXCIpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgUkVHX05BTUUkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSkgKyBcIipcIiksXG4gICAgICAgIEhPU1QkID0gc3ViZXhwKElQX0xJVEVSQUwkICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQgKyBcIig/IVwiICsgUkVHX05BTUUkICsgXCIpXCIgKyBcInxcIiArIFJFR19OQU1FJCksXG4gICAgICAgIFBPUlQkID0gc3ViZXhwKERJR0lUJCQgKyBcIipcIiksXG4gICAgICAgIEFVVEhPUklUWSQgPSBzdWJleHAoc3ViZXhwKFVTRVJJTkZPJCArIFwiQFwiKSArIFwiP1wiICsgSE9TVCQgKyBzdWJleHAoXCJcXFxcOlwiICsgUE9SVCQpICsgXCI/XCIpLFxuICAgICAgICBQQ0hBUiQgPSBzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQF1cIikpLFxuICAgICAgICBTRUdNRU5UJCA9IHN1YmV4cChQQ0hBUiQgKyBcIipcIiksXG4gICAgICAgIFNFR01FTlRfTlokID0gc3ViZXhwKFBDSEFSJCArIFwiK1wiKSxcbiAgICAgICAgU0VHTUVOVF9OWl9OQyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFxAXVwiKSkgKyBcIitcIiksXG4gICAgICAgIFBBVEhfQUJFTVBUWSQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cIiArIFNFR01FTlQkKSArIFwiKlwiKSxcbiAgICAgICAgUEFUSF9BQlNPTFVURSQgPSBzdWJleHAoXCJcXFxcL1wiICsgc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCkgKyBcIj9cIiksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfTk9TQ0hFTUUkID0gc3ViZXhwKFNFR01FTlRfTlpfTkMkICsgUEFUSF9BQkVNUFRZJCksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfUk9PVExFU1MkID0gc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfRU1QVFkkID0gXCIoPyFcIiArIFBDSEFSJCArIFwiKVwiLFxuICAgICAgICBQQVRIJCA9IHN1YmV4cChQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFFVRVJZJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8XCIgKyBtZXJnZShcIltcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSkgKyBcIipcIiksXG4gICAgICAgIEZSQUdNRU5UJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8W1xcXFwvXFxcXD9dXCIpICsgXCIqXCIpLFxuICAgICAgICBISUVSX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFVSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFJFTEFUSVZFX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFJFTEFUSVZFJCA9IHN1YmV4cChSRUxBVElWRV9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcbiAgICAgICAgVVJJX1JFRkVSRU5DRSQgPSBzdWJleHAoVVJJJCArIFwifFwiICsgUkVMQVRJVkUkKSxcbiAgICAgICAgQUJTT0xVVEVfVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIpLFxuICAgICAgICBHRU5FUklDX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIFJFTEFUSVZFX1JFRiQgPSBcIl4oKXswfVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQUJTT0xVVEVfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBTQU1FRE9DX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBBVVRIT1JJVFlfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/JFwiO1xuICAgIHJldHVybiB7XG4gICAgICAgIE5PVF9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSwgXCJnXCIpLFxuICAgICAgICBOT1RfVVNFUklORk86IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfSE9TVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcW1xcXFxdXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUEFUSDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFw6XFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUEFUSF9OT1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1FVRVJZOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfRlJBR01FTlQ6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIpLCBcImdcIiksXG4gICAgICAgIEVTQ0FQRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgVU5SRVNFUlZFRDogbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKSxcbiAgICAgICAgT1RIRVJfQ0hBUlM6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFJFU0VSVkVEJCQpLCBcImdcIiksXG4gICAgICAgIFBDVF9FTkNPREVEOiBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpLFxuICAgICAgICBJUFY0QUREUkVTUzogbmV3IFJlZ0V4cChcIl4oXCIgKyBJUFY0QUREUkVTUyQgKyBcIikkXCIpLFxuICAgICAgICBJUFY2QUREUkVTUzogbmV3IFJlZ0V4cChcIl5cXFxcWz8oXCIgKyBJUFY2QUREUkVTUyQgKyBcIilcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFwiKFwiICsgWk9ORUlEJCArIFwiKVwiKSArIFwiP1xcXFxdPyRcIikgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICB9O1xufVxudmFyIFVSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyhmYWxzZSk7XG5cbnZhciBJUklfUFJPVE9DT0wgPSBidWlsZEV4cHModHJ1ZSk7XG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXG52YXIgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG52YXIgYmFzZSA9IDM2O1xudmFyIHRNaW4gPSAxO1xudmFyIHRNYXggPSAyNjtcbnZhciBza2V3ID0gMzg7XG52YXIgZGFtcCA9IDcwMDtcbnZhciBpbml0aWFsQmlhcyA9IDcyO1xudmFyIGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG52YXIgZGVsaW1pdGVyID0gJy0nOyAvLyAnXFx4MkQnXG5cbi8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG52YXIgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG52YXIgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbnZhciByZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nOyAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cbi8qKiBFcnJvciBtZXNzYWdlcyAqL1xudmFyIGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbnZhciBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvciQxKHR5cGUpIHtcblx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcbn1cblxuLyoqXG4gKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG4gKiBpdGVtLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdHZhciByZXN1bHQgPSBbXTtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdHZhciByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgY291bnRlciA9IDA7XG5cdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblx0XHRcdHZhciBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcblx0XHRcdFx0Ly8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xudmFyIHVjczJlbmNvZGUgPSBmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsIHRvQ29uc3VtYWJsZUFycmF5KGFycmF5KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbnZhciBiYXNpY1RvRGlnaXQgPSBmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdGlmIChjb2RlUG9pbnQgLSAweDMwIDwgMHgwQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDE2O1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgLSAweDQxIDwgMHgxQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDQxO1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgLSAweDYxIDwgMHgxQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDYxO1xuXHR9XG5cdHJldHVybiBiYXNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG4gKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcbiAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG4gKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuICovXG52YXIgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhZGFwdCA9IGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHR2YXIgayA9IDA7XG5cdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0Zm9yICg7IC8qIG5vIGluaXRpYWxpemF0aW9uICovZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdH1cblx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG4gKiBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKi9cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0dmFyIGkgPSAwO1xuXHR2YXIgbiA9IGluaXRpYWxOO1xuXHR2YXIgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHR2YXIgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yICh2YXIgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IkMSgnbm90LWJhc2ljJyk7XG5cdFx0fVxuXHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHR9XG5cblx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdGZvciAodmFyIGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDspIC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi97XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdHZhciBvbGRpID0gaTtcblx0XHRmb3IgKHZhciB3ID0gMSwgayA9IGJhc2U7OyAvKiBubyBjb25kaXRpb24gKi9rICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yJDEoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0dmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXHRcdH1cblxuXHRcdHZhciBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0aSAlPSBvdXQ7XG5cblx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0LlxuXHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblx0fVxuXG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsIG91dHB1dCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKi9cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0dmFyIG91dHB1dCA9IFtdO1xuXG5cdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIGFuIGFycmF5IG9mIFVuaWNvZGUgY29kZSBwb2ludHMuXG5cdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0Ly8gQ2FjaGUgdGhlIGxlbmd0aC5cblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlLlxuXHR2YXIgbiA9IGluaXRpYWxOO1xuXHR2YXIgZGVsdGEgPSAwO1xuXHR2YXIgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHMuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0dmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvciA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0dmFyIF9jdXJyZW50VmFsdWUyID0gX3N0ZXAudmFsdWU7XG5cblx0XHRcdGlmIChfY3VycmVudFZhbHVlMiA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKF9jdXJyZW50VmFsdWUyKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvci5yZXR1cm4oKTtcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cdHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG5cdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cblx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdHZhciBtID0gbWF4SW50O1xuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMiA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG5cdFx0XHRcdHZhciBjdXJyZW50VmFsdWUgPSBfc3RlcDIudmFsdWU7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcblx0XHRcdF9pdGVyYXRvckVycm9yMiA9IGVycjtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuXHRcdFx0XHRcdF9pdGVyYXRvcjIucmV0dXJuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcblx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0biA9IG07XG5cblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjMgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgX2N1cnJlbnRWYWx1ZSA9IF9zdGVwMy52YWx1ZTtcblxuXHRcdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRcdHZhciBxID0gZGVsdGE7XG5cdFx0XHRcdFx0Zm9yICh2YXIgayA9IGJhc2U7OyAvKiBubyBjb25kaXRpb24gKi9rICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0dmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSkpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcblx0XHRcdF9pdGVyYXRvckVycm9yMyA9IGVycjtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuXHRcdFx0XHRcdF9pdGVyYXRvcjMucmV0dXJuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcblx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblx0fVxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAqIHN0cmluZy5cbiAqL1xudmFyIHRvVW5pY29kZSA9IGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG52YXIgdG9BU0NJSSA9IGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG52YXIgcHVueWNvZGUgPSB7XG5cdC8qKlxuICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cbiAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgKiBAdHlwZSBTdHJpbmdcbiAgKi9cblx0J3ZlcnNpb24nOiAnMi4xLjAnLFxuXHQvKipcbiAgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuICAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG4gICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgT2JqZWN0XG4gICovXG5cdCd1Y3MyJzoge1xuXHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdH0sXG5cdCdkZWNvZGUnOiBkZWNvZGUsXG5cdCdlbmNvZGUnOiBlbmNvZGUsXG5cdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxufTtcblxuLyoqXG4gKiBVUkkuanNcbiAqXG4gKiBAZmlsZW92ZXJ2aWV3IEFuIFJGQyAzOTg2IGNvbXBsaWFudCwgc2NoZW1lIGV4dGVuZGFibGUgVVJJIHBhcnNpbmcvdmFsaWRhdGluZy9yZXNvbHZpbmcgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC5cbiAqIEBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpnYXJ5LmNvdXJ0QGdtYWlsLmNvbVwiPkdhcnkgQ291cnQ8L2E+XG4gKiBAc2VlIGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanNcbiAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMSBHYXJ5IENvdXJ0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxuICogcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcbiAqICAgICAgIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICogICAgICAgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAqICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEdBUlkgQ09VUlQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEXG4gKiBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR0FSWSBDT1VSVCBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRlxuICogQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uIGFyZSB0aG9zZSBvZiB0aGVcbiAqIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkXG4gKiBvciBpbXBsaWVkLCBvZiBHYXJ5IENvdXJ0LlxuICovXG52YXIgU0NIRU1FUyA9IHt9O1xuZnVuY3Rpb24gcGN0RW5jQ2hhcihjaHIpIHtcbiAgICB2YXIgYyA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBlID0gdm9pZCAwO1xuICAgIGlmIChjIDwgMTYpIGUgPSBcIiUwXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAxMjgpIGUgPSBcIiVcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoYyA8IDIwNDgpIGUgPSBcIiVcIiArIChjID4+IDYgfCAxOTIpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGUgPSBcIiVcIiArIChjID4+IDEyIHwgMjI0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgPj4gNiAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBwY3REZWNDaGFycyhzdHIpIHtcbiAgICB2YXIgbmV3U3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGlsID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGlsKSB7XG4gICAgICAgIHZhciBjID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgMSwgMiksIDE2KTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMTk0ICYmIGMgPCAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gNikge1xuICAgICAgICAgICAgICAgIHZhciBjMiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAzMSkgPDwgNiB8IGMyICYgNjMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDIyNCkge1xuICAgICAgICAgICAgaWYgKGlsIC0gaSA+PSA5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgYzMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA3LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKF9jICYgNjMpIDw8IDYgfCBjMyAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCAzKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3U3RyO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKSB7XG4gICAgZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICAgICAgdmFyIGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG4gICAgICAgIHJldHVybiAhZGVjU3RyLm1hdGNoKHByb3RvY29sLlVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUpIGNvbXBvbmVudHMuc2NoZW1lID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1NDSEVNRSwgXCJcIik7XG4gICAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy51c2VyaW5mbyA9IFN0cmluZyhjb21wb25lbnRzLnVzZXJpbmZvKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9VU0VSSU5GTywgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5ob3N0ID0gU3RyaW5nKGNvbXBvbmVudHMuaG9zdCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9IT1NULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnBhdGggPSBTdHJpbmcoY29tcG9uZW50cy5wYXRoKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKGNvbXBvbmVudHMuc2NoZW1lID8gcHJvdG9jb2wuTk9UX1BBVEggOiBwcm90b2NvbC5OT1RfUEFUSF9OT1NDSEVNRSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucXVlcnkgPSBTdHJpbmcoY29tcG9uZW50cy5xdWVyeSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfUVVFUlksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmZyYWdtZW50ID0gU3RyaW5nKGNvbXBvbmVudHMuZnJhZ21lbnQpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0ZSQUdNRU5ULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbmZ1bmN0aW9uIF9zdHJpcExlYWRpbmdaZXJvcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14wKiguKikvLCBcIiQxXCIpIHx8IFwiMFwiO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjQoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNEFERFJFU1MpIHx8IFtdO1xuXG4gICAgdmFyIF9tYXRjaGVzID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAyKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzWzFdO1xuXG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3Muc3BsaXQoXCIuXCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpLmpvaW4oXCIuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY2KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjZBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlczIgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDMpLFxuICAgICAgICBhZGRyZXNzID0gX21hdGNoZXMyWzFdLFxuICAgICAgICB6b25lID0gX21hdGNoZXMyWzJdO1xuXG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIF9hZGRyZXNzJHRvTG93ZXJDYXNlJCA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5zcGxpdCgnOjonKS5yZXZlcnNlKCksXG4gICAgICAgICAgICBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyID0gc2xpY2VkVG9BcnJheShfYWRkcmVzcyR0b0xvd2VyQ2FzZSQsIDIpLFxuICAgICAgICAgICAgbGFzdCA9IF9hZGRyZXNzJHRvTG93ZXJDYXNlJDJbMF0sXG4gICAgICAgICAgICBmaXJzdCA9IF9hZGRyZXNzJHRvTG93ZXJDYXNlJDJbMV07XG5cbiAgICAgICAgdmFyIGZpcnN0RmllbGRzID0gZmlyc3QgPyBmaXJzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykgOiBbXTtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHMgPSBsYXN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKTtcbiAgICAgICAgdmFyIGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPSBwcm90b2NvbC5JUFY0QUREUkVTUy50ZXN0KGxhc3RGaWVsZHNbbGFzdEZpZWxkcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHZhciBmaWVsZENvdW50ID0gaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA/IDcgOiA4O1xuICAgICAgICB2YXIgbGFzdEZpZWxkc1N0YXJ0ID0gbGFzdEZpZWxkcy5sZW5ndGggLSBmaWVsZENvdW50O1xuICAgICAgICB2YXIgZmllbGRzID0gQXJyYXkoZmllbGRDb3VudCk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZmllbGRDb3VudDsgKyt4KSB7XG4gICAgICAgICAgICBmaWVsZHNbeF0gPSBmaXJzdEZpZWxkc1t4XSB8fCBsYXN0RmllbGRzW2xhc3RGaWVsZHNTdGFydCArIHhdIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhc3RGaWVsZElQdjRBZGRyZXNzKSB7XG4gICAgICAgICAgICBmaWVsZHNbZmllbGRDb3VudCAtIDFdID0gX25vcm1hbGl6ZUlQdjQoZmllbGRzW2ZpZWxkQ291bnQgLSAxXSwgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxaZXJvRmllbGRzID0gZmllbGRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmaWVsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghZmllbGQgfHwgZmllbGQgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMb25nZXN0ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExvbmdlc3QgJiYgbGFzdExvbmdlc3QuaW5kZXggKyBsYXN0TG9uZ2VzdC5sZW5ndGggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMb25nZXN0Lmxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYy5wdXNoKHsgaW5kZXg6IGluZGV4LCBsZW5ndGg6IDEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICB2YXIgbG9uZ2VzdFplcm9GaWVsZHMgPSBhbGxaZXJvRmllbGRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgdmFyIG5ld0hvc3QgPSB2b2lkIDA7XG4gICAgICAgIGlmIChsb25nZXN0WmVyb0ZpZWxkcyAmJiBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgbmV3Rmlyc3QgPSBmaWVsZHMuc2xpY2UoMCwgbG9uZ2VzdFplcm9GaWVsZHMuaW5kZXgpO1xuICAgICAgICAgICAgdmFyIG5ld0xhc3QgPSBmaWVsZHMuc2xpY2UobG9uZ2VzdFplcm9GaWVsZHMuaW5kZXggKyBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3SG9zdCA9IG5ld0ZpcnN0LmpvaW4oXCI6XCIpICsgXCI6OlwiICsgbmV3TGFzdC5qb2luKFwiOlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBmaWVsZHMuam9pbihcIjpcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvbmUpIHtcbiAgICAgICAgICAgIG5ld0hvc3QgKz0gXCIlXCIgKyB6b25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIb3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbn1cbnZhciBVUklfUEFSU0UgPSAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooW15cXC8/I0BdKilAKT8oXFxbW15cXC8/I1xcXV0rXFxdfFteXFwvPyM6XSopKD86XFw6KFxcZCopKT8pKT8oW14/I10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxcXG58XFxyKSopKT8vaTtcbnZhciBOT19NQVRDSF9JU19VTkRFRklORUQgPSBcIlwiLm1hdGNoKC8oKXswfS8pWzFdID09PSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBwYXJzZSh1cmlTdHJpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IHt9O1xuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09IFwic3VmZml4XCIpIHVyaVN0cmluZyA9IChvcHRpb25zLnNjaGVtZSA/IG9wdGlvbnMuc2NoZW1lICsgXCI6XCIgOiBcIlwiKSArIFwiLy9cIiArIHVyaVN0cmluZztcbiAgICB2YXIgbWF0Y2hlcyA9IHVyaVN0cmluZy5tYXRjaChVUklfUEFSU0UpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGlmIChOT19NQVRDSF9JU19VTkRFRklORUQpIHtcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBtYXRjaGVzWzddO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IG1hdGNoZXNbOF07XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBtYXRjaGVzWzVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9JRSBGSVggZm9yIGltcHJvcGVyIFJlZ0V4cCBtYXRjaGluZ1xuICAgICAgICAgICAgLy9zdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSB1cmlTdHJpbmcuaW5kZXhPZihcIkBcIikgIT09IC0xID8gbWF0Y2hlc1szXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IHVyaVN0cmluZy5pbmRleE9mKFwiLy9cIikgIT09IC0xID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSB1cmlTdHJpbmcuaW5kZXhPZihcIj9cIikgIT09IC0xID8gbWF0Y2hlc1s3XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSB1cmlTdHJpbmcuaW5kZXhPZihcIiNcIikgIT09IC0xID8gbWF0Y2hlc1s4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVyaVN0cmluZy5tYXRjaCgvXFwvXFwvKD86LnxcXG4pKlxcOig/OlxcL3xcXD98XFwjfCQpLykgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzXG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChjb21wb25lbnRzLmhvc3QsIHByb3RvY29sKSwgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vZGV0ZXJtaW5lIHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnBvcnQgPT09IHVuZGVmaW5lZCAmJiAhY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInNhbWUtZG9jdW1lbnRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRzLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInVyaVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBjb21wb25lbnRzLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgaXMgbm90IGEgXCIgKyBvcHRpb25zLnJlZmVyZW5jZSArIFwiIHJlZmVyZW5jZS5cIjtcbiAgICAgICAgfVxuICAgICAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgLy9jaGVjayBpZiBzY2hlbWUgY2FuJ3QgaGFuZGxlIElSSXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnZlcnQgSVJJIC0+IFVSSVxuICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIFVSSV9QUk9UT0NPTCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ3NcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcbiAgICAgICAgICAgIHNjaGVtZUhhbmRsZXIucGFyc2UoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbmZ1bmN0aW9uIF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICB2YXIgdXJpVG9rZW5zID0gW107XG4gICAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCJAXCIpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy9ub3JtYWxpemUgSVAgaG9zdHMsIGFkZCBicmFja2V0cyBhbmQgZXNjYXBlIHpvbmUgc2VwYXJhdG9yIGZvciBJUHY2XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KFN0cmluZyhjb21wb25lbnRzLmhvc3QpLCBwcm90b2NvbCksIHByb3RvY29sKS5yZXBsYWNlKHByb3RvY29sLklQVjZBRERSRVNTLCBmdW5jdGlvbiAoXywgJDEsICQyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbXCIgKyAkMSArICgkMiA/IFwiJTI1XCIgKyAkMiA6IFwiXCIpICsgXCJdXCI7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIjpcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnRzLnBvcnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbihcIlwiKSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIFJEUzEgPSAvXlxcLlxcLj9cXC8vO1xudmFyIFJEUzIgPSAvXlxcL1xcLihcXC98JCkvO1xudmFyIFJEUzMgPSAvXlxcL1xcLlxcLihcXC98JCkvO1xudmFyIFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS87XG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyhpbnB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzEsIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgXCIvXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzMpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMywgXCIvXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnBvcCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcIi5cIiB8fCBpbnB1dCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW0gPSBpbnB1dC5tYXRjaChSRFM1KTtcbiAgICAgICAgICAgIGlmIChpbSkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gaW1bMF07XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZG90IHNlZ21lbnQgY29uZGl0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICB2YXIgdXJpVG9rZW5zID0gW107XG4gICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGFuIElQdjYgYWRkcmVzc1xuICAgICAgICBpZiAocHJvdG9jb2wuSVBWNkFERFJFU1MudGVzdChjb21wb25lbnRzLmhvc3QpKSB7fVxuICAgICAgICAvL1RPRE86IG5vcm1hbGl6ZSBJUHY2IGFkZHJlc3MgYXMgcGVyIFJGQyA1OTUyXG5cbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGNvbXBvbmVudHMuaG9zdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8vbm9ybWFsaXplIGVuY29kaW5nXG4gICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgY29tcG9uZW50cy5zY2hlbWUpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIjpcIik7XG4gICAgfVxuICAgIHZhciBhdXRob3JpdHkgPSBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiLy9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIvXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcyA9IGNvbXBvbmVudHMucGF0aDtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXlxcL1xcLy8sIFwiLyUyRlwiKTsgLy9kb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKHMpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiP1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5xdWVyeSk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIjXCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLmZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaVRva2Vucy5qb2luKFwiXCIpOyAvL21lcmdlIHRva2VucyBpbnRvIGEgc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzKGJhc2UsIHJlbGF0aXZlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBza2lwTm9ybWFsaXphdGlvbiA9IGFyZ3VtZW50c1szXTtcblxuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAvL25vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcbiAgICAgICAgcmVsYXRpdmUgPSBwYXJzZShzZXJpYWxpemUocmVsYXRpdmUsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50c1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWU7XG4gICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG4gICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG4gICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aDtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYmFzZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IGJhc2UucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IFwiL1wiICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgIH1cbiAgICB0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudDtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGJhc2VVUkksIHJlbGF0aXZlVVJJLCBvcHRpb25zKSB7XG4gICAgdmFyIHNjaGVtZWxlc3NPcHRpb25zID0gYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKSwgc2NoZW1lbGVzc09wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUodXJpLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpID0gc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpID0gcGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpO1xufVxuXG5mdW5jdGlvbiBlcXVhbCh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB1cmlBID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUEgPSBzZXJpYWxpemUocGFyc2UodXJpQSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUEpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUEgPSBzZXJpYWxpemUodXJpQSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdXJpQiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlCID0gc2VyaWFsaXplKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlCKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlCID0gc2VyaWFsaXplKHVyaUIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpQSA9PT0gdXJpQjtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQ29tcG9uZW50KHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuRVNDQVBFIDogSVJJX1BST1RPQ09MLkVTQ0FQRSwgcGN0RW5jQ2hhcik7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQ29tcG9uZW50KHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuUENUX0VOQ09ERUQgOiBJUklfUFJPVE9DT0wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKTtcbn1cblxudmFyIGhhbmRsZXIgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vcmVwb3J0IG1pc3NpbmcgaG9zdFxuICAgICAgICBpZiAoIWNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJodHRwc1wiO1xuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBvcnQgPT09IChzZWN1cmUgPyA0NDMgOiA4MCkgfHwgY29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLnBhdGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIC8vTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuICAgICAgICAvL2FzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuICAgICAgICAvL2FuZCBub3QgdGhlIEhUVFAgc3BlYy5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIGhhbmRsZXIkMSA9IHtcbiAgICBzY2hlbWU6IFwiaHR0cHNcIixcbiAgICBkb21haW5Ib3N0OiBoYW5kbGVyLmRvbWFpbkhvc3QsXG4gICAgcGFyc2U6IGhhbmRsZXIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyLnNlcmlhbGl6ZVxufTtcblxuZnVuY3Rpb24gaXNTZWN1cmUod3NDb21wb25lbnRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicgPyB3c0NvbXBvbmVudHMuc2VjdXJlIDogU3RyaW5nKHdzQ29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwid3NzXCI7XG59XG4vL1JGQyA2NDU1XG52YXIgaGFuZGxlciQyID0ge1xuICAgIHNjaGVtZTogXCJ3c1wiLFxuICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHdzQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIC8vaW5kaWNhdGUgaWYgdGhlIHNlY3VyZSBmbGFnIGlzIHNldFxuICAgICAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gaXNTZWN1cmUod3NDb21wb25lbnRzKTtcbiAgICAgICAgLy9jb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJyk7XG4gICAgICAgIHdzQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICB3c0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB3c0NvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh3c0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2Vuc3VyZSBzY2hlbWUgbWF0Y2hlcyBzZWN1cmUgZmxhZ1xuICAgICAgICBpZiAodHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNjaGVtZSA9IHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfd3NDb21wb25lbnRzJHJlc291cmMgPSB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lLnNwbGl0KCc/JyksXG4gICAgICAgICAgICAgICAgX3dzQ29tcG9uZW50cyRyZXNvdXJjMiA9IHNsaWNlZFRvQXJyYXkoX3dzQ29tcG9uZW50cyRyZXNvdXJjLCAyKSxcbiAgICAgICAgICAgICAgICBwYXRoID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlswXSxcbiAgICAgICAgICAgICAgICBxdWVyeSA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMV07XG5cbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5wYXRoID0gcGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICAgICAgICB3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB3c0NvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIGhhbmRsZXIkMyA9IHtcbiAgICBzY2hlbWU6IFwid3NzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlciQyLmRvbWFpbkhvc3QsXG4gICAgcGFyc2U6IGhhbmRsZXIkMi5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGhhbmRsZXIkMi5zZXJpYWxpemVcbn07XG5cbnZhciBPID0ge307XG52YXIgaXNJUkkgPSB0cnVlO1xuLy9SRkMgMzk4NlxudmFyIFVOUkVTRVJWRUQkJCA9IFwiW0EtWmEtejAtOVxcXFwtXFxcXC5cXFxcX1xcXFx+XCIgKyAoaXNJUkkgPyBcIlxcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRlwiIDogXCJcIikgKyBcIl1cIjtcbnZhciBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIjsgLy9jYXNlLWluc2Vuc2l0aXZlXG52YXIgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpOyAvL2V4cGFuZGVkXG4vL1JGQyA1MzIyLCBleGNlcHQgdGhlc2Ugc3ltYm9scyBhcyBwZXIgUkZDIDYwNjg6IEAgOiAvID8gIyBbIF0gJiA7ID1cbi8vY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIjsgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcbi8vY29uc3QgUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKTsgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxuLy9jb25zdCBWQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKTsgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxuLy9jb25zdCBGV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIik7XG4vL2NvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpO1xuLy9jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyk7XG52YXIgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG52YXIgUVRFWFQkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwtXFxcXC4wLTlcXFxcPFxcXFw+QS1aXFxcXHg1RS1cXFxceDdFXVwiO1xudmFyIFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbnZhciBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIjtcbnZhciBVTlJFU0VSVkVEID0gbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKTtcbnZhciBQQ1RfRU5DT0RFRCA9IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIik7XG52YXIgTk9UX0xPQ0FMX1BBUlQgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCAnW1xcXFxcIl0nLCBWQ0hBUiQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRk5BTUUgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU09NRV9ERUxJTVMkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZWQUxVRSA9IE5PVF9IRk5BTUU7XG5mdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgIHJldHVybiAhZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyO1xufVxudmFyIGhhbmRsZXIkNCA9IHtcbiAgICBzY2hlbWU6IFwibWFpbHRvXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1haWx0b0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSBtYWlsdG9Db21wb25lbnRzLnRvID0gbWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdO1xuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgdW5rbm93bkhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgICAgICAgICB2YXIgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gaGZpZWxkcy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhmaWVsZCA9IGhmaWVsZHNbeF0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaGZpZWxkWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX3ggPSAwLCBfeGwgPSB0b0FkZHJzLmxlbmd0aDsgX3ggPCBfeGw7ICsrX3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0by5wdXNoKHRvQWRkcnNbX3hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ViamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5ib2R5ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5rbm93bkhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1t1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMF0sIG9wdGlvbnMpXSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5rbm93bkhlYWRlcnMpIG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgX3gyID0gMCwgX3hsMiA9IHRvLmxlbmd0aDsgX3gyIDwgX3hsMjsgKytfeDIpIHtcbiAgICAgICAgICAgIHZhciBhZGRyID0gdG9bX3gyXS5zcGxpdChcIkBcIik7XG4gICAgICAgICAgICBhZGRyWzBdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclswXSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmVycm9yID0gbWFpbHRvQ29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJbMV0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9bX3gyXSA9IGFkZHIuam9pbihcIkBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1haWx0b0NvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMShtYWlsdG9Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gbWFpbHRvQ29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gdG9BcnJheShtYWlsdG9Db21wb25lbnRzLnRvKTtcbiAgICAgICAgaWYgKHRvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvQWRkciA9IFN0cmluZyh0b1t4XSk7XG4gICAgICAgICAgICAgICAgdmFyIGF0SWR4ID0gdG9BZGRyLmxhc3RJbmRleE9mKFwiQFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQYXJ0ID0gdG9BZGRyLnNsaWNlKDAsIGF0SWR4KS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfTE9DQUxfUEFSVCwgcGN0RW5jQ2hhcik7XG4gICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRvQWRkci5zbGljZShhdElkeCArIDEpO1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChkb21haW4sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGRvbWFpbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9beF0gPSBsb2NhbFBhcnQgKyBcIkBcIiArIGRvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IHRvLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0KSBoZWFkZXJzW1wic3ViamVjdFwiXSA9IG1haWx0b0NvbXBvbmVudHMuc3ViamVjdDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuYm9keSkgaGVhZGVyc1tcImJvZHlcIl0gPSBtYWlsdG9Db21wb25lbnRzLmJvZHk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyc1tuYW1lXSAhPT0gT1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKG5hbWUucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGTkFNRSwgcGN0RW5jQ2hhcikgKyBcIj1cIiArIGhlYWRlcnNbbmFtZV0ucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGVkFMVUUsIHBjdEVuY0NoYXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IGZpZWxkcy5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVJOX1BBUlNFID0gL14oW15cXDpdKylcXDooLiopLztcbi8vUkZDIDIxNDFcbnZhciBoYW5kbGVyJDUgPSB7XG4gICAgc2NoZW1lOiBcInVyblwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5tYXRjaChVUk5fUEFSU0UpO1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcbiAgICAgICAgICAgIHZhciBuaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbnNzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gbnNzO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8IFwiVVJOIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cm5Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcbiAgICAgICAgdmFyIG5pZCA9IHVybkNvbXBvbmVudHMubmlkO1xuICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG4gICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVyaUNvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB2YXIgbnNzID0gdXJuQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHVyaUNvbXBvbmVudHMucGF0aCA9IChuaWQgfHwgb3B0aW9ucy5uaWQpICsgXCI6XCIgKyBuc3M7XG4gICAgICAgIHJldHVybiB1cmlDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVVUlEID0gL15bMC05QS1GYS1mXXs4fSg/OlxcLVswLTlBLUZhLWZdezR9KXszfVxcLVswLTlBLUZhLWZdezEyfSQvO1xuLy9SRkMgNDEyMlxudmFyIGhhbmRsZXIkNiA9IHtcbiAgICBzY2hlbWU6IFwidXJuOnV1aWRcIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB1dWlkQ29tcG9uZW50cy51dWlkID0gdXVpZENvbXBvbmVudHMubnNzO1xuICAgICAgICB1dWlkQ29tcG9uZW50cy5uc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnRzLnV1aWQgfHwgIXV1aWRDb21wb25lbnRzLnV1aWQubWF0Y2goVVVJRCkpKSB7XG4gICAgICAgICAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8IFwiVVVJRCBpcyBub3QgdmFsaWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV1aWRDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUodXVpZENvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50cztcbiAgICAgICAgLy9ub3JtYWxpemUgVVVJRFxuICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9ICh1dWlkQ29tcG9uZW50cy51dWlkIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB1cm5Db21wb25lbnRzO1xuICAgIH1cbn07XG5cblNDSEVNRVNbaGFuZGxlci5zY2hlbWVdID0gaGFuZGxlcjtcblNDSEVNRVNbaGFuZGxlciQxLnNjaGVtZV0gPSBoYW5kbGVyJDE7XG5TQ0hFTUVTW2hhbmRsZXIkMi5zY2hlbWVdID0gaGFuZGxlciQyO1xuU0NIRU1FU1toYW5kbGVyJDMuc2NoZW1lXSA9IGhhbmRsZXIkMztcblNDSEVNRVNbaGFuZGxlciQ0LnNjaGVtZV0gPSBoYW5kbGVyJDQ7XG5TQ0hFTUVTW2hhbmRsZXIkNS5zY2hlbWVdID0gaGFuZGxlciQ1O1xuU0NIRU1FU1toYW5kbGVyJDYuc2NoZW1lXSA9IGhhbmRsZXIkNjtcblxuZXhwb3J0cy5TQ0hFTUVTID0gU0NIRU1FUztcbmV4cG9ydHMucGN0RW5jQ2hhciA9IHBjdEVuY0NoYXI7XG5leHBvcnRzLnBjdERlY0NoYXJzID0gcGN0RGVjQ2hhcnM7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnJlbW92ZURvdFNlZ21lbnRzID0gcmVtb3ZlRG90U2VnbWVudHM7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmV4cG9ydHMucmVzb2x2ZUNvbXBvbmVudHMgPSByZXNvbHZlQ29tcG9uZW50cztcbmV4cG9ydHMucmVzb2x2ZSA9IHJlc29sdmU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZXF1YWwgPSBlcXVhbDtcbmV4cG9ydHMuZXNjYXBlQ29tcG9uZW50ID0gZXNjYXBlQ29tcG9uZW50O1xuZXhwb3J0cy51bmVzY2FwZUNvbXBvbmVudCA9IHVuZXNjYXBlQ29tcG9uZW50O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLmFsbC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIlVSSSIsIm1lcmdlIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNldHMiLCJBcnJheSIsIl9rZXkiLCJzbGljZSIsInhsIiwieCIsImpvaW4iLCJzdWJleHAiLCJzdHIiLCJ0eXBlT2YiLCJvIiwidW5kZWZpbmVkIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic3BsaXQiLCJwb3AiLCJzaGlmdCIsInRvTG93ZXJDYXNlIiwidG9VcHBlckNhc2UiLCJ0b0FycmF5Iiwib2JqIiwic2V0SW50ZXJ2YWwiLCJhc3NpZ24iLCJ0YXJnZXQiLCJzb3VyY2UiLCJrZXkiLCJidWlsZEV4cHMiLCJpc0lSSSIsIkFMUEhBJCQiLCJDUiQiLCJESUdJVCQkIiwiRFFVT1RFJCQiLCJIRVhESUckJCIsIkxGJCQiLCJTUCQkIiwiUENUX0VOQ09ERUQkIiwiR0VOX0RFTElNUyQkIiwiU1VCX0RFTElNUyQkIiwiUkVTRVJWRUQkJCIsIlVDU0NIQVIkJCIsIklQUklWQVRFJCQiLCJVTlJFU0VSVkVEJCQiLCJTQ0hFTUUkIiwiVVNFUklORk8kIiwiREVDX09DVEVUJCIsIkRFQ19PQ1RFVF9SRUxBWEVEJCIsIklQVjRBRERSRVNTJCIsIkgxNiQiLCJMUzMyJCIsIklQVjZBRERSRVNTMSQiLCJJUFY2QUREUkVTUzIkIiwiSVBWNkFERFJFU1MzJCIsIklQVjZBRERSRVNTNCQiLCJJUFY2QUREUkVTUzUkIiwiSVBWNkFERFJFU1M2JCIsIklQVjZBRERSRVNTNyQiLCJJUFY2QUREUkVTUzgkIiwiSVBWNkFERFJFU1M5JCIsIklQVjZBRERSRVNTJCIsIlpPTkVJRCQiLCJJUFY2QUREUlokIiwiSVBWNkFERFJaX1JFTEFYRUQkIiwiSVBWRlVUVVJFJCIsIklQX0xJVEVSQUwkIiwiUkVHX05BTUUkIiwiSE9TVCQiLCJQT1JUJCIsIkFVVEhPUklUWSQiLCJQQ0hBUiQiLCJTRUdNRU5UJCIsIlNFR01FTlRfTlokIiwiU0VHTUVOVF9OWl9OQyQiLCJQQVRIX0FCRU1QVFkkIiwiUEFUSF9BQlNPTFVURSQiLCJQQVRIX05PU0NIRU1FJCIsIlBBVEhfUk9PVExFU1MkIiwiUEFUSF9FTVBUWSQiLCJQQVRIJCIsIlFVRVJZJCIsIkZSQUdNRU5UJCIsIkhJRVJfUEFSVCQiLCJVUkkkIiwiUkVMQVRJVkVfUEFSVCQiLCJSRUxBVElWRSQiLCJVUklfUkVGRVJFTkNFJCIsIkFCU09MVVRFX1VSSSQiLCJHRU5FUklDX1JFRiQiLCJSRUxBVElWRV9SRUYkIiwiQUJTT0xVVEVfUkVGJCIsIlNBTUVET0NfUkVGJCIsIkFVVEhPUklUWV9SRUYkIiwiTk9UX1NDSEVNRSIsIlJlZ0V4cCIsIk5PVF9VU0VSSU5GTyIsIk5PVF9IT1NUIiwiTk9UX1BBVEgiLCJOT1RfUEFUSF9OT1NDSEVNRSIsIk5PVF9RVUVSWSIsIk5PVF9GUkFHTUVOVCIsIkVTQ0FQRSIsIlVOUkVTRVJWRUQiLCJPVEhFUl9DSEFSUyIsIlBDVF9FTkNPREVEIiwiSVBWNEFERFJFU1MiLCJJUFY2QUREUkVTUyIsIlVSSV9QUk9UT0NPTCIsIklSSV9QUk9UT0NPTCIsInNsaWNlZFRvQXJyYXkiLCJzbGljZUl0ZXJhdG9yIiwiYXJyIiwiaSIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJUeXBlRXJyb3IiLCJ0b0NvbnN1bWFibGVBcnJheSIsImFycjIiLCJmcm9tIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJlcnJvcnMiLCJiYXNlTWludXNUTWluIiwiZmxvb3IiLCJNYXRoIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXJyb3IkMSIsInR5cGUiLCJSYW5nZUVycm9yIiwibWFwIiwiYXJyYXkiLCJmbiIsInJlc3VsdCIsIm1hcERvbWFpbiIsInN0cmluZyIsInBhcnRzIiwicmVwbGFjZSIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsImNoYXJDb2RlQXQiLCJleHRyYSIsInVjczJlbmNvZGUiLCJmcm9tQ29kZVBvaW50IiwiYXBwbHkiLCJiYXNpY1RvRGlnaXQiLCJjb2RlUG9pbnQiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImZsYWciLCJhZGFwdCIsImRlbHRhIiwibnVtUG9pbnRzIiwiZmlyc3RUaW1lIiwiayIsImRlY29kZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJuIiwiYmlhcyIsImJhc2ljIiwibGFzdEluZGV4T2YiLCJqIiwiaW5kZXgiLCJvbGRpIiwidyIsInQiLCJiYXNlTWludXNUIiwib3V0Iiwic3BsaWNlIiwiZW5jb2RlIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJfc3RlcCIsIl9jdXJyZW50VmFsdWUyIiwicmV0dXJuIiwiYmFzaWNMZW5ndGgiLCJoYW5kbGVkQ1BDb3VudCIsIm0iLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiIsIl9kaWRJdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyIsIl9kaWRJdGVyYXRvckVycm9yMyIsIl9pdGVyYXRvckVycm9yMyIsIl9pdGVyYXRvcjMiLCJfc3RlcDMiLCJfY3VycmVudFZhbHVlIiwicSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0ZXN0IiwidG9BU0NJSSIsInB1bnljb2RlIiwiU0NIRU1FUyIsInBjdEVuY0NoYXIiLCJjaHIiLCJjIiwiZSIsInBjdERlY0NoYXJzIiwibmV3U3RyIiwiaWwiLCJwYXJzZUludCIsInN1YnN0ciIsImMyIiwiX2MiLCJjMyIsIl9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyIsImNvbXBvbmVudHMiLCJwcm90b2NvbCIsImRlY29kZVVucmVzZXJ2ZWQiLCJkZWNTdHIiLCJtYXRjaCIsInNjaGVtZSIsInVzZXJpbmZvIiwiaG9zdCIsInBhdGgiLCJxdWVyeSIsImZyYWdtZW50IiwiX3N0cmlwTGVhZGluZ1plcm9zIiwiX25vcm1hbGl6ZUlQdjQiLCJtYXRjaGVzIiwiX21hdGNoZXMiLCJhZGRyZXNzIiwiX25vcm1hbGl6ZUlQdjYiLCJfbWF0Y2hlczIiLCJ6b25lIiwiX2FkZHJlc3MkdG9Mb3dlckNhc2UkIiwicmV2ZXJzZSIsIl9hZGRyZXNzJHRvTG93ZXJDYXNlJDIiLCJsYXN0IiwiZmlyc3QiLCJmaXJzdEZpZWxkcyIsImxhc3RGaWVsZHMiLCJpc0xhc3RGaWVsZElQdjRBZGRyZXNzIiwiZmllbGRDb3VudCIsImxhc3RGaWVsZHNTdGFydCIsImZpZWxkcyIsImFsbFplcm9GaWVsZHMiLCJyZWR1Y2UiLCJhY2MiLCJmaWVsZCIsImxhc3RMb25nZXN0IiwibG9uZ2VzdFplcm9GaWVsZHMiLCJzb3J0IiwiYSIsImIiLCJuZXdIb3N0IiwibmV3Rmlyc3QiLCJuZXdMYXN0IiwiVVJJX1BBUlNFIiwiTk9fTUFUQ0hfSVNfVU5ERUZJTkVEIiwicGFyc2UiLCJ1cmlTdHJpbmciLCJvcHRpb25zIiwiaXJpIiwicmVmZXJlbmNlIiwicG9ydCIsImlzTmFOIiwiaW5kZXhPZiIsImVycm9yIiwic2NoZW1lSGFuZGxlciIsInVuaWNvZGVTdXBwb3J0IiwiZG9tYWluSG9zdCIsIl9yZWNvbXBvc2VBdXRob3JpdHkiLCJ1cmlUb2tlbnMiLCJfIiwiJDEiLCIkMiIsIlJEUzEiLCJSRFMyIiwiUkRTMyIsIlJEUzUiLCJyZW1vdmVEb3RTZWdtZW50cyIsImltIiwicyIsIkVycm9yIiwic2VyaWFsaXplIiwiYXV0aG9yaXR5IiwiY2hhckF0IiwiYWJzb2x1dGVQYXRoIiwicmVzb2x2ZUNvbXBvbmVudHMiLCJyZWxhdGl2ZSIsInNraXBOb3JtYWxpemF0aW9uIiwidG9sZXJhbnQiLCJyZXNvbHZlIiwiYmFzZVVSSSIsInJlbGF0aXZlVVJJIiwic2NoZW1lbGVzc09wdGlvbnMiLCJub3JtYWxpemUiLCJ1cmkiLCJlcXVhbCIsInVyaUEiLCJ1cmlCIiwiZXNjYXBlQ29tcG9uZW50IiwidW5lc2NhcGVDb21wb25lbnQiLCJoYW5kbGVyIiwic2VjdXJlIiwiaGFuZGxlciQxIiwiaXNTZWN1cmUiLCJ3c0NvbXBvbmVudHMiLCJoYW5kbGVyJDIiLCJyZXNvdXJjZU5hbWUiLCJfd3NDb21wb25lbnRzJHJlc291cmMiLCJfd3NDb21wb25lbnRzJHJlc291cmMyIiwiaGFuZGxlciQzIiwiTyIsIkFURVhUJCQiLCJRVEVYVCQkIiwiVkNIQVIkJCIsIlNPTUVfREVMSU1TJCQiLCJOT1RfTE9DQUxfUEFSVCIsIk5PVF9IRk5BTUUiLCJOT1RfSEZWQUxVRSIsImhhbmRsZXIkNCIsInBhcnNlJCQxIiwibWFpbHRvQ29tcG9uZW50cyIsInRvIiwidW5rbm93bkhlYWRlcnMiLCJoZWFkZXJzIiwiaGZpZWxkcyIsImhmaWVsZCIsInRvQWRkcnMiLCJfeCIsIl94bCIsInN1YmplY3QiLCJib2R5IiwiX3gyIiwiX3hsMiIsImFkZHIiLCJzZXJpYWxpemUkJDEiLCJ0b0FkZHIiLCJhdElkeCIsImxvY2FsUGFydCIsImRvbWFpbiIsIm5hbWUiLCJVUk5fUEFSU0UiLCJoYW5kbGVyJDUiLCJ1cm5Db21wb25lbnRzIiwibmlkIiwibnNzIiwidXJuU2NoZW1lIiwidXJpQ29tcG9uZW50cyIsIlVVSUQiLCJoYW5kbGVyJDYiLCJ1dWlkQ29tcG9uZW50cyIsInV1aWQiLCJkZWZpbmVQcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uri-js/dist/es5/uri.all.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    function merge() {\n        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++){\n            sets[_key] = arguments[_key];\n        }\n        if (sets.length > 1) {\n            sets[0] = sets[0].slice(0, -1);\n            var xl = sets.length - 1;\n            for(var x = 1; x < xl; ++x){\n                sets[x] = sets[x].slice(1, -1);\n            }\n            sets[xl] = sets[xl].slice(1);\n            return sets.join(\"\");\n        } else {\n            return sets[0];\n        }\n    }\n    function subexp(str) {\n        return \"(?:\" + str + \")\";\n    }\n    function typeOf(o) {\n        return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n    }\n    function toUpperCase(str) {\n        return str.toUpperCase();\n    }\n    function toArray(obj) {\n        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [\n            obj\n        ] : Array.prototype.slice.call(obj) : [];\n    }\n    function assign(target, source) {\n        var obj = target;\n        if (source) {\n            for(var key in source){\n                obj[key] = source[key];\n            }\n        }\n        return obj;\n    }\n    function buildExps(isIRI) {\n        var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), //case-insensitive\n        LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), //expanded\n        GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", //subset, excludes bidi control characters\n        IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", //subset\n        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$), //relaxed parsing rules\n        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n        IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n        IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"), //[ *6( h16 \":\" ) h16 ] \"::\"\n        IPV6ADDRESS$ = subexp([\n            IPV6ADDRESS1$,\n            IPV6ADDRESS2$,\n            IPV6ADDRESS3$,\n            IPV6ADDRESS4$,\n            IPV6ADDRESS5$,\n            IPV6ADDRESS6$,\n            IPV6ADDRESS7$,\n            IPV6ADDRESS8$,\n            IPV6ADDRESS9$\n        ].join(\"|\")), ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"), //RFC 6874\n        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$), //RFC 6874\n        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$), //RFC 6874, with relaxed parsing rules\n        IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), //RFC 6874\n        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), //simplified\n        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified\n        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified\n        PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n        return {\n            NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n            NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n            NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n            ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n            OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n            PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n            IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n            IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n        };\n    }\n    var URI_PROTOCOL = buildExps(false);\n    var IRI_PROTOCOL = buildExps(true);\n    var slicedToArray = function() {\n        function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n            try {\n                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                    _arr.push(_s.value);\n                    if (i && _arr.length === i) break;\n                }\n            } catch (err) {\n                _d = true;\n                _e = err;\n            } finally{\n                try {\n                    if (!_n && _i[\"return\"]) _i[\"return\"]();\n                } finally{\n                    if (_d) throw _e;\n                }\n            }\n            return _arr;\n        }\n        return function(arr, i) {\n            if (Array.isArray(arr)) {\n                return arr;\n            } else if (Symbol.iterator in Object(arr)) {\n                return sliceIterator(arr, i);\n            } else {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n            }\n        };\n    }();\n    var toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];\n            return arr2;\n        } else {\n            return Array.from(arr);\n        }\n    };\n    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n    /** Bootstring parameters */ var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128; // 0x80\n    var delimiter = \"-\"; // '\\x2D'\n    /** Regular expressions */ var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n    /** Error messages */ var errors = {\n        \"overflow\": \"Overflow: input needs wider integers to process\",\n        \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n        \"invalid-input\": \"Invalid input\"\n    };\n    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    /*--------------------------------------------------------------------------*/ /**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */ function error$1(type) {\n        throw new RangeError(errors[type]);\n    }\n    /**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */ function map(array, fn) {\n        var result = [];\n        var length = array.length;\n        while(length--){\n            result[length] = fn(array[length]);\n        }\n        return result;\n    }\n    /**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */ function mapDomain(string, fn) {\n        var parts = string.split(\"@\");\n        var result = \"\";\n        if (parts.length > 1) {\n            // In email addresses, only the domain name should be punycoded. Leave\n            // the local part (i.e. everything up to `@`) intact.\n            result = parts[0] + \"@\";\n            string = parts[1];\n        }\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, \".\");\n        var labels = string.split(\".\");\n        var encoded = map(labels, fn).join(\".\");\n        return result + encoded;\n    }\n    /**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */ function ucs2decode(string) {\n        var output = [];\n        var counter = 0;\n        var length = string.length;\n        while(counter < length){\n            var value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // It's a high surrogate, and there is a next character.\n                var extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {\n                    // Low surrogate.\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                    // It's an unmatched surrogate; only append this code unit, in case the\n                    // next code unit is the high surrogate of a surrogate pair.\n                    output.push(value);\n                    counter--;\n                }\n            } else {\n                output.push(value);\n            }\n        }\n        return output;\n    }\n    /**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */ var ucs2encode = function ucs2encode(array) {\n        return String.fromCodePoint.apply(String, toConsumableArray(array));\n    };\n    /**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */ var basicToDigit = function basicToDigit(codePoint) {\n        if (codePoint - 0x30 < 0x0A) {\n            return codePoint - 0x16;\n        }\n        if (codePoint - 0x41 < 0x1A) {\n            return codePoint - 0x41;\n        }\n        if (codePoint - 0x61 < 0x1A) {\n            return codePoint - 0x61;\n        }\n        return base;\n    };\n    /**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */ var digitToBasic = function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    /**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */ var adapt = function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for(; delta > baseMinusTMin * tMax >> 1; k += base){\n            delta = floor(delta / baseMinusTMin);\n        }\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    /**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */ var decode = function decode(input) {\n        // Don't use UCS-2.\n        var output = [];\n        var inputLength = input.length;\n        var i = 0;\n        var n = initialN;\n        var bias = initialBias;\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n        var basic = input.lastIndexOf(delimiter);\n        if (basic < 0) {\n            basic = 0;\n        }\n        for(var j = 0; j < basic; ++j){\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) {\n                error$1(\"not-basic\");\n            }\n            output.push(input.charCodeAt(j));\n        }\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            var oldi = i;\n            for(var w = 1, k = base;; k += base){\n                if (index >= inputLength) {\n                    error$1(\"invalid-input\");\n                }\n                var digit = basicToDigit(input.charCodeAt(index++));\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error$1(\"overflow\");\n                }\n                i += digit * w;\n                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (digit < t) {\n                    break;\n                }\n                var baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                    error$1(\"overflow\");\n                }\n                w *= baseMinusT;\n            }\n            var out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0);\n            // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) {\n                error$1(\"overflow\");\n            }\n            n += floor(i / out);\n            i %= out;\n            // Insert `n` at position `i` of the output.\n            output.splice(i++, 0, n);\n        }\n        return String.fromCodePoint.apply(String, output);\n    };\n    /**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */ var encode = function encode(input) {\n        var output = [];\n        // Convert the input in UCS-2 to an array of Unicode code points.\n        input = ucs2decode(input);\n        // Cache the length.\n        var inputLength = input.length;\n        // Initialize the state.\n        var n = initialN;\n        var delta = 0;\n        var bias = initialBias;\n        // Handle the basic code points.\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _currentValue2 = _step.value;\n                if (_currentValue2 < 0x80) {\n                    output.push(stringFromCharCode(_currentValue2));\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        var basicLength = output.length;\n        var handledCPCount = basicLength;\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n        // Finish the basic string with a delimiter unless it's empty.\n        if (basicLength) {\n            output.push(delimiter);\n        }\n        // Main encoding loop:\n        while(handledCPCount < inputLength){\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            var m = maxInt;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                    var currentValue = _step2.value;\n                    if (currentValue >= n && currentValue < m) {\n                        m = currentValue;\n                    }\n                }\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow.\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally{\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n            var handledCPCountPlusOne = handledCPCount + 1;\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error$1(\"overflow\");\n            }\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n            try {\n                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n                    var _currentValue = _step3.value;\n                    if (_currentValue < n && ++delta > maxInt) {\n                        error$1(\"overflow\");\n                    }\n                    if (_currentValue == n) {\n                        // Represent delta as a generalized variable-length integer.\n                        var q = delta;\n                        for(var k = base;; k += base){\n                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                            if (q < t) {\n                                break;\n                            }\n                            var qMinusT = q - t;\n                            var baseMinusT = base - t;\n                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                            q = floor(qMinusT / baseMinusT);\n                        }\n                        output.push(stringFromCharCode(digitToBasic(q, 0)));\n                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                        delta = 0;\n                        ++handledCPCount;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally{\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n            ++delta;\n            ++n;\n        }\n        return output.join(\"\");\n    };\n    /**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */ var toUnicode = function toUnicode(input) {\n        return mapDomain(input, function(string) {\n            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n        });\n    };\n    /**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */ var toASCII = function toASCII(input) {\n        return mapDomain(input, function(string) {\n            return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n        });\n    };\n    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {\n        /**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */ \"version\": \"2.1.0\",\n        /**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */ \"ucs2\": {\n            \"decode\": ucs2decode,\n            \"encode\": ucs2encode\n        },\n        \"decode\": decode,\n        \"encode\": encode,\n        \"toASCII\": toASCII,\n        \"toUnicode\": toUnicode\n    };\n    /**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */ /**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */ var SCHEMES = {};\n    function pctEncChar(chr) {\n        var c = chr.charCodeAt(0);\n        var e = void 0;\n        if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n        else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n        else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        return e;\n    }\n    function pctDecChars(str) {\n        var newStr = \"\";\n        var i = 0;\n        var il = str.length;\n        while(i < il){\n            var c = parseInt(str.substr(i + 1, 2), 16);\n            if (c < 128) {\n                newStr += String.fromCharCode(c);\n                i += 3;\n            } else if (c >= 194 && c < 224) {\n                if (il - i >= 6) {\n                    var c2 = parseInt(str.substr(i + 4, 2), 16);\n                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n                } else {\n                    newStr += str.substr(i, 6);\n                }\n                i += 6;\n            } else if (c >= 224) {\n                if (il - i >= 9) {\n                    var _c = parseInt(str.substr(i + 4, 2), 16);\n                    var c3 = parseInt(str.substr(i + 7, 2), 16);\n                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n                } else {\n                    newStr += str.substr(i, 9);\n                }\n                i += 9;\n            } else {\n                newStr += str.substr(i, 3);\n                i += 3;\n            }\n        }\n        return newStr;\n    }\n    function _normalizeComponentEncoding(components, protocol) {\n        function decodeUnreserved(str) {\n            var decStr = pctDecChars(str);\n            return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n        }\n        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        return components;\n    }\n    function _stripLeadingZeros(str) {\n        return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n    }\n    function _normalizeIPv4(host, protocol) {\n        var matches = host.match(protocol.IPV4ADDRESS) || [];\n        var _matches = slicedToArray(matches, 2), address = _matches[1];\n        if (address) {\n            return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n        } else {\n            return host;\n        }\n    }\n    function _normalizeIPv6(host, protocol) {\n        var matches = host.match(protocol.IPV6ADDRESS) || [];\n        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];\n        if (address) {\n            var _address$toLowerCase$ = address.toLowerCase().split(\"::\").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];\n            var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n            var lastFields = last.split(\":\").map(_stripLeadingZeros);\n            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n            var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n            var lastFieldsStart = lastFields.length - fieldCount;\n            var fields = Array(fieldCount);\n            for(var x = 0; x < fieldCount; ++x){\n                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || \"\";\n            }\n            if (isLastFieldIPv4Address) {\n                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n            }\n            var allZeroFields = fields.reduce(function(acc, field, index) {\n                if (!field || field === \"0\") {\n                    var lastLongest = acc[acc.length - 1];\n                    if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                        lastLongest.length++;\n                    } else {\n                        acc.push({\n                            index: index,\n                            length: 1\n                        });\n                    }\n                }\n                return acc;\n            }, []);\n            var longestZeroFields = allZeroFields.sort(function(a, b) {\n                return b.length - a.length;\n            })[0];\n            var newHost = void 0;\n            if (longestZeroFields && longestZeroFields.length > 1) {\n                var newFirst = fields.slice(0, longestZeroFields.index);\n                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n                newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n            } else {\n                newHost = fields.join(\":\");\n            }\n            if (zone) {\n                newHost += \"%\" + zone;\n            }\n            return newHost;\n        } else {\n            return host;\n        }\n    }\n    var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n    var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n    function parse(uriString) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var components = {};\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n        var matches = uriString.match(URI_PARSE);\n        if (matches) {\n            if (NO_MATCH_IS_UNDEFINED) {\n                //store each component\n                components.scheme = matches[1];\n                components.userinfo = matches[3];\n                components.host = matches[4];\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = matches[7];\n                components.fragment = matches[8];\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = matches[5];\n                }\n            } else {\n                //IE FIX for improper RegExp matching\n                //store each component\n                components.scheme = matches[1] || undefined;\n                components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n                components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n                components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n                }\n            }\n            if (components.host) {\n                //normalize IP hosts\n                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n            }\n            //determine reference type\n            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n                components.reference = \"same-document\";\n            } else if (components.scheme === undefined) {\n                components.reference = \"relative\";\n            } else if (components.fragment === undefined) {\n                components.reference = \"absolute\";\n            } else {\n                components.reference = \"uri\";\n            }\n            //check for reference errors\n            if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n                components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n            }\n            //find scheme handler\n            var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n            //check if scheme can't handle IRIs\n            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n                //if host component is a domain name\n                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                    } catch (e) {\n                        components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                }\n                //convert IRI -> URI\n                _normalizeComponentEncoding(components, URI_PROTOCOL);\n            } else {\n                //normalize encodings\n                _normalizeComponentEncoding(components, protocol);\n            }\n            //perform scheme specific parsing\n            if (schemeHandler && schemeHandler.parse) {\n                schemeHandler.parse(components, options);\n            }\n        } else {\n            components.error = components.error || \"URI can not be parsed.\";\n        }\n        return components;\n    }\n    function _recomposeAuthority(components, options) {\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        if (components.userinfo !== undefined) {\n            uriTokens.push(components.userinfo);\n            uriTokens.push(\"@\");\n        }\n        if (components.host !== undefined) {\n            //normalize IP hosts, add brackets and escape zone separator for IPv6\n            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {\n                return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n            }));\n        }\n        if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n            uriTokens.push(\":\");\n            uriTokens.push(String(components.port));\n        }\n        return uriTokens.length ? uriTokens.join(\"\") : undefined;\n    }\n    var RDS1 = /^\\.\\.?\\//;\n    var RDS2 = /^\\/\\.(\\/|$)/;\n    var RDS3 = /^\\/\\.\\.(\\/|$)/;\n    var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n    function removeDotSegments(input) {\n        var output = [];\n        while(input.length){\n            if (input.match(RDS1)) {\n                input = input.replace(RDS1, \"\");\n            } else if (input.match(RDS2)) {\n                input = input.replace(RDS2, \"/\");\n            } else if (input.match(RDS3)) {\n                input = input.replace(RDS3, \"/\");\n                output.pop();\n            } else if (input === \".\" || input === \"..\") {\n                input = \"\";\n            } else {\n                var im = input.match(RDS5);\n                if (im) {\n                    var s = im[0];\n                    input = input.slice(s.length);\n                    output.push(s);\n                } else {\n                    throw new Error(\"Unexpected dot segment condition\");\n                }\n            }\n        }\n        return output.join(\"\");\n    }\n    function serialize(components) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //perform scheme specific serialization\n        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n        if (components.host) {\n            //if host component is an IPv6 address\n            if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n        }\n        //normalize encoding\n        _normalizeComponentEncoding(components, protocol);\n        if (options.reference !== \"suffix\" && components.scheme) {\n            uriTokens.push(components.scheme);\n            uriTokens.push(\":\");\n        }\n        var authority = _recomposeAuthority(components, options);\n        if (authority !== undefined) {\n            if (options.reference !== \"suffix\") {\n                uriTokens.push(\"//\");\n            }\n            uriTokens.push(authority);\n            if (components.path && components.path.charAt(0) !== \"/\") {\n                uriTokens.push(\"/\");\n            }\n        }\n        if (components.path !== undefined) {\n            var s = components.path;\n            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n                s = removeDotSegments(s);\n            }\n            if (authority === undefined) {\n                s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n            }\n            uriTokens.push(s);\n        }\n        if (components.query !== undefined) {\n            uriTokens.push(\"?\");\n            uriTokens.push(components.query);\n        }\n        if (components.fragment !== undefined) {\n            uriTokens.push(\"#\");\n            uriTokens.push(components.fragment);\n        }\n        return uriTokens.join(\"\"); //merge tokens into a string\n    }\n    function resolveComponents(base, relative) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var skipNormalization = arguments[3];\n        var target = {};\n        if (!skipNormalization) {\n            base = parse(serialize(base, options), options); //normalize base components\n            relative = parse(serialize(relative, options), options); //normalize relative components\n        }\n        options = options || {};\n        if (!options.tolerant && relative.scheme) {\n            target.scheme = relative.scheme;\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n                //target.authority = relative.authority;\n                target.userinfo = relative.userinfo;\n                target.host = relative.host;\n                target.port = relative.port;\n                target.path = removeDotSegments(relative.path || \"\");\n                target.query = relative.query;\n            } else {\n                if (!relative.path) {\n                    target.path = base.path;\n                    if (relative.query !== undefined) {\n                        target.query = relative.query;\n                    } else {\n                        target.query = base.query;\n                    }\n                } else {\n                    if (relative.path.charAt(0) === \"/\") {\n                        target.path = removeDotSegments(relative.path);\n                    } else {\n                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                            target.path = \"/\" + relative.path;\n                        } else if (!base.path) {\n                            target.path = relative.path;\n                        } else {\n                            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                        }\n                        target.path = removeDotSegments(target.path);\n                    }\n                    target.query = relative.query;\n                }\n                //target.authority = base.authority;\n                target.userinfo = base.userinfo;\n                target.host = base.host;\n                target.port = base.port;\n            }\n            target.scheme = base.scheme;\n        }\n        target.fragment = relative.fragment;\n        return target;\n    }\n    function resolve(baseURI, relativeURI, options) {\n        var schemelessOptions = assign({\n            scheme: \"null\"\n        }, options);\n        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n    }\n    function normalize(uri, options) {\n        if (typeof uri === \"string\") {\n            uri = serialize(parse(uri, options), options);\n        } else if (typeOf(uri) === \"object\") {\n            uri = parse(serialize(uri, options), options);\n        }\n        return uri;\n    }\n    function equal(uriA, uriB, options) {\n        if (typeof uriA === \"string\") {\n            uriA = serialize(parse(uriA, options), options);\n        } else if (typeOf(uriA) === \"object\") {\n            uriA = serialize(uriA, options);\n        }\n        if (typeof uriB === \"string\") {\n            uriB = serialize(parse(uriB, options), options);\n        } else if (typeOf(uriB) === \"object\") {\n            uriB = serialize(uriB, options);\n        }\n        return uriA === uriB;\n    }\n    function escapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n    }\n    function unescapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n    }\n    var handler = {\n        scheme: \"http\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            //report missing host\n            if (!components.host) {\n                components.error = components.error || \"HTTP URIs must have a host.\";\n            }\n            return components;\n        },\n        serialize: function serialize(components, options) {\n            var secure = String(components.scheme).toLowerCase() === \"https\";\n            //normalize the default port\n            if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n                components.port = undefined;\n            }\n            //normalize the empty path\n            if (!components.path) {\n                components.path = \"/\";\n            }\n            //NOTE: We do not parse query strings for HTTP URIs\n            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n            //and not the HTTP spec.\n            return components;\n        }\n    };\n    var handler$1 = {\n        scheme: \"https\",\n        domainHost: handler.domainHost,\n        parse: handler.parse,\n        serialize: handler.serialize\n    };\n    function isSecure(wsComponents) {\n        return typeof wsComponents.secure === \"boolean\" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n    }\n    //RFC 6455\n    var handler$2 = {\n        scheme: \"ws\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            var wsComponents = components;\n            //indicate if the secure flag is set\n            wsComponents.secure = isSecure(wsComponents);\n            //construct resouce name\n            wsComponents.resourceName = (wsComponents.path || \"/\") + (wsComponents.query ? \"?\" + wsComponents.query : \"\");\n            wsComponents.path = undefined;\n            wsComponents.query = undefined;\n            return wsComponents;\n        },\n        serialize: function serialize(wsComponents, options) {\n            //normalize the default port\n            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n                wsComponents.port = undefined;\n            }\n            //ensure scheme matches secure flag\n            if (typeof wsComponents.secure === \"boolean\") {\n                wsComponents.scheme = wsComponents.secure ? \"wss\" : \"ws\";\n                wsComponents.secure = undefined;\n            }\n            //reconstruct path from resource name\n            if (wsComponents.resourceName) {\n                var _wsComponents$resourc = wsComponents.resourceName.split(\"?\"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];\n                wsComponents.path = path && path !== \"/\" ? path : undefined;\n                wsComponents.query = query;\n                wsComponents.resourceName = undefined;\n            }\n            //forbid fragment component\n            wsComponents.fragment = undefined;\n            return wsComponents;\n        }\n    };\n    var handler$3 = {\n        scheme: \"wss\",\n        domainHost: handler$2.domainHost,\n        parse: handler$2.parse,\n        serialize: handler$2.serialize\n    };\n    var O = {};\n    var isIRI = true;\n    //RFC 3986\n    var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n    var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n    var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n    //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n    //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n    //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n    //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n    //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n    //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n    var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n    var VCHAR$$ = merge(QTEXT$$, '[\\\\\"\\\\\\\\]');\n    var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n    var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n    var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n    var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n    var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n    var NOT_HFVALUE = NOT_HFNAME;\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(UNRESERVED) ? str : decStr;\n    }\n    var handler$4 = {\n        scheme: \"mailto\",\n        parse: function parse$$1(components, options) {\n            var mailtoComponents = components;\n            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n            mailtoComponents.path = undefined;\n            if (mailtoComponents.query) {\n                var unknownHeaders = false;\n                var headers = {};\n                var hfields = mailtoComponents.query.split(\"&\");\n                for(var x = 0, xl = hfields.length; x < xl; ++x){\n                    var hfield = hfields[x].split(\"=\");\n                    switch(hfield[0]){\n                        case \"to\":\n                            var toAddrs = hfield[1].split(\",\");\n                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x){\n                                to.push(toAddrs[_x]);\n                            }\n                            break;\n                        case \"subject\":\n                            mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                            break;\n                        case \"body\":\n                            mailtoComponents.body = unescapeComponent(hfield[1], options);\n                            break;\n                        default:\n                            unknownHeaders = true;\n                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                            break;\n                    }\n                }\n                if (unknownHeaders) mailtoComponents.headers = headers;\n            }\n            mailtoComponents.query = undefined;\n            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){\n                var addr = to[_x2].split(\"@\");\n                addr[0] = unescapeComponent(addr[0]);\n                if (!options.unicodeSupport) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                    } catch (e) {\n                        mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                } else {\n                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n                }\n                to[_x2] = addr.join(\"@\");\n            }\n            return mailtoComponents;\n        },\n        serialize: function serialize$$1(mailtoComponents, options) {\n            var components = mailtoComponents;\n            var to = toArray(mailtoComponents.to);\n            if (to) {\n                for(var x = 0, xl = to.length; x < xl; ++x){\n                    var toAddr = String(to[x]);\n                    var atIdx = toAddr.lastIndexOf(\"@\");\n                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                    var domain = toAddr.slice(atIdx + 1);\n                    //convert IDN via punycode\n                    try {\n                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                    } catch (e) {\n                        components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                    }\n                    to[x] = localPart + \"@\" + domain;\n                }\n                components.path = to.join(\",\");\n            }\n            var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n            if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n            if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n            var fields = [];\n            for(var name in headers){\n                if (headers[name] !== O[name]) {\n                    fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n                }\n            }\n            if (fields.length) {\n                components.query = fields.join(\"&\");\n            }\n            return components;\n        }\n    };\n    var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n    //RFC 2141\n    var handler$5 = {\n        scheme: \"urn\",\n        parse: function parse$$1(components, options) {\n            var matches = components.path && components.path.match(URN_PARSE);\n            var urnComponents = components;\n            if (matches) {\n                var scheme = options.scheme || urnComponents.scheme || \"urn\";\n                var nid = matches[1].toLowerCase();\n                var nss = matches[2];\n                var urnScheme = scheme + \":\" + (options.nid || nid);\n                var schemeHandler = SCHEMES[urnScheme];\n                urnComponents.nid = nid;\n                urnComponents.nss = nss;\n                urnComponents.path = undefined;\n                if (schemeHandler) {\n                    urnComponents = schemeHandler.parse(urnComponents, options);\n                }\n            } else {\n                urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n            }\n            return urnComponents;\n        },\n        serialize: function serialize$$1(urnComponents, options) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = urnComponents.nid;\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            if (schemeHandler) {\n                urnComponents = schemeHandler.serialize(urnComponents, options);\n            }\n            var uriComponents = urnComponents;\n            var nss = urnComponents.nss;\n            uriComponents.path = (nid || options.nid) + \":\" + nss;\n            return uriComponents;\n        }\n    };\n    var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n    //RFC 4122\n    var handler$6 = {\n        scheme: \"urn:uuid\",\n        parse: function parse(urnComponents, options) {\n            var uuidComponents = urnComponents;\n            uuidComponents.uuid = uuidComponents.nss;\n            uuidComponents.nss = undefined;\n            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n                uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n            }\n            return uuidComponents;\n        },\n        serialize: function serialize(uuidComponents, options) {\n            var urnComponents = uuidComponents;\n            //normalize UUID\n            urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n            return urnComponents;\n        }\n    };\n    SCHEMES[handler.scheme] = handler;\n    SCHEMES[handler$1.scheme] = handler$1;\n    SCHEMES[handler$2.scheme] = handler$2;\n    SCHEMES[handler$3.scheme] = handler$3;\n    SCHEMES[handler$4.scheme] = handler$4;\n    SCHEMES[handler$5.scheme] = handler$5;\n    SCHEMES[handler$6.scheme] = handler$6;\n    exports1.SCHEMES = SCHEMES;\n    exports1.pctEncChar = pctEncChar;\n    exports1.pctDecChars = pctDecChars;\n    exports1.parse = parse;\n    exports1.removeDotSegments = removeDotSegments;\n    exports1.serialize = serialize;\n    exports1.resolveComponents = resolveComponents;\n    exports1.resolve = resolve;\n    exports1.normalize = normalize;\n    exports1.equal = equal;\n    exports1.escapeComponent = escapeComponent;\n    exports1.unescapeComponent = unescapeComponent;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=uri.all.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXJpLWpzL2Rpc3QvZXM1L3VyaS5hbGwuanMiLCJtYXBwaW5ncyI6IkFBQUEsNEZBQTRGLEdBQzNGLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN6QixLQUFpRCxHQUFjQSxRQUFRQyxXQUN2RSxDQUN3QztBQUN6QyxHQUFFLElBQUksRUFBRyxTQUFVQSxRQUFPO0lBQUk7SUFFOUIsU0FBU0s7UUFDTCxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBT0MsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1lBQ2pGRixJQUFJLENBQUNFLEtBQUssR0FBR0osU0FBUyxDQUFDSSxLQUFLO1FBQ2hDO1FBRUEsSUFBSUYsS0FBS0QsTUFBTSxHQUFHLEdBQUc7WUFDakJDLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLENBQUNHLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDNUIsSUFBSUMsS0FBS0osS0FBS0QsTUFBTSxHQUFHO1lBQ3ZCLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJRCxJQUFJLEVBQUVDLEVBQUc7Z0JBQ3pCTCxJQUFJLENBQUNLLEVBQUUsR0FBR0wsSUFBSSxDQUFDSyxFQUFFLENBQUNGLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDaEM7WUFDQUgsSUFBSSxDQUFDSSxHQUFHLEdBQUdKLElBQUksQ0FBQ0ksR0FBRyxDQUFDRCxLQUFLLENBQUM7WUFDMUIsT0FBT0gsS0FBS00sSUFBSSxDQUFDO1FBQ3JCLE9BQU87WUFDSCxPQUFPTixJQUFJLENBQUMsRUFBRTtRQUNsQjtJQUNKO0lBQ0EsU0FBU08sT0FBT0MsR0FBRztRQUNmLE9BQU8sUUFBUUEsTUFBTTtJQUN6QjtJQUNBLFNBQVNDLE9BQU9DLENBQUM7UUFDYixPQUFPQSxNQUFNQyxZQUFZLGNBQWNELE1BQU0sT0FBTyxTQUFTRSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTCxHQUFH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LFVBQVVyRixNQUFNLENBQUMsR0FBR3FGO0lBQzVCeEcsT0FBTyxDQUFDMkcsVUFBVXhGLE1BQU0sQ0FBQyxHQUFHd0Y7SUFDNUIzRyxPQUFPLENBQUMrRyxVQUFVNUYsTUFBTSxDQUFDLEdBQUc0RjtJQUM1Qi9HLE9BQU8sQ0FBQ3dILFVBQVVyRyxNQUFNLENBQUMsR0FBR3FHO0lBQzVCeEgsT0FBTyxDQUFDK0ksVUFBVTVILE1BQU0sQ0FBQyxHQUFHNEg7SUFDNUIvSSxPQUFPLENBQUNzSixVQUFVbkksTUFBTSxDQUFDLEdBQUdtSTtJQUU1QmpZLFNBQVEyTyxPQUFPLEdBQUdBO0lBQ2xCM08sU0FBUTRPLFVBQVUsR0FBR0E7SUFDckI1TyxTQUFRZ1AsV0FBVyxHQUFHQTtJQUN0QmhQLFNBQVFxUyxLQUFLLEdBQUdBO0lBQ2hCclMsU0FBUTBULGlCQUFpQixHQUFHQTtJQUM1QjFULFNBQVE4VCxTQUFTLEdBQUdBO0lBQ3BCOVQsU0FBUWtVLGlCQUFpQixHQUFHQTtJQUM1QmxVLFNBQVFzVSxPQUFPLEdBQUdBO0lBQ2xCdFUsU0FBUTBVLFNBQVMsR0FBR0E7SUFDcEIxVSxTQUFRNFUsS0FBSyxHQUFHQTtJQUNoQjVVLFNBQVErVSxlQUFlLEdBQUdBO0lBQzFCL1UsU0FBUWdWLGlCQUFpQixHQUFHQTtJQUU1QjNULE9BQU8rVyxjQUFjLENBQUNwWSxVQUFTLGNBQWM7UUFBRXFJLE9BQU87SUFBSztBQUUzRCxJQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzP2U3ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFVSSS5qcyB2NC40LjEgKGMpIDIwMTEgR2FyeSBDb3VydC4gTGljZW5zZTogaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qcyAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLlVSSSA9IGdsb2JhbC5VUkkgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzZXRzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHNldHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHNldHMubGVuZ3RoID4gMSkge1xuICAgICAgICBzZXRzWzBdID0gc2V0c1swXS5zbGljZSgwLCAtMSk7XG4gICAgICAgIHZhciB4bCA9IHNldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICBzZXRzW3hdID0gc2V0c1t4XS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0c1t4bF0gPSBzZXRzW3hsXS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIHNldHMuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNldHNbMF07XG4gICAgfVxufVxuZnVuY3Rpb24gc3ViZXhwKHN0cikge1xuICAgIHJldHVybiBcIig/OlwiICsgc3RyICsgXCIpXCI7XG59XG5mdW5jdGlvbiB0eXBlT2Yobykge1xuICAgIHJldHVybiBvID09PSB1bmRlZmluZWQgPyBcInVuZGVmaW5lZFwiIDogbyA9PT0gbnVsbCA/IFwibnVsbFwiIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNwbGl0KFwiIFwiKS5wb3AoKS5zcGxpdChcIl1cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsID8gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiB0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBvYmouc3BsaXQgfHwgb2JqLnNldEludGVydmFsIHx8IG9iai5jYWxsID8gW29ial0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopIDogW107XG59XG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB2YXIgb2JqID0gdGFyZ2V0O1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBidWlsZEV4cHMoaXNJUkkpIHtcbiAgICB2YXIgQUxQSEEkJCA9IFwiW0EtWmEtel1cIixcbiAgICAgICAgQ1IkID0gXCJbXFxcXHgwRF1cIixcbiAgICAgICAgRElHSVQkJCA9IFwiWzAtOV1cIixcbiAgICAgICAgRFFVT1RFJCQgPSBcIltcXFxceDIyXVwiLFxuICAgICAgICBIRVhESUckJCA9IG1lcmdlKERJR0lUJCQsIFwiW0EtRmEtZl1cIiksXG4gICAgICAgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuICAgIExGJCQgPSBcIltcXFxceDBBXVwiLFxuICAgICAgICBTUCQkID0gXCJbXFxcXHgyMF1cIixcbiAgICAgICAgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpLFxuICAgICAgICAvL2V4cGFuZGVkXG4gICAgR0VOX0RFTElNUyQkID0gXCJbXFxcXDpcXFxcL1xcXFw/XFxcXCNcXFxcW1xcXFxdXFxcXEBdXCIsXG4gICAgICAgIFNVQl9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJlxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXD1dXCIsXG4gICAgICAgIFJFU0VSVkVEJCQgPSBtZXJnZShHRU5fREVMSU1TJCQsIFNVQl9ERUxJTVMkJCksXG4gICAgICAgIFVDU0NIQVIkJCA9IGlzSVJJID8gXCJbXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXVwiIDogXCJbXVwiLFxuICAgICAgICAvL3N1YnNldCwgZXhjbHVkZXMgYmlkaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBJUFJJVkFURSQkID0gaXNJUkkgPyBcIltcXFxcdUUwMDAtXFxcXHVGOEZGXVwiIDogXCJbXVwiLFxuICAgICAgICAvL3N1YnNldFxuICAgIFVOUkVTRVJWRUQkJCA9IG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwtXFxcXC5cXFxcX1xcXFx+XVwiLCBVQ1NDSEFSJCQpLFxuICAgICAgICBTQ0hFTUUkID0gc3ViZXhwKEFMUEhBJCQgKyBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpICsgXCIqXCIpLFxuICAgICAgICBVU0VSSU5GTyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSkgKyBcIipcIiksXG4gICAgICAgIERFQ19PQ1RFVCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCJbMS05XVwiICsgRElHSVQkJCkgKyBcInxcIiArIERJR0lUJCQpLFxuICAgICAgICBERUNfT0NURVRfUkVMQVhFRCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIwP1sxLTldXCIgKyBESUdJVCQkKSArIFwifDA/MD9cIiArIERJR0lUJCQpLFxuICAgICAgICAvL3JlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVjRBRERSRVNTJCA9IHN1YmV4cChERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQpLFxuICAgICAgICBIMTYkID0gc3ViZXhwKEhFWERJRyQkICsgXCJ7MSw0fVwiKSxcbiAgICAgICAgTFMzMiQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIgKyBIMTYkKSArIFwifFwiICsgSVBWNEFERFJFU1MkKSxcbiAgICAgICAgSVBWNkFERFJFU1MxJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns2fVwiICsgTFMzMiQpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzIkID0gc3ViZXhwKFwiXFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NX1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgXCI6OlwiIDUoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzMkID0gc3ViZXhwKHN1YmV4cChIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezR9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M0JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwxfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInszfVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjEoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAzKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M1JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwyfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInsyfVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjIoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAyKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M2JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwzfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBIMTYkICsgXCJcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG4gICAgSVBWNkFERFJFU1M3JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw0fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqNCggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBsczMyXG4gICAgSVBWNkFERFJFU1M4JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw1fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBIMTYkKSxcbiAgICAgICAgLy9bICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuICAgIElQVjZBRERSRVNTOSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiKSxcbiAgICAgICAgLy9bICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcbiAgICBJUFY2QUREUkVTUyQgPSBzdWJleHAoW0lQVjZBRERSRVNTMSQsIElQVjZBRERSRVNTMiQsIElQVjZBRERSRVNTMyQsIElQVjZBRERSRVNTNCQsIElQVjZBRERSRVNTNSQsIElQVjZBRERSRVNTNiQsIElQVjZBRERSRVNTNyQsIElQVjZBRERSRVNTOCQsIElQVjZBRERSRVNTOSRdLmpvaW4oXCJ8XCIpKSxcbiAgICAgICAgWk9ORUlEJCA9IHN1YmV4cChzdWJleHAoVU5SRVNFUlZFRCQkICsgXCJ8XCIgKyBQQ1RfRU5DT0RFRCQpICsgXCIrXCIpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgSVBWNkFERFJaJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBcIlxcXFwlMjVcIiArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgSVBWNkFERFJaX1JFTEFYRUQkID0gc3ViZXhwKElQVjZBRERSRVNTJCArIHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgWk9ORUlEJCksXG4gICAgICAgIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgSVBWRlVUVVJFJCA9IHN1YmV4cChcIlt2Vl1cIiArIEhFWERJRyQkICsgXCIrXFxcXC5cIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikgKyBcIitcIiksXG4gICAgICAgIElQX0xJVEVSQUwkID0gc3ViZXhwKFwiXFxcXFtcIiArIHN1YmV4cChJUFY2QUREUlpfUkVMQVhFRCQgKyBcInxcIiArIElQVjZBRERSRVNTJCArIFwifFwiICsgSVBWRlVUVVJFJCkgKyBcIlxcXFxdXCIpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgUkVHX05BTUUkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSkgKyBcIipcIiksXG4gICAgICAgIEhPU1QkID0gc3ViZXhwKElQX0xJVEVSQUwkICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQgKyBcIig/IVwiICsgUkVHX05BTUUkICsgXCIpXCIgKyBcInxcIiArIFJFR19OQU1FJCksXG4gICAgICAgIFBPUlQkID0gc3ViZXhwKERJR0lUJCQgKyBcIipcIiksXG4gICAgICAgIEFVVEhPUklUWSQgPSBzdWJleHAoc3ViZXhwKFVTRVJJTkZPJCArIFwiQFwiKSArIFwiP1wiICsgSE9TVCQgKyBzdWJleHAoXCJcXFxcOlwiICsgUE9SVCQpICsgXCI/XCIpLFxuICAgICAgICBQQ0hBUiQgPSBzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQF1cIikpLFxuICAgICAgICBTRUdNRU5UJCA9IHN1YmV4cChQQ0hBUiQgKyBcIipcIiksXG4gICAgICAgIFNFR01FTlRfTlokID0gc3ViZXhwKFBDSEFSJCArIFwiK1wiKSxcbiAgICAgICAgU0VHTUVOVF9OWl9OQyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFxAXVwiKSkgKyBcIitcIiksXG4gICAgICAgIFBBVEhfQUJFTVBUWSQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cIiArIFNFR01FTlQkKSArIFwiKlwiKSxcbiAgICAgICAgUEFUSF9BQlNPTFVURSQgPSBzdWJleHAoXCJcXFxcL1wiICsgc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCkgKyBcIj9cIiksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfTk9TQ0hFTUUkID0gc3ViZXhwKFNFR01FTlRfTlpfTkMkICsgUEFUSF9BQkVNUFRZJCksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfUk9PVExFU1MkID0gc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfRU1QVFkkID0gXCIoPyFcIiArIFBDSEFSJCArIFwiKVwiLFxuICAgICAgICBQQVRIJCA9IHN1YmV4cChQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFFVRVJZJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8XCIgKyBtZXJnZShcIltcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSkgKyBcIipcIiksXG4gICAgICAgIEZSQUdNRU5UJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8W1xcXFwvXFxcXD9dXCIpICsgXCIqXCIpLFxuICAgICAgICBISUVSX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFVSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFJFTEFUSVZFX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFJFTEFUSVZFJCA9IHN1YmV4cChSRUxBVElWRV9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcbiAgICAgICAgVVJJX1JFRkVSRU5DRSQgPSBzdWJleHAoVVJJJCArIFwifFwiICsgUkVMQVRJVkUkKSxcbiAgICAgICAgQUJTT0xVVEVfVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIpLFxuICAgICAgICBHRU5FUklDX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIFJFTEFUSVZFX1JFRiQgPSBcIl4oKXswfVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQUJTT0xVVEVfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBTQU1FRE9DX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBBVVRIT1JJVFlfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/JFwiO1xuICAgIHJldHVybiB7XG4gICAgICAgIE5PVF9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSwgXCJnXCIpLFxuICAgICAgICBOT1RfVVNFUklORk86IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfSE9TVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcW1xcXFxdXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUEFUSDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFw6XFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUEFUSF9OT1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1FVRVJZOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfRlJBR01FTlQ6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIpLCBcImdcIiksXG4gICAgICAgIEVTQ0FQRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgVU5SRVNFUlZFRDogbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKSxcbiAgICAgICAgT1RIRVJfQ0hBUlM6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFJFU0VSVkVEJCQpLCBcImdcIiksXG4gICAgICAgIFBDVF9FTkNPREVEOiBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpLFxuICAgICAgICBJUFY0QUREUkVTUzogbmV3IFJlZ0V4cChcIl4oXCIgKyBJUFY0QUREUkVTUyQgKyBcIikkXCIpLFxuICAgICAgICBJUFY2QUREUkVTUzogbmV3IFJlZ0V4cChcIl5cXFxcWz8oXCIgKyBJUFY2QUREUkVTUyQgKyBcIilcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFwiKFwiICsgWk9ORUlEJCArIFwiKVwiKSArIFwiP1xcXFxdPyRcIikgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICB9O1xufVxudmFyIFVSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyhmYWxzZSk7XG5cbnZhciBJUklfUFJPVE9DT0wgPSBidWlsZEV4cHModHJ1ZSk7XG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXG52YXIgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG52YXIgYmFzZSA9IDM2O1xudmFyIHRNaW4gPSAxO1xudmFyIHRNYXggPSAyNjtcbnZhciBza2V3ID0gMzg7XG52YXIgZGFtcCA9IDcwMDtcbnZhciBpbml0aWFsQmlhcyA9IDcyO1xudmFyIGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG52YXIgZGVsaW1pdGVyID0gJy0nOyAvLyAnXFx4MkQnXG5cbi8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG52YXIgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG52YXIgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbnZhciByZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nOyAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cbi8qKiBFcnJvciBtZXNzYWdlcyAqL1xudmFyIGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbnZhciBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvciQxKHR5cGUpIHtcblx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcbn1cblxuLyoqXG4gKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG4gKiBpdGVtLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdHZhciByZXN1bHQgPSBbXTtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdHZhciByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgY291bnRlciA9IDA7XG5cdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblx0XHRcdHZhciBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcblx0XHRcdFx0Ly8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xudmFyIHVjczJlbmNvZGUgPSBmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsIHRvQ29uc3VtYWJsZUFycmF5KGFycmF5KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbnZhciBiYXNpY1RvRGlnaXQgPSBmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdGlmIChjb2RlUG9pbnQgLSAweDMwIDwgMHgwQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDE2O1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgLSAweDQxIDwgMHgxQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDQxO1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgLSAweDYxIDwgMHgxQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDYxO1xuXHR9XG5cdHJldHVybiBiYXNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG4gKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcbiAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG4gKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuICovXG52YXIgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhZGFwdCA9IGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHR2YXIgayA9IDA7XG5cdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0Zm9yICg7IC8qIG5vIGluaXRpYWxpemF0aW9uICovZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdH1cblx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG4gKiBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKi9cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0dmFyIGkgPSAwO1xuXHR2YXIgbiA9IGluaXRpYWxOO1xuXHR2YXIgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHR2YXIgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yICh2YXIgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IkMSgnbm90LWJhc2ljJyk7XG5cdFx0fVxuXHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHR9XG5cblx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdGZvciAodmFyIGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDspIC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi97XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdHZhciBvbGRpID0gaTtcblx0XHRmb3IgKHZhciB3ID0gMSwgayA9IGJhc2U7OyAvKiBubyBjb25kaXRpb24gKi9rICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yJDEoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0dmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXHRcdH1cblxuXHRcdHZhciBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0aSAlPSBvdXQ7XG5cblx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0LlxuXHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblx0fVxuXG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsIG91dHB1dCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKi9cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0dmFyIG91dHB1dCA9IFtdO1xuXG5cdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIGFuIGFycmF5IG9mIFVuaWNvZGUgY29kZSBwb2ludHMuXG5cdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0Ly8gQ2FjaGUgdGhlIGxlbmd0aC5cblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlLlxuXHR2YXIgbiA9IGluaXRpYWxOO1xuXHR2YXIgZGVsdGEgPSAwO1xuXHR2YXIgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHMuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0dmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvciA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0dmFyIF9jdXJyZW50VmFsdWUyID0gX3N0ZXAudmFsdWU7XG5cblx0XHRcdGlmIChfY3VycmVudFZhbHVlMiA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKF9jdXJyZW50VmFsdWUyKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvci5yZXR1cm4oKTtcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cdHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG5cdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cblx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdHZhciBtID0gbWF4SW50O1xuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMiA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG5cdFx0XHRcdHZhciBjdXJyZW50VmFsdWUgPSBfc3RlcDIudmFsdWU7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcblx0XHRcdF9pdGVyYXRvckVycm9yMiA9IGVycjtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuXHRcdFx0XHRcdF9pdGVyYXRvcjIucmV0dXJuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcblx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0biA9IG07XG5cblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjMgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgX2N1cnJlbnRWYWx1ZSA9IF9zdGVwMy52YWx1ZTtcblxuXHRcdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRcdHZhciBxID0gZGVsdGE7XG5cdFx0XHRcdFx0Zm9yICh2YXIgayA9IGJhc2U7OyAvKiBubyBjb25kaXRpb24gKi9rICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0dmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSkpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcblx0XHRcdF9pdGVyYXRvckVycm9yMyA9IGVycjtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuXHRcdFx0XHRcdF9pdGVyYXRvcjMucmV0dXJuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcblx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblx0fVxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAqIHN0cmluZy5cbiAqL1xudmFyIHRvVW5pY29kZSA9IGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG52YXIgdG9BU0NJSSA9IGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG52YXIgcHVueWNvZGUgPSB7XG5cdC8qKlxuICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cbiAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgKiBAdHlwZSBTdHJpbmdcbiAgKi9cblx0J3ZlcnNpb24nOiAnMi4xLjAnLFxuXHQvKipcbiAgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuICAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG4gICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgT2JqZWN0XG4gICovXG5cdCd1Y3MyJzoge1xuXHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdH0sXG5cdCdkZWNvZGUnOiBkZWNvZGUsXG5cdCdlbmNvZGUnOiBlbmNvZGUsXG5cdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxufTtcblxuLyoqXG4gKiBVUkkuanNcbiAqXG4gKiBAZmlsZW92ZXJ2aWV3IEFuIFJGQyAzOTg2IGNvbXBsaWFudCwgc2NoZW1lIGV4dGVuZGFibGUgVVJJIHBhcnNpbmcvdmFsaWRhdGluZy9yZXNvbHZpbmcgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC5cbiAqIEBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpnYXJ5LmNvdXJ0QGdtYWlsLmNvbVwiPkdhcnkgQ291cnQ8L2E+XG4gKiBAc2VlIGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanNcbiAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMSBHYXJ5IENvdXJ0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxuICogcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcbiAqICAgICAgIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICogICAgICAgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAqICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEdBUlkgQ09VUlQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEXG4gKiBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR0FSWSBDT1VSVCBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRlxuICogQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uIGFyZSB0aG9zZSBvZiB0aGVcbiAqIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkXG4gKiBvciBpbXBsaWVkLCBvZiBHYXJ5IENvdXJ0LlxuICovXG52YXIgU0NIRU1FUyA9IHt9O1xuZnVuY3Rpb24gcGN0RW5jQ2hhcihjaHIpIHtcbiAgICB2YXIgYyA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBlID0gdm9pZCAwO1xuICAgIGlmIChjIDwgMTYpIGUgPSBcIiUwXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAxMjgpIGUgPSBcIiVcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoYyA8IDIwNDgpIGUgPSBcIiVcIiArIChjID4+IDYgfCAxOTIpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGUgPSBcIiVcIiArIChjID4+IDEyIHwgMjI0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgPj4gNiAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBwY3REZWNDaGFycyhzdHIpIHtcbiAgICB2YXIgbmV3U3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGlsID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGlsKSB7XG4gICAgICAgIHZhciBjID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgMSwgMiksIDE2KTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMTk0ICYmIGMgPCAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gNikge1xuICAgICAgICAgICAgICAgIHZhciBjMiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAzMSkgPDwgNiB8IGMyICYgNjMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDIyNCkge1xuICAgICAgICAgICAgaWYgKGlsIC0gaSA+PSA5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgYzMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA3LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKF9jICYgNjMpIDw8IDYgfCBjMyAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCAzKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3U3RyO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKSB7XG4gICAgZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICAgICAgdmFyIGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG4gICAgICAgIHJldHVybiAhZGVjU3RyLm1hdGNoKHByb3RvY29sLlVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUpIGNvbXBvbmVudHMuc2NoZW1lID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1NDSEVNRSwgXCJcIik7XG4gICAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy51c2VyaW5mbyA9IFN0cmluZyhjb21wb25lbnRzLnVzZXJpbmZvKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9VU0VSSU5GTywgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5ob3N0ID0gU3RyaW5nKGNvbXBvbmVudHMuaG9zdCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9IT1NULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnBhdGggPSBTdHJpbmcoY29tcG9uZW50cy5wYXRoKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKGNvbXBvbmVudHMuc2NoZW1lID8gcHJvdG9jb2wuTk9UX1BBVEggOiBwcm90b2NvbC5OT1RfUEFUSF9OT1NDSEVNRSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucXVlcnkgPSBTdHJpbmcoY29tcG9uZW50cy5xdWVyeSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfUVVFUlksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmZyYWdtZW50ID0gU3RyaW5nKGNvbXBvbmVudHMuZnJhZ21lbnQpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0ZSQUdNRU5ULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbmZ1bmN0aW9uIF9zdHJpcExlYWRpbmdaZXJvcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14wKiguKikvLCBcIiQxXCIpIHx8IFwiMFwiO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjQoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNEFERFJFU1MpIHx8IFtdO1xuXG4gICAgdmFyIF9tYXRjaGVzID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAyKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzWzFdO1xuXG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3Muc3BsaXQoXCIuXCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpLmpvaW4oXCIuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY2KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjZBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlczIgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDMpLFxuICAgICAgICBhZGRyZXNzID0gX21hdGNoZXMyWzFdLFxuICAgICAgICB6b25lID0gX21hdGNoZXMyWzJdO1xuXG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIF9hZGRyZXNzJHRvTG93ZXJDYXNlJCA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5zcGxpdCgnOjonKS5yZXZlcnNlKCksXG4gICAgICAgICAgICBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyID0gc2xpY2VkVG9BcnJheShfYWRkcmVzcyR0b0xvd2VyQ2FzZSQsIDIpLFxuICAgICAgICAgICAgbGFzdCA9IF9hZGRyZXNzJHRvTG93ZXJDYXNlJDJbMF0sXG4gICAgICAgICAgICBmaXJzdCA9IF9hZGRyZXNzJHRvTG93ZXJDYXNlJDJbMV07XG5cbiAgICAgICAgdmFyIGZpcnN0RmllbGRzID0gZmlyc3QgPyBmaXJzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykgOiBbXTtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHMgPSBsYXN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKTtcbiAgICAgICAgdmFyIGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPSBwcm90b2NvbC5JUFY0QUREUkVTUy50ZXN0KGxhc3RGaWVsZHNbbGFzdEZpZWxkcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHZhciBmaWVsZENvdW50ID0gaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA/IDcgOiA4O1xuICAgICAgICB2YXIgbGFzdEZpZWxkc1N0YXJ0ID0gbGFzdEZpZWxkcy5sZW5ndGggLSBmaWVsZENvdW50O1xuICAgICAgICB2YXIgZmllbGRzID0gQXJyYXkoZmllbGRDb3VudCk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZmllbGRDb3VudDsgKyt4KSB7XG4gICAgICAgICAgICBmaWVsZHNbeF0gPSBmaXJzdEZpZWxkc1t4XSB8fCBsYXN0RmllbGRzW2xhc3RGaWVsZHNTdGFydCArIHhdIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhc3RGaWVsZElQdjRBZGRyZXNzKSB7XG4gICAgICAgICAgICBmaWVsZHNbZmllbGRDb3VudCAtIDFdID0gX25vcm1hbGl6ZUlQdjQoZmllbGRzW2ZpZWxkQ291bnQgLSAxXSwgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxaZXJvRmllbGRzID0gZmllbGRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmaWVsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghZmllbGQgfHwgZmllbGQgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMb25nZXN0ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExvbmdlc3QgJiYgbGFzdExvbmdlc3QuaW5kZXggKyBsYXN0TG9uZ2VzdC5sZW5ndGggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMb25nZXN0Lmxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYy5wdXNoKHsgaW5kZXg6IGluZGV4LCBsZW5ndGg6IDEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICB2YXIgbG9uZ2VzdFplcm9GaWVsZHMgPSBhbGxaZXJvRmllbGRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgdmFyIG5ld0hvc3QgPSB2b2lkIDA7XG4gICAgICAgIGlmIChsb25nZXN0WmVyb0ZpZWxkcyAmJiBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgbmV3Rmlyc3QgPSBmaWVsZHMuc2xpY2UoMCwgbG9uZ2VzdFplcm9GaWVsZHMuaW5kZXgpO1xuICAgICAgICAgICAgdmFyIG5ld0xhc3QgPSBmaWVsZHMuc2xpY2UobG9uZ2VzdFplcm9GaWVsZHMuaW5kZXggKyBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3SG9zdCA9IG5ld0ZpcnN0LmpvaW4oXCI6XCIpICsgXCI6OlwiICsgbmV3TGFzdC5qb2luKFwiOlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBmaWVsZHMuam9pbihcIjpcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvbmUpIHtcbiAgICAgICAgICAgIG5ld0hvc3QgKz0gXCIlXCIgKyB6b25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIb3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbn1cbnZhciBVUklfUEFSU0UgPSAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooW15cXC8/I0BdKilAKT8oXFxbW15cXC8/I1xcXV0rXFxdfFteXFwvPyM6XSopKD86XFw6KFxcZCopKT8pKT8oW14/I10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxcXG58XFxyKSopKT8vaTtcbnZhciBOT19NQVRDSF9JU19VTkRFRklORUQgPSBcIlwiLm1hdGNoKC8oKXswfS8pWzFdID09PSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBwYXJzZSh1cmlTdHJpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IHt9O1xuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09IFwic3VmZml4XCIpIHVyaVN0cmluZyA9IChvcHRpb25zLnNjaGVtZSA/IG9wdGlvbnMuc2NoZW1lICsgXCI6XCIgOiBcIlwiKSArIFwiLy9cIiArIHVyaVN0cmluZztcbiAgICB2YXIgbWF0Y2hlcyA9IHVyaVN0cmluZy5tYXRjaChVUklfUEFSU0UpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGlmIChOT19NQVRDSF9JU19VTkRFRklORUQpIHtcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBtYXRjaGVzWzddO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IG1hdGNoZXNbOF07XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBtYXRjaGVzWzVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9JRSBGSVggZm9yIGltcHJvcGVyIFJlZ0V4cCBtYXRjaGluZ1xuICAgICAgICAgICAgLy9zdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSB1cmlTdHJpbmcuaW5kZXhPZihcIkBcIikgIT09IC0xID8gbWF0Y2hlc1szXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IHVyaVN0cmluZy5pbmRleE9mKFwiLy9cIikgIT09IC0xID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSB1cmlTdHJpbmcuaW5kZXhPZihcIj9cIikgIT09IC0xID8gbWF0Y2hlc1s3XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSB1cmlTdHJpbmcuaW5kZXhPZihcIiNcIikgIT09IC0xID8gbWF0Y2hlc1s4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVyaVN0cmluZy5tYXRjaCgvXFwvXFwvKD86LnxcXG4pKlxcOig/OlxcL3xcXD98XFwjfCQpLykgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzXG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChjb21wb25lbnRzLmhvc3QsIHByb3RvY29sKSwgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vZGV0ZXJtaW5lIHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnBvcnQgPT09IHVuZGVmaW5lZCAmJiAhY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInNhbWUtZG9jdW1lbnRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRzLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInVyaVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBjb21wb25lbnRzLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgaXMgbm90IGEgXCIgKyBvcHRpb25zLnJlZmVyZW5jZSArIFwiIHJlZmVyZW5jZS5cIjtcbiAgICAgICAgfVxuICAgICAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgLy9jaGVjayBpZiBzY2hlbWUgY2FuJ3QgaGFuZGxlIElSSXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnZlcnQgSVJJIC0+IFVSSVxuICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIFVSSV9QUk9UT0NPTCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ3NcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcbiAgICAgICAgICAgIHNjaGVtZUhhbmRsZXIucGFyc2UoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbmZ1bmN0aW9uIF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICB2YXIgdXJpVG9rZW5zID0gW107XG4gICAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCJAXCIpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy9ub3JtYWxpemUgSVAgaG9zdHMsIGFkZCBicmFja2V0cyBhbmQgZXNjYXBlIHpvbmUgc2VwYXJhdG9yIGZvciBJUHY2XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KFN0cmluZyhjb21wb25lbnRzLmhvc3QpLCBwcm90b2NvbCksIHByb3RvY29sKS5yZXBsYWNlKHByb3RvY29sLklQVjZBRERSRVNTLCBmdW5jdGlvbiAoXywgJDEsICQyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbXCIgKyAkMSArICgkMiA/IFwiJTI1XCIgKyAkMiA6IFwiXCIpICsgXCJdXCI7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIjpcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnRzLnBvcnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbihcIlwiKSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIFJEUzEgPSAvXlxcLlxcLj9cXC8vO1xudmFyIFJEUzIgPSAvXlxcL1xcLihcXC98JCkvO1xudmFyIFJEUzMgPSAvXlxcL1xcLlxcLihcXC98JCkvO1xudmFyIFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS87XG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyhpbnB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzEsIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgXCIvXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzMpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMywgXCIvXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnBvcCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcIi5cIiB8fCBpbnB1dCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW0gPSBpbnB1dC5tYXRjaChSRFM1KTtcbiAgICAgICAgICAgIGlmIChpbSkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gaW1bMF07XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZG90IHNlZ21lbnQgY29uZGl0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICB2YXIgdXJpVG9rZW5zID0gW107XG4gICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGFuIElQdjYgYWRkcmVzc1xuICAgICAgICBpZiAocHJvdG9jb2wuSVBWNkFERFJFU1MudGVzdChjb21wb25lbnRzLmhvc3QpKSB7fVxuICAgICAgICAvL1RPRE86IG5vcm1hbGl6ZSBJUHY2IGFkZHJlc3MgYXMgcGVyIFJGQyA1OTUyXG5cbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGNvbXBvbmVudHMuaG9zdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8vbm9ybWFsaXplIGVuY29kaW5nXG4gICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgY29tcG9uZW50cy5zY2hlbWUpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIjpcIik7XG4gICAgfVxuICAgIHZhciBhdXRob3JpdHkgPSBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiLy9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIvXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcyA9IGNvbXBvbmVudHMucGF0aDtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXlxcL1xcLy8sIFwiLyUyRlwiKTsgLy9kb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKHMpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiP1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5xdWVyeSk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIjXCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLmZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaVRva2Vucy5qb2luKFwiXCIpOyAvL21lcmdlIHRva2VucyBpbnRvIGEgc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzKGJhc2UsIHJlbGF0aXZlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBza2lwTm9ybWFsaXphdGlvbiA9IGFyZ3VtZW50c1szXTtcblxuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAvL25vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcbiAgICAgICAgcmVsYXRpdmUgPSBwYXJzZShzZXJpYWxpemUocmVsYXRpdmUsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50c1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWU7XG4gICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG4gICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG4gICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aDtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYmFzZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IGJhc2UucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IFwiL1wiICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgIH1cbiAgICB0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudDtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGJhc2VVUkksIHJlbGF0aXZlVVJJLCBvcHRpb25zKSB7XG4gICAgdmFyIHNjaGVtZWxlc3NPcHRpb25zID0gYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKSwgc2NoZW1lbGVzc09wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUodXJpLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpID0gc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpID0gcGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpO1xufVxuXG5mdW5jdGlvbiBlcXVhbCh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB1cmlBID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUEgPSBzZXJpYWxpemUocGFyc2UodXJpQSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUEpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUEgPSBzZXJpYWxpemUodXJpQSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdXJpQiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlCID0gc2VyaWFsaXplKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlCKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlCID0gc2VyaWFsaXplKHVyaUIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpQSA9PT0gdXJpQjtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQ29tcG9uZW50KHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuRVNDQVBFIDogSVJJX1BST1RPQ09MLkVTQ0FQRSwgcGN0RW5jQ2hhcik7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQ29tcG9uZW50KHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuUENUX0VOQ09ERUQgOiBJUklfUFJPVE9DT0wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKTtcbn1cblxudmFyIGhhbmRsZXIgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vcmVwb3J0IG1pc3NpbmcgaG9zdFxuICAgICAgICBpZiAoIWNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJodHRwc1wiO1xuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBvcnQgPT09IChzZWN1cmUgPyA0NDMgOiA4MCkgfHwgY29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLnBhdGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIC8vTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuICAgICAgICAvL2FzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuICAgICAgICAvL2FuZCBub3QgdGhlIEhUVFAgc3BlYy5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIGhhbmRsZXIkMSA9IHtcbiAgICBzY2hlbWU6IFwiaHR0cHNcIixcbiAgICBkb21haW5Ib3N0OiBoYW5kbGVyLmRvbWFpbkhvc3QsXG4gICAgcGFyc2U6IGhhbmRsZXIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyLnNlcmlhbGl6ZVxufTtcblxuZnVuY3Rpb24gaXNTZWN1cmUod3NDb21wb25lbnRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicgPyB3c0NvbXBvbmVudHMuc2VjdXJlIDogU3RyaW5nKHdzQ29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwid3NzXCI7XG59XG4vL1JGQyA2NDU1XG52YXIgaGFuZGxlciQyID0ge1xuICAgIHNjaGVtZTogXCJ3c1wiLFxuICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHdzQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIC8vaW5kaWNhdGUgaWYgdGhlIHNlY3VyZSBmbGFnIGlzIHNldFxuICAgICAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gaXNTZWN1cmUod3NDb21wb25lbnRzKTtcbiAgICAgICAgLy9jb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJyk7XG4gICAgICAgIHdzQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICB3c0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB3c0NvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh3c0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2Vuc3VyZSBzY2hlbWUgbWF0Y2hlcyBzZWN1cmUgZmxhZ1xuICAgICAgICBpZiAodHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNjaGVtZSA9IHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfd3NDb21wb25lbnRzJHJlc291cmMgPSB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lLnNwbGl0KCc/JyksXG4gICAgICAgICAgICAgICAgX3dzQ29tcG9uZW50cyRyZXNvdXJjMiA9IHNsaWNlZFRvQXJyYXkoX3dzQ29tcG9uZW50cyRyZXNvdXJjLCAyKSxcbiAgICAgICAgICAgICAgICBwYXRoID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlswXSxcbiAgICAgICAgICAgICAgICBxdWVyeSA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMV07XG5cbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5wYXRoID0gcGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICAgICAgICB3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB3c0NvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIGhhbmRsZXIkMyA9IHtcbiAgICBzY2hlbWU6IFwid3NzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlciQyLmRvbWFpbkhvc3QsXG4gICAgcGFyc2U6IGhhbmRsZXIkMi5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGhhbmRsZXIkMi5zZXJpYWxpemVcbn07XG5cbnZhciBPID0ge307XG52YXIgaXNJUkkgPSB0cnVlO1xuLy9SRkMgMzk4NlxudmFyIFVOUkVTRVJWRUQkJCA9IFwiW0EtWmEtejAtOVxcXFwtXFxcXC5cXFxcX1xcXFx+XCIgKyAoaXNJUkkgPyBcIlxcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRlwiIDogXCJcIikgKyBcIl1cIjtcbnZhciBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIjsgLy9jYXNlLWluc2Vuc2l0aXZlXG52YXIgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpOyAvL2V4cGFuZGVkXG4vL1JGQyA1MzIyLCBleGNlcHQgdGhlc2Ugc3ltYm9scyBhcyBwZXIgUkZDIDYwNjg6IEAgOiAvID8gIyBbIF0gJiA7ID1cbi8vY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIjsgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcbi8vY29uc3QgUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKTsgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxuLy9jb25zdCBWQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKTsgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxuLy9jb25zdCBGV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIik7XG4vL2NvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpO1xuLy9jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyk7XG52YXIgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG52YXIgUVRFWFQkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwtXFxcXC4wLTlcXFxcPFxcXFw+QS1aXFxcXHg1RS1cXFxceDdFXVwiO1xudmFyIFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbnZhciBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIjtcbnZhciBVTlJFU0VSVkVEID0gbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKTtcbnZhciBQQ1RfRU5DT0RFRCA9IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIik7XG52YXIgTk9UX0xPQ0FMX1BBUlQgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCAnW1xcXFxcIl0nLCBWQ0hBUiQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRk5BTUUgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU09NRV9ERUxJTVMkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZWQUxVRSA9IE5PVF9IRk5BTUU7XG5mdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgIHJldHVybiAhZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyO1xufVxudmFyIGhhbmRsZXIkNCA9IHtcbiAgICBzY2hlbWU6IFwibWFpbHRvXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1haWx0b0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSBtYWlsdG9Db21wb25lbnRzLnRvID0gbWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdO1xuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgdW5rbm93bkhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgICAgICAgICB2YXIgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gaGZpZWxkcy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhmaWVsZCA9IGhmaWVsZHNbeF0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaGZpZWxkWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX3ggPSAwLCBfeGwgPSB0b0FkZHJzLmxlbmd0aDsgX3ggPCBfeGw7ICsrX3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0by5wdXNoKHRvQWRkcnNbX3hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ViamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5ib2R5ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5rbm93bkhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1t1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMF0sIG9wdGlvbnMpXSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5rbm93bkhlYWRlcnMpIG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgX3gyID0gMCwgX3hsMiA9IHRvLmxlbmd0aDsgX3gyIDwgX3hsMjsgKytfeDIpIHtcbiAgICAgICAgICAgIHZhciBhZGRyID0gdG9bX3gyXS5zcGxpdChcIkBcIik7XG4gICAgICAgICAgICBhZGRyWzBdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclswXSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmVycm9yID0gbWFpbHRvQ29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJbMV0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9bX3gyXSA9IGFkZHIuam9pbihcIkBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1haWx0b0NvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMShtYWlsdG9Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gbWFpbHRvQ29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gdG9BcnJheShtYWlsdG9Db21wb25lbnRzLnRvKTtcbiAgICAgICAgaWYgKHRvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvQWRkciA9IFN0cmluZyh0b1t4XSk7XG4gICAgICAgICAgICAgICAgdmFyIGF0SWR4ID0gdG9BZGRyLmxhc3RJbmRleE9mKFwiQFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQYXJ0ID0gdG9BZGRyLnNsaWNlKDAsIGF0SWR4KS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfTE9DQUxfUEFSVCwgcGN0RW5jQ2hhcik7XG4gICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRvQWRkci5zbGljZShhdElkeCArIDEpO1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChkb21haW4sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGRvbWFpbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9beF0gPSBsb2NhbFBhcnQgKyBcIkBcIiArIGRvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IHRvLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0KSBoZWFkZXJzW1wic3ViamVjdFwiXSA9IG1haWx0b0NvbXBvbmVudHMuc3ViamVjdDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuYm9keSkgaGVhZGVyc1tcImJvZHlcIl0gPSBtYWlsdG9Db21wb25lbnRzLmJvZHk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyc1tuYW1lXSAhPT0gT1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKG5hbWUucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGTkFNRSwgcGN0RW5jQ2hhcikgKyBcIj1cIiArIGhlYWRlcnNbbmFtZV0ucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGVkFMVUUsIHBjdEVuY0NoYXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IGZpZWxkcy5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVJOX1BBUlNFID0gL14oW15cXDpdKylcXDooLiopLztcbi8vUkZDIDIxNDFcbnZhciBoYW5kbGVyJDUgPSB7XG4gICAgc2NoZW1lOiBcInVyblwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5tYXRjaChVUk5fUEFSU0UpO1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcbiAgICAgICAgICAgIHZhciBuaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbnNzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gbnNzO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8IFwiVVJOIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cm5Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcbiAgICAgICAgdmFyIG5pZCA9IHVybkNvbXBvbmVudHMubmlkO1xuICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG4gICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVyaUNvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB2YXIgbnNzID0gdXJuQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHVyaUNvbXBvbmVudHMucGF0aCA9IChuaWQgfHwgb3B0aW9ucy5uaWQpICsgXCI6XCIgKyBuc3M7XG4gICAgICAgIHJldHVybiB1cmlDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVVUlEID0gL15bMC05QS1GYS1mXXs4fSg/OlxcLVswLTlBLUZhLWZdezR9KXszfVxcLVswLTlBLUZhLWZdezEyfSQvO1xuLy9SRkMgNDEyMlxudmFyIGhhbmRsZXIkNiA9IHtcbiAgICBzY2hlbWU6IFwidXJuOnV1aWRcIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB1dWlkQ29tcG9uZW50cy51dWlkID0gdXVpZENvbXBvbmVudHMubnNzO1xuICAgICAgICB1dWlkQ29tcG9uZW50cy5uc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnRzLnV1aWQgfHwgIXV1aWRDb21wb25lbnRzLnV1aWQubWF0Y2goVVVJRCkpKSB7XG4gICAgICAgICAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8IFwiVVVJRCBpcyBub3QgdmFsaWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV1aWRDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUodXVpZENvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50cztcbiAgICAgICAgLy9ub3JtYWxpemUgVVVJRFxuICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9ICh1dWlkQ29tcG9uZW50cy51dWlkIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB1cm5Db21wb25lbnRzO1xuICAgIH1cbn07XG5cblNDSEVNRVNbaGFuZGxlci5zY2hlbWVdID0gaGFuZGxlcjtcblNDSEVNRVNbaGFuZGxlciQxLnNjaGVtZV0gPSBoYW5kbGVyJDE7XG5TQ0hFTUVTW2hhbmRsZXIkMi5zY2hlbWVdID0gaGFuZGxlciQyO1xuU0NIRU1FU1toYW5kbGVyJDMuc2NoZW1lXSA9IGhhbmRsZXIkMztcblNDSEVNRVNbaGFuZGxlciQ0LnNjaGVtZV0gPSBoYW5kbGVyJDQ7XG5TQ0hFTUVTW2hhbmRsZXIkNS5zY2hlbWVdID0gaGFuZGxlciQ1O1xuU0NIRU1FU1toYW5kbGVyJDYuc2NoZW1lXSA9IGhhbmRsZXIkNjtcblxuZXhwb3J0cy5TQ0hFTUVTID0gU0NIRU1FUztcbmV4cG9ydHMucGN0RW5jQ2hhciA9IHBjdEVuY0NoYXI7XG5leHBvcnRzLnBjdERlY0NoYXJzID0gcGN0RGVjQ2hhcnM7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnJlbW92ZURvdFNlZ21lbnRzID0gcmVtb3ZlRG90U2VnbWVudHM7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmV4cG9ydHMucmVzb2x2ZUNvbXBvbmVudHMgPSByZXNvbHZlQ29tcG9uZW50cztcbmV4cG9ydHMucmVzb2x2ZSA9IHJlc29sdmU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZXF1YWwgPSBlcXVhbDtcbmV4cG9ydHMuZXNjYXBlQ29tcG9uZW50ID0gZXNjYXBlQ29tcG9uZW50O1xuZXhwb3J0cy51bmVzY2FwZUNvbXBvbmVudCA9IHVuZXNjYXBlQ29tcG9uZW50O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLmFsbC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIlVSSSIsIm1lcmdlIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNldHMiLCJBcnJheSIsIl9rZXkiLCJzbGljZSIsInhsIiwieCIsImpvaW4iLCJzdWJleHAiLCJzdHIiLCJ0eXBlT2YiLCJvIiwidW5kZWZpbmVkIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic3BsaXQiLCJwb3AiLCJzaGlmdCIsInRvTG93ZXJDYXNlIiwidG9VcHBlckNhc2UiLCJ0b0FycmF5Iiwib2JqIiwic2V0SW50ZXJ2YWwiLCJhc3NpZ24iLCJ0YXJnZXQiLCJzb3VyY2UiLCJrZXkiLCJidWlsZEV4cHMiLCJpc0lSSSIsIkFMUEhBJCQiLCJDUiQiLCJESUdJVCQkIiwiRFFVT1RFJCQiLCJIRVhESUckJCIsIkxGJCQiLCJTUCQkIiwiUENUX0VOQ09ERUQkIiwiR0VOX0RFTElNUyQkIiwiU1VCX0RFTElNUyQkIiwiUkVTRVJWRUQkJCIsIlVDU0NIQVIkJCIsIklQUklWQVRFJCQiLCJVTlJFU0VSVkVEJCQiLCJTQ0hFTUUkIiwiVVNFUklORk8kIiwiREVDX09DVEVUJCIsIkRFQ19PQ1RFVF9SRUxBWEVEJCIsIklQVjRBRERSRVNTJCIsIkgxNiQiLCJMUzMyJCIsIklQVjZBRERSRVNTMSQiLCJJUFY2QUREUkVTUzIkIiwiSVBWNkFERFJFU1MzJCIsIklQVjZBRERSRVNTNCQiLCJJUFY2QUREUkVTUzUkIiwiSVBWNkFERFJFU1M2JCIsIklQVjZBRERSRVNTNyQiLCJJUFY2QUREUkVTUzgkIiwiSVBWNkFERFJFU1M5JCIsIklQVjZBRERSRVNTJCIsIlpPTkVJRCQiLCJJUFY2QUREUlokIiwiSVBWNkFERFJaX1JFTEFYRUQkIiwiSVBWRlVUVVJFJCIsIklQX0xJVEVSQUwkIiwiUkVHX05BTUUkIiwiSE9TVCQiLCJQT1JUJCIsIkFVVEhPUklUWSQiLCJQQ0hBUiQiLCJTRUdNRU5UJCIsIlNFR01FTlRfTlokIiwiU0VHTUVOVF9OWl9OQyQiLCJQQVRIX0FCRU1QVFkkIiwiUEFUSF9BQlNPTFVURSQiLCJQQVRIX05PU0NIRU1FJCIsIlBBVEhfUk9PVExFU1MkIiwiUEFUSF9FTVBUWSQiLCJQQVRIJCIsIlFVRVJZJCIsIkZSQUdNRU5UJCIsIkhJRVJfUEFSVCQiLCJVUkkkIiwiUkVMQVRJVkVfUEFSVCQiLCJSRUxBVElWRSQiLCJVUklfUkVGRVJFTkNFJCIsIkFCU09MVVRFX1VSSSQiLCJHRU5FUklDX1JFRiQiLCJSRUxBVElWRV9SRUYkIiwiQUJTT0xVVEVfUkVGJCIsIlNBTUVET0NfUkVGJCIsIkFVVEhPUklUWV9SRUYkIiwiTk9UX1NDSEVNRSIsIlJlZ0V4cCIsIk5PVF9VU0VSSU5GTyIsIk5PVF9IT1NUIiwiTk9UX1BBVEgiLCJOT1RfUEFUSF9OT1NDSEVNRSIsIk5PVF9RVUVSWSIsIk5PVF9GUkFHTUVOVCIsIkVTQ0FQRSIsIlVOUkVTRVJWRUQiLCJPVEhFUl9DSEFSUyIsIlBDVF9FTkNPREVEIiwiSVBWNEFERFJFU1MiLCJJUFY2QUREUkVTUyIsIlVSSV9QUk9UT0NPTCIsIklSSV9QUk9UT0NPTCIsInNsaWNlZFRvQXJyYXkiLCJzbGljZUl0ZXJhdG9yIiwiYXJyIiwiaSIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJUeXBlRXJyb3IiLCJ0b0NvbnN1bWFibGVBcnJheSIsImFycjIiLCJmcm9tIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJlcnJvcnMiLCJiYXNlTWludXNUTWluIiwiZmxvb3IiLCJNYXRoIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXJyb3IkMSIsInR5cGUiLCJSYW5nZUVycm9yIiwibWFwIiwiYXJyYXkiLCJmbiIsInJlc3VsdCIsIm1hcERvbWFpbiIsInN0cmluZyIsInBhcnRzIiwicmVwbGFjZSIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsImNoYXJDb2RlQXQiLCJleHRyYSIsInVjczJlbmNvZGUiLCJmcm9tQ29kZVBvaW50IiwiYXBwbHkiLCJiYXNpY1RvRGlnaXQiLCJjb2RlUG9pbnQiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImZsYWciLCJhZGFwdCIsImRlbHRhIiwibnVtUG9pbnRzIiwiZmlyc3RUaW1lIiwiayIsImRlY29kZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJuIiwiYmlhcyIsImJhc2ljIiwibGFzdEluZGV4T2YiLCJqIiwiaW5kZXgiLCJvbGRpIiwidyIsInQiLCJiYXNlTWludXNUIiwib3V0Iiwic3BsaWNlIiwiZW5jb2RlIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJfc3RlcCIsIl9jdXJyZW50VmFsdWUyIiwicmV0dXJuIiwiYmFzaWNMZW5ndGgiLCJoYW5kbGVkQ1BDb3VudCIsIm0iLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiIsIl9kaWRJdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyIsIl9kaWRJdGVyYXRvckVycm9yMyIsIl9pdGVyYXRvckVycm9yMyIsIl9pdGVyYXRvcjMiLCJfc3RlcDMiLCJfY3VycmVudFZhbHVlIiwicSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0ZXN0IiwidG9BU0NJSSIsInB1bnljb2RlIiwiU0NIRU1FUyIsInBjdEVuY0NoYXIiLCJjaHIiLCJjIiwiZSIsInBjdERlY0NoYXJzIiwibmV3U3RyIiwiaWwiLCJwYXJzZUludCIsInN1YnN0ciIsImMyIiwiX2MiLCJjMyIsIl9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyIsImNvbXBvbmVudHMiLCJwcm90b2NvbCIsImRlY29kZVVucmVzZXJ2ZWQiLCJkZWNTdHIiLCJtYXRjaCIsInNjaGVtZSIsInVzZXJpbmZvIiwiaG9zdCIsInBhdGgiLCJxdWVyeSIsImZyYWdtZW50IiwiX3N0cmlwTGVhZGluZ1plcm9zIiwiX25vcm1hbGl6ZUlQdjQiLCJtYXRjaGVzIiwiX21hdGNoZXMiLCJhZGRyZXNzIiwiX25vcm1hbGl6ZUlQdjYiLCJfbWF0Y2hlczIiLCJ6b25lIiwiX2FkZHJlc3MkdG9Mb3dlckNhc2UkIiwicmV2ZXJzZSIsIl9hZGRyZXNzJHRvTG93ZXJDYXNlJDIiLCJsYXN0IiwiZmlyc3QiLCJmaXJzdEZpZWxkcyIsImxhc3RGaWVsZHMiLCJpc0xhc3RGaWVsZElQdjRBZGRyZXNzIiwiZmllbGRDb3VudCIsImxhc3RGaWVsZHNTdGFydCIsImZpZWxkcyIsImFsbFplcm9GaWVsZHMiLCJyZWR1Y2UiLCJhY2MiLCJmaWVsZCIsImxhc3RMb25nZXN0IiwibG9uZ2VzdFplcm9GaWVsZHMiLCJzb3J0IiwiYSIsImIiLCJuZXdIb3N0IiwibmV3Rmlyc3QiLCJuZXdMYXN0IiwiVVJJX1BBUlNFIiwiTk9fTUFUQ0hfSVNfVU5ERUZJTkVEIiwicGFyc2UiLCJ1cmlTdHJpbmciLCJvcHRpb25zIiwiaXJpIiwicmVmZXJlbmNlIiwicG9ydCIsImlzTmFOIiwiaW5kZXhPZiIsImVycm9yIiwic2NoZW1lSGFuZGxlciIsInVuaWNvZGVTdXBwb3J0IiwiZG9tYWluSG9zdCIsIl9yZWNvbXBvc2VBdXRob3JpdHkiLCJ1cmlUb2tlbnMiLCJfIiwiJDEiLCIkMiIsIlJEUzEiLCJSRFMyIiwiUkRTMyIsIlJEUzUiLCJyZW1vdmVEb3RTZWdtZW50cyIsImltIiwicyIsIkVycm9yIiwic2VyaWFsaXplIiwiYXV0aG9yaXR5IiwiY2hhckF0IiwiYWJzb2x1dGVQYXRoIiwicmVzb2x2ZUNvbXBvbmVudHMiLCJyZWxhdGl2ZSIsInNraXBOb3JtYWxpemF0aW9uIiwidG9sZXJhbnQiLCJyZXNvbHZlIiwiYmFzZVVSSSIsInJlbGF0aXZlVVJJIiwic2NoZW1lbGVzc09wdGlvbnMiLCJub3JtYWxpemUiLCJ1cmkiLCJlcXVhbCIsInVyaUEiLCJ1cmlCIiwiZXNjYXBlQ29tcG9uZW50IiwidW5lc2NhcGVDb21wb25lbnQiLCJoYW5kbGVyIiwic2VjdXJlIiwiaGFuZGxlciQxIiwiaXNTZWN1cmUiLCJ3c0NvbXBvbmVudHMiLCJoYW5kbGVyJDIiLCJyZXNvdXJjZU5hbWUiLCJfd3NDb21wb25lbnRzJHJlc291cmMiLCJfd3NDb21wb25lbnRzJHJlc291cmMyIiwiaGFuZGxlciQzIiwiTyIsIkFURVhUJCQiLCJRVEVYVCQkIiwiVkNIQVIkJCIsIlNPTUVfREVMSU1TJCQiLCJOT1RfTE9DQUxfUEFSVCIsIk5PVF9IRk5BTUUiLCJOT1RfSEZWQUxVRSIsImhhbmRsZXIkNCIsInBhcnNlJCQxIiwibWFpbHRvQ29tcG9uZW50cyIsInRvIiwidW5rbm93bkhlYWRlcnMiLCJoZWFkZXJzIiwiaGZpZWxkcyIsImhmaWVsZCIsInRvQWRkcnMiLCJfeCIsIl94bCIsInN1YmplY3QiLCJib2R5IiwiX3gyIiwiX3hsMiIsImFkZHIiLCJzZXJpYWxpemUkJDEiLCJ0b0FkZHIiLCJhdElkeCIsImxvY2FsUGFydCIsImRvbWFpbiIsIm5hbWUiLCJVUk5fUEFSU0UiLCJoYW5kbGVyJDUiLCJ1cm5Db21wb25lbnRzIiwibmlkIiwibnNzIiwidXJuU2NoZW1lIiwidXJpQ29tcG9uZW50cyIsIlVVSUQiLCJoYW5kbGVyJDYiLCJ1dWlkQ29tcG9uZW50cyIsInV1aWQiLCJkZWZpbmVQcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uri-js/dist/es5/uri.all.js\n");

/***/ })

};
;