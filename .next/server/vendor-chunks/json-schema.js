"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-schema";
exports.ids = ["vendor-chunks/json-schema"];
exports.modules = {

/***/ "(ssr)/./node_modules/json-schema/lib/validate.js":
/*!**************************************************!*\
  !*** ./node_modules/json-schema/lib/validate.js ***!
  \**************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/**\r\n * JSONSchema Validator - Validates JavaScript objects using JSON Schemas\r\n *\t(http://www.json.com/json-schema-proposal/)\r\n * Licensed under AFL-2.1 OR BSD-3-Clause\r\nTo use the validator call the validate function with an instance object and an optional schema object.\r\nIf a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),\r\nthat schema will be used to validate and the schema parameter is not necessary (if both exist,\r\nboth validations will occur).\r\nThe validate method will return an array of validation errors. If there are no errors, then an\r\nempty list will be returned. A validation error will have two properties:\r\n\"property\" which indicates which property had the error\r\n\"message\" which indicates what the error was\r\n */ (function(root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return factory();\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    var exports = validate;\n    exports.Integer = {\n        type: \"integer\"\n    };\n    var primitiveConstructors = {\n        String: String,\n        Boolean: Boolean,\n        Number: Number,\n        Object: Object,\n        Array: Array,\n        Date: Date\n    };\n    exports.validate = validate;\n    function validate(/*Any*/ instance, /*Object*/ schema) {\n        // Summary:\n        //  \tTo use the validator call JSONSchema.validate with an instance object and an optional schema object.\n        // \t\tIf a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),\n        // \t\tthat schema will be used to validate and the schema parameter is not necessary (if both exist,\n        // \t\tboth validations will occur).\n        // \t\tThe validate method will return an object with two properties:\n        // \t\t\tvalid: A boolean indicating if the instance is valid by the schema\n        // \t\t\terrors: An array of validation errors. If there are no errors, then an\n        // \t\t\t\t\tempty list will be returned. A validation error will have two properties:\n        // \t\t\t\t\t\tproperty: which indicates which property had the error\n        // \t\t\t\t\t\tmessage: which indicates what the error was\n        //\n        return validate(instance, schema, {\n            changing: false\n        }); //, coerce: false, existingOnly: false});\n    }\n    ;\n    exports.checkPropertyChange = function(/*Any*/ value, /*Object*/ schema, /*String*/ property) {\n        // Summary:\n        // \t\tThe checkPropertyChange method will check to see if an value can legally be in property with the given schema\n        // \t\tThis is slightly different than the validate method in that it will fail if the schema is readonly and it will\n        // \t\tnot check for self-validation, it is assumed that the passed in value is already internally valid.\n        // \t\tThe checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for\n        // \t\tinformation.\n        //\n        return validate(value, schema, {\n            changing: property || \"property\"\n        });\n    };\n    var validate = exports._validate = function(/*Any*/ instance, /*Object*/ schema, /*Object*/ options) {\n        if (!options) options = {};\n        var _changing = options.changing;\n        function getType(schema) {\n            return schema.type || primitiveConstructors[schema.name] == schema && schema.name.toLowerCase();\n        }\n        var errors = [];\n        // validate a value against a property definition\n        function checkProp(value, schema, path, i) {\n            var l;\n            path += path ? typeof i == \"number\" ? \"[\" + i + \"]\" : typeof i == \"undefined\" ? \"\" : \".\" + i : i;\n            function addError(message) {\n                errors.push({\n                    property: path,\n                    message: message\n                });\n            }\n            if ((typeof schema != \"object\" || schema instanceof Array) && (path || typeof schema != \"function\") && !(schema && getType(schema))) {\n                if (typeof schema == \"function\") {\n                    if (!(value instanceof schema)) {\n                        addError(\"is not an instance of the class/constructor \" + schema.name);\n                    }\n                } else if (schema) {\n                    addError(\"Invalid schema/property definition \" + schema);\n                }\n                return null;\n            }\n            if (_changing && schema.readonly) {\n                addError(\"is a readonly field, it can not be changed\");\n            }\n            if (schema[\"extends\"]) {\n                checkProp(value, schema[\"extends\"], path, i);\n            }\n            // validate a value against a type definition\n            function checkType(type, value) {\n                if (type) {\n                    if (typeof type == \"string\" && type != \"any\" && (type == \"null\" ? value !== null : typeof value != type) && !(value instanceof Array && type == \"array\") && !(value instanceof Date && type == \"date\") && !(type == \"integer\" && value % 1 === 0)) {\n                        return [\n                            {\n                                property: path,\n                                message: value + \" - \" + typeof value + \" value found, but a \" + type + \" is required\"\n                            }\n                        ];\n                    }\n                    if (type instanceof Array) {\n                        var unionErrors = [];\n                        for(var j = 0; j < type.length; j++){\n                            if (!(unionErrors = checkType(type[j], value)).length) {\n                                break;\n                            }\n                        }\n                        if (unionErrors.length) {\n                            return unionErrors;\n                        }\n                    } else if (typeof type == \"object\") {\n                        var priorErrors = errors;\n                        errors = [];\n                        checkProp(value, type, path);\n                        var theseErrors = errors;\n                        errors = priorErrors;\n                        return theseErrors;\n                    }\n                }\n                return [];\n            }\n            if (value === undefined) {\n                if (schema.required) {\n                    addError(\"is missing and it is required\");\n                }\n            } else {\n                errors = errors.concat(checkType(getType(schema), value));\n                if (schema.disallow && !checkType(schema.disallow, value).length) {\n                    addError(\" disallowed value was matched\");\n                }\n                if (value !== null) {\n                    if (value instanceof Array) {\n                        if (schema.items) {\n                            var itemsIsArray = schema.items instanceof Array;\n                            var propDef = schema.items;\n                            for(i = 0, l = value.length; i < l; i += 1){\n                                if (itemsIsArray) propDef = schema.items[i];\n                                if (options.coerce) value[i] = options.coerce(value[i], propDef);\n                                errors.concat(checkProp(value[i], propDef, path, i));\n                            }\n                        }\n                        if (schema.minItems && value.length < schema.minItems) {\n                            addError(\"There must be a minimum of \" + schema.minItems + \" in the array\");\n                        }\n                        if (schema.maxItems && value.length > schema.maxItems) {\n                            addError(\"There must be a maximum of \" + schema.maxItems + \" in the array\");\n                        }\n                    } else if (schema.properties || schema.additionalProperties) {\n                        errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));\n                    }\n                    if (schema.pattern && typeof value == \"string\" && !value.match(schema.pattern)) {\n                        addError(\"does not match the regex pattern \" + schema.pattern);\n                    }\n                    if (schema.maxLength && typeof value == \"string\" && value.length > schema.maxLength) {\n                        addError(\"may only be \" + schema.maxLength + \" characters long\");\n                    }\n                    if (schema.minLength && typeof value == \"string\" && value.length < schema.minLength) {\n                        addError(\"must be at least \" + schema.minLength + \" characters long\");\n                    }\n                    if (typeof schema.minimum !== \"undefined\" && typeof value == typeof schema.minimum && schema.minimum > value) {\n                        addError(\"must have a minimum value of \" + schema.minimum);\n                    }\n                    if (typeof schema.maximum !== \"undefined\" && typeof value == typeof schema.maximum && schema.maximum < value) {\n                        addError(\"must have a maximum value of \" + schema.maximum);\n                    }\n                    if (schema[\"enum\"]) {\n                        var enumer = schema[\"enum\"];\n                        l = enumer.length;\n                        var found;\n                        for(var j = 0; j < l; j++){\n                            if (enumer[j] === value) {\n                                found = 1;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            addError(\"does not have a value in the enumeration \" + enumer.join(\", \"));\n                        }\n                    }\n                    if (typeof schema.maxDecimal == \"number\" && value.toString().match(new RegExp(\"\\\\.[0-9]{\" + (schema.maxDecimal + 1) + \",}\"))) {\n                        addError(\"may only have \" + schema.maxDecimal + \" digits of decimal places\");\n                    }\n                }\n            }\n            return null;\n        }\n        // validate an object against a schema\n        function checkObj(instance, objTypeDef, path, additionalProp) {\n            if (typeof objTypeDef == \"object\") {\n                if (typeof instance != \"object\" || instance instanceof Array) {\n                    errors.push({\n                        property: path,\n                        message: \"an object is required\"\n                    });\n                }\n                for(var i in objTypeDef){\n                    if (objTypeDef.hasOwnProperty(i) && i != \"__proto__\" && i != \"constructor\") {\n                        var value = instance.hasOwnProperty(i) ? instance[i] : undefined;\n                        // skip _not_ specified properties\n                        if (value === undefined && options.existingOnly) continue;\n                        var propDef = objTypeDef[i];\n                        // set default\n                        if (value === undefined && propDef[\"default\"]) {\n                            value = instance[i] = propDef[\"default\"];\n                        }\n                        if (options.coerce && i in instance) {\n                            value = instance[i] = options.coerce(value, propDef);\n                        }\n                        checkProp(value, propDef, path, i);\n                    }\n                }\n            }\n            for(i in instance){\n                if (instance.hasOwnProperty(i) && !(i.charAt(0) == \"_\" && i.charAt(1) == \"_\") && objTypeDef && !objTypeDef[i] && additionalProp === false) {\n                    if (options.filter) {\n                        delete instance[i];\n                        continue;\n                    } else {\n                        errors.push({\n                            property: path,\n                            message: \"The property \" + i + \" is not defined in the schema and the schema does not allow additional properties\"\n                        });\n                    }\n                }\n                var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;\n                if (requires && !(requires in instance)) {\n                    errors.push({\n                        property: path,\n                        message: \"the presence of the property \" + i + \" requires that \" + requires + \" also be present\"\n                    });\n                }\n                value = instance[i];\n                if (additionalProp && (!(objTypeDef && typeof objTypeDef == \"object\") || !(i in objTypeDef))) {\n                    if (options.coerce) {\n                        value = instance[i] = options.coerce(value, additionalProp);\n                    }\n                    checkProp(value, additionalProp, path, i);\n                }\n                if (!_changing && value && value.$schema) {\n                    errors = errors.concat(checkProp(value, value.$schema, path, i));\n                }\n            }\n            return errors;\n        }\n        if (schema) {\n            checkProp(instance, schema, \"\", _changing || \"\");\n        }\n        if (!_changing && instance && instance.$schema) {\n            checkProp(instance, instance.$schema, \"\", \"\");\n        }\n        return {\n            valid: !errors.length,\n            errors: errors\n        };\n    };\n    exports.mustBeValid = function(result) {\n        //\tsummary:\n        //\t\tThis checks to ensure that the result is valid and will throw an appropriate error message if it is not\n        // result: the result returned from checkPropertyChange or validate\n        if (!result.valid) {\n            throw new TypeError(result.errors.map(function(error) {\n                return \"for property \" + error.property + \": \" + error.message;\n            }).join(\", \\n\"));\n        }\n    };\n    return exports;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEvbGliL3ZhbGlkYXRlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDQSxVQUFVQSxJQUFJLEVBQUVDLE9BQU87SUFDcEIsSUFBSSxJQUEwQyxFQUFFO1FBQzVDLHdDQUF3QztRQUN4Q0MsaUNBQU8sRUFBRSxtQ0FBRTtZQUNQLE9BQU9EO1FBQ1gsQ0FBQztBQUFBLGtHQUFDO0lBQ04sT0FBTyxFQVFOO0FBQ0wsR0FBRSxRQUFNO0lBQ1IsSUFBSUksVUFBVUU7SUFDZEYsUUFBUUcsT0FBTyxHQUFHO1FBQUNDLE1BQUs7SUFBUztJQUNqQyxJQUFJQyx3QkFBd0I7UUFDM0JDLFFBQVFBO1FBQ1JDLFNBQVNBO1FBQ1RDLFFBQVFBO1FBQ1JDLFFBQVFBO1FBQ1JDLE9BQU9BO1FBQ1BDLE1BQU1BO0lBQ1A7SUFDQVgsUUFBUUUsUUFBUSxHQUFHQTtJQUNuQixTQUFTQSxTQUFTLEtBQUssR0FBRVUsUUFBUSxFQUFDLFFBQVEsR0FBRUMsTUFBTTtRQUNoRCxXQUFXO1FBQ1gseUdBQXlHO1FBQ3pHLHVIQUF1SDtRQUN2SCxtR0FBbUc7UUFDbkcsa0NBQWtDO1FBQ2xDLG1FQUFtRTtRQUNuRSx3RUFBd0U7UUFDeEUsNEVBQTRFO1FBQzVFLGlGQUFpRjtRQUNqRiwrREFBK0Q7UUFDL0Qsb0RBQW9EO1FBQ3BELEVBQUU7UUFDRixPQUFPWCxTQUFTVSxVQUFVQyxRQUFRO1lBQUNDLFVBQVU7UUFBSyxJQUFHLHlDQUF5QztJQUMvRjs7SUFDRGQsUUFBUWUsbUJBQW1CLEdBQUcsU0FBUyxLQUFLLEdBQUVDLEtBQUssRUFBQyxRQUFRLEdBQUVILE1BQU0sRUFBRSxRQUFRLEdBQUVJLFFBQVE7UUFDdEYsV0FBVztRQUNYLGtIQUFrSDtRQUNsSCxtSEFBbUg7UUFDbkgsdUdBQXVHO1FBQ3ZHLDZHQUE2RztRQUM3RyxpQkFBaUI7UUFDakIsRUFBRTtRQUNGLE9BQU9mLFNBQVNjLE9BQU9ILFFBQVE7WUFB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QWMsT0FBT0EsY0FBYyxRQUFPLEtBQU0sQ0FBRXJDLENBQUFBLEtBQUtxQyxVQUFTLENBQUMsR0FBRztvQkFDM0YsSUFBRzdDLFFBQVEyQixNQUFNLEVBQUM7d0JBQ2pCOUIsUUFBUUosUUFBUSxDQUFDZSxFQUFFLEdBQUdSLFFBQVEyQixNQUFNLENBQUM5QixPQUFPaUQ7b0JBQzdDO29CQUNBeEMsVUFBVVQsT0FBTWlELGdCQUFldkMsTUFBS0M7Z0JBQ3JDO2dCQUNBLElBQUcsQ0FBQ1AsYUFBYUosU0FBU0EsTUFBTXVELE9BQU8sRUFBQztvQkFDdkMvQyxTQUFTQSxPQUFPaUIsTUFBTSxDQUFDaEIsVUFBVVQsT0FBTUEsTUFBTXVELE9BQU8sRUFBQzdDLE1BQUtDO2dCQUMzRDtZQUNEO1lBQ0EsT0FBT0g7UUFDUjtRQUNBLElBQUdYLFFBQU87WUFDVFksVUFBVWIsVUFBU0MsUUFBTyxJQUFHTyxhQUFhO1FBQzNDO1FBQ0EsSUFBRyxDQUFDQSxhQUFhUixZQUFZQSxTQUFTMkQsT0FBTyxFQUFDO1lBQzdDOUMsVUFBVWIsVUFBU0EsU0FBUzJELE9BQU8sRUFBQyxJQUFHO1FBQ3hDO1FBQ0EsT0FBTztZQUFDQyxPQUFNLENBQUNoRCxPQUFPWSxNQUFNO1lBQUNaLFFBQU9BO1FBQU07SUFDM0M7SUFDQXhCLFFBQVF5RSxXQUFXLEdBQUcsU0FBU0MsTUFBTTtRQUNwQyxXQUFXO1FBQ1gsMkdBQTJHO1FBQzNHLG1FQUFtRTtRQUNuRSxJQUFHLENBQUNBLE9BQU9GLEtBQUssRUFBQztZQUNoQixNQUFNLElBQUlHLFVBQVVELE9BQU9sRCxNQUFNLENBQUNvRCxHQUFHLENBQUMsU0FBU0MsS0FBSztnQkFBRSxPQUFPLGtCQUFrQkEsTUFBTTVELFFBQVEsR0FBRyxPQUFPNEQsTUFBTS9DLE9BQU87WUFBQyxHQUFHOEIsSUFBSSxDQUFDO1FBQzlIO0lBQ0Q7SUFFQSxPQUFPNUQ7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hL2xpYi92YWxpZGF0ZS5qcz81YTJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBKU09OU2NoZW1hIFZhbGlkYXRvciAtIFZhbGlkYXRlcyBKYXZhU2NyaXB0IG9iamVjdHMgdXNpbmcgSlNPTiBTY2hlbWFzXHJcbiAqXHQoaHR0cDovL3d3dy5qc29uLmNvbS9qc29uLXNjaGVtYS1wcm9wb3NhbC8pXHJcbiAqIExpY2Vuc2VkIHVuZGVyIEFGTC0yLjEgT1IgQlNELTMtQ2xhdXNlXHJcblRvIHVzZSB0aGUgdmFsaWRhdG9yIGNhbGwgdGhlIHZhbGlkYXRlIGZ1bmN0aW9uIHdpdGggYW4gaW5zdGFuY2Ugb2JqZWN0IGFuZCBhbiBvcHRpb25hbCBzY2hlbWEgb2JqZWN0LlxyXG5JZiBhIHNjaGVtYSBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlLiBJZiB0aGUgaW5zdGFuY2Ugb2JqZWN0IHJlZmVycyB0byBhIHNjaGVtYSAoc2VsZi12YWxpZGF0aW5nKSxcclxudGhhdCBzY2hlbWEgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0aGUgc2NoZW1hIHBhcmFtZXRlciBpcyBub3QgbmVjZXNzYXJ5IChpZiBib3RoIGV4aXN0LFxyXG5ib3RoIHZhbGlkYXRpb25zIHdpbGwgb2NjdXIpLlxyXG5UaGUgdmFsaWRhdGUgbWV0aG9kIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzLiBJZiB0aGVyZSBhcmUgbm8gZXJyb3JzLCB0aGVuIGFuXHJcbmVtcHR5IGxpc3Qgd2lsbCBiZSByZXR1cm5lZC4gQSB2YWxpZGF0aW9uIGVycm9yIHdpbGwgaGF2ZSB0d28gcHJvcGVydGllczpcclxuXCJwcm9wZXJ0eVwiIHdoaWNoIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0eSBoYWQgdGhlIGVycm9yXHJcblwibWVzc2FnZVwiIHdoaWNoIGluZGljYXRlcyB3aGF0IHRoZSBlcnJvciB3YXNcclxuICovXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcclxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcclxuICAgICAgICAvLyBsaWtlIE5vZGUuXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xyXG4gICAgICAgIHJvb3QuanNvblNjaGVtYSA9IGZhY3RvcnkoKTtcclxuICAgIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7Ly8gc2V0dXAgcHJpbWl0aXZlIGNsYXNzZXMgdG8gYmUgSlNPTiBTY2hlbWEgdHlwZXNcclxudmFyIGV4cG9ydHMgPSB2YWxpZGF0ZVxyXG5leHBvcnRzLkludGVnZXIgPSB7dHlwZTpcImludGVnZXJcIn07XHJcbnZhciBwcmltaXRpdmVDb25zdHJ1Y3RvcnMgPSB7XHJcblx0U3RyaW5nOiBTdHJpbmcsXHJcblx0Qm9vbGVhbjogQm9vbGVhbixcclxuXHROdW1iZXI6IE51bWJlcixcclxuXHRPYmplY3Q6IE9iamVjdCxcclxuXHRBcnJheTogQXJyYXksXHJcblx0RGF0ZTogRGF0ZVxyXG59XHJcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcclxuZnVuY3Rpb24gdmFsaWRhdGUoLypBbnkqL2luc3RhbmNlLC8qT2JqZWN0Ki9zY2hlbWEpIHtcclxuXHRcdC8vIFN1bW1hcnk6XHJcblx0XHQvLyAgXHRUbyB1c2UgdGhlIHZhbGlkYXRvciBjYWxsIEpTT05TY2hlbWEudmFsaWRhdGUgd2l0aCBhbiBpbnN0YW5jZSBvYmplY3QgYW5kIGFuIG9wdGlvbmFsIHNjaGVtYSBvYmplY3QuXHJcblx0XHQvLyBcdFx0SWYgYSBzY2hlbWEgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZS4gSWYgdGhlIGluc3RhbmNlIG9iamVjdCByZWZlcnMgdG8gYSBzY2hlbWEgKHNlbGYtdmFsaWRhdGluZyksXHJcblx0XHQvLyBcdFx0dGhhdCBzY2hlbWEgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0aGUgc2NoZW1hIHBhcmFtZXRlciBpcyBub3QgbmVjZXNzYXJ5IChpZiBib3RoIGV4aXN0LFxyXG5cdFx0Ly8gXHRcdGJvdGggdmFsaWRhdGlvbnMgd2lsbCBvY2N1cikuXHJcblx0XHQvLyBcdFx0VGhlIHZhbGlkYXRlIG1ldGhvZCB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczpcclxuXHRcdC8vIFx0XHRcdHZhbGlkOiBBIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgaW5zdGFuY2UgaXMgdmFsaWQgYnkgdGhlIHNjaGVtYVxyXG5cdFx0Ly8gXHRcdFx0ZXJyb3JzOiBBbiBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9ycy4gSWYgdGhlcmUgYXJlIG5vIGVycm9ycywgdGhlbiBhblxyXG5cdFx0Ly8gXHRcdFx0XHRcdGVtcHR5IGxpc3Qgd2lsbCBiZSByZXR1cm5lZC4gQSB2YWxpZGF0aW9uIGVycm9yIHdpbGwgaGF2ZSB0d28gcHJvcGVydGllczpcclxuXHRcdC8vIFx0XHRcdFx0XHRcdHByb3BlcnR5OiB3aGljaCBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydHkgaGFkIHRoZSBlcnJvclxyXG5cdFx0Ly8gXHRcdFx0XHRcdFx0bWVzc2FnZTogd2hpY2ggaW5kaWNhdGVzIHdoYXQgdGhlIGVycm9yIHdhc1xyXG5cdFx0Ly9cclxuXHRcdHJldHVybiB2YWxpZGF0ZShpbnN0YW5jZSwgc2NoZW1hLCB7Y2hhbmdpbmc6IGZhbHNlfSk7Ly8sIGNvZXJjZTogZmFsc2UsIGV4aXN0aW5nT25seTogZmFsc2V9KTtcclxuXHR9O1xyXG5leHBvcnRzLmNoZWNrUHJvcGVydHlDaGFuZ2UgPSBmdW5jdGlvbigvKkFueSovdmFsdWUsLypPYmplY3QqL3NjaGVtYSwgLypTdHJpbmcqL3Byb3BlcnR5KSB7XHJcblx0XHQvLyBTdW1tYXJ5OlxyXG5cdFx0Ly8gXHRcdFRoZSBjaGVja1Byb3BlcnR5Q2hhbmdlIG1ldGhvZCB3aWxsIGNoZWNrIHRvIHNlZSBpZiBhbiB2YWx1ZSBjYW4gbGVnYWxseSBiZSBpbiBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBzY2hlbWFcclxuXHRcdC8vIFx0XHRUaGlzIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIHRoZSB2YWxpZGF0ZSBtZXRob2QgaW4gdGhhdCBpdCB3aWxsIGZhaWwgaWYgdGhlIHNjaGVtYSBpcyByZWFkb25seSBhbmQgaXQgd2lsbFxyXG5cdFx0Ly8gXHRcdG5vdCBjaGVjayBmb3Igc2VsZi12YWxpZGF0aW9uLCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHBhc3NlZCBpbiB2YWx1ZSBpcyBhbHJlYWR5IGludGVybmFsbHkgdmFsaWQuXHJcblx0XHQvLyBcdFx0VGhlIGNoZWNrUHJvcGVydHlDaGFuZ2UgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lIG9iamVjdCB0eXBlIGFzIHZhbGlkYXRlLCBzZWUgSlNPTlNjaGVtYS52YWxpZGF0ZSBmb3JcclxuXHRcdC8vIFx0XHRpbmZvcm1hdGlvbi5cclxuXHRcdC8vXHJcblx0XHRyZXR1cm4gdmFsaWRhdGUodmFsdWUsIHNjaGVtYSwge2NoYW5naW5nOiBwcm9wZXJ0eSB8fCBcInByb3BlcnR5XCJ9KTtcclxuXHR9O1xyXG52YXIgdmFsaWRhdGUgPSBleHBvcnRzLl92YWxpZGF0ZSA9IGZ1bmN0aW9uKC8qQW55Ki9pbnN0YW5jZSwvKk9iamVjdCovc2NoZW1hLC8qT2JqZWN0Ki9vcHRpb25zKSB7XHJcblxyXG5cdGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG5cdHZhciBfY2hhbmdpbmcgPSBvcHRpb25zLmNoYW5naW5nO1xyXG5cclxuXHRmdW5jdGlvbiBnZXRUeXBlKHNjaGVtYSl7XHJcblx0XHRyZXR1cm4gc2NoZW1hLnR5cGUgfHwgKHByaW1pdGl2ZUNvbnN0cnVjdG9yc1tzY2hlbWEubmFtZV0gPT0gc2NoZW1hICYmIHNjaGVtYS5uYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG5cdH1cclxuXHR2YXIgZXJyb3JzID0gW107XHJcblx0Ly8gdmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgcHJvcGVydHkgZGVmaW5pdGlvblxyXG5cdGZ1bmN0aW9uIGNoZWNrUHJvcCh2YWx1ZSwgc2NoZW1hLCBwYXRoLGkpe1xyXG5cclxuXHRcdHZhciBsO1xyXG5cdFx0cGF0aCArPSBwYXRoID8gdHlwZW9mIGkgPT0gJ251bWJlcicgPyAnWycgKyBpICsgJ10nIDogdHlwZW9mIGkgPT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICcuJyArIGkgOiBpO1xyXG5cdFx0ZnVuY3Rpb24gYWRkRXJyb3IobWVzc2FnZSl7XHJcblx0XHRcdGVycm9ycy5wdXNoKHtwcm9wZXJ0eTpwYXRoLG1lc3NhZ2U6bWVzc2FnZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCh0eXBlb2Ygc2NoZW1hICE9ICdvYmplY3QnIHx8IHNjaGVtYSBpbnN0YW5jZW9mIEFycmF5KSAmJiAocGF0aCB8fCB0eXBlb2Ygc2NoZW1hICE9ICdmdW5jdGlvbicpICYmICEoc2NoZW1hICYmIGdldFR5cGUoc2NoZW1hKSkpe1xyXG5cdFx0XHRpZih0eXBlb2Ygc2NoZW1hID09ICdmdW5jdGlvbicpe1xyXG5cdFx0XHRcdGlmKCEodmFsdWUgaW5zdGFuY2VvZiBzY2hlbWEpKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwiaXMgbm90IGFuIGluc3RhbmNlIG9mIHRoZSBjbGFzcy9jb25zdHJ1Y3RvciBcIiArIHNjaGVtYS5uYW1lKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKHNjaGVtYSl7XHJcblx0XHRcdFx0YWRkRXJyb3IoXCJJbnZhbGlkIHNjaGVtYS9wcm9wZXJ0eSBkZWZpbml0aW9uIFwiICsgc2NoZW1hKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdGlmKF9jaGFuZ2luZyAmJiBzY2hlbWEucmVhZG9ubHkpe1xyXG5cdFx0XHRhZGRFcnJvcihcImlzIGEgcmVhZG9ubHkgZmllbGQsIGl0IGNhbiBub3QgYmUgY2hhbmdlZFwiKTtcclxuXHRcdH1cclxuXHRcdGlmKHNjaGVtYVsnZXh0ZW5kcyddKXsgLy8gaWYgaXQgZXh0ZW5kcyBhbm90aGVyIHNjaGVtYSwgaXQgbXVzdCBwYXNzIHRoYXQgc2NoZW1hIGFzIHdlbGxcclxuXHRcdFx0Y2hlY2tQcm9wKHZhbHVlLHNjaGVtYVsnZXh0ZW5kcyddLHBhdGgsaSk7XHJcblx0XHR9XHJcblx0XHQvLyB2YWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSB0eXBlIGRlZmluaXRpb25cclxuXHRcdGZ1bmN0aW9uIGNoZWNrVHlwZSh0eXBlLHZhbHVlKXtcclxuXHRcdFx0aWYodHlwZSl7XHJcblx0XHRcdFx0aWYodHlwZW9mIHR5cGUgPT0gJ3N0cmluZycgJiYgdHlwZSAhPSAnYW55JyAmJlxyXG5cdFx0XHRcdFx0XHQodHlwZSA9PSAnbnVsbCcgPyB2YWx1ZSAhPT0gbnVsbCA6IHR5cGVvZiB2YWx1ZSAhPSB0eXBlKSAmJlxyXG5cdFx0XHRcdFx0XHQhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdHlwZSA9PSAnYXJyYXknKSAmJlxyXG5cdFx0XHRcdFx0XHQhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiB0eXBlID09ICdkYXRlJykgJiZcclxuXHRcdFx0XHRcdFx0ISh0eXBlID09ICdpbnRlZ2VyJyAmJiB2YWx1ZSUxPT09MCkpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIFt7cHJvcGVydHk6cGF0aCxtZXNzYWdlOnZhbHVlICsgXCIgLSBcIiArICh0eXBlb2YgdmFsdWUpICsgXCIgdmFsdWUgZm91bmQsIGJ1dCBhIFwiICsgdHlwZSArIFwiIGlzIHJlcXVpcmVkXCJ9XTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZSBpbnN0YW5jZW9mIEFycmF5KXtcclxuXHRcdFx0XHRcdHZhciB1bmlvbkVycm9ycz1bXTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCB0eXBlLmxlbmd0aDsgaisrKXsgLy8gYSB1bmlvbiB0eXBlXHJcblx0XHRcdFx0XHRcdGlmKCEodW5pb25FcnJvcnM9Y2hlY2tUeXBlKHR5cGVbal0sdmFsdWUpKS5sZW5ndGgpe1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZih1bmlvbkVycm9ycy5sZW5ndGgpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5pb25FcnJvcnM7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fWVsc2UgaWYodHlwZW9mIHR5cGUgPT0gJ29iamVjdCcpe1xyXG5cdFx0XHRcdFx0dmFyIHByaW9yRXJyb3JzID0gZXJyb3JzO1xyXG5cdFx0XHRcdFx0ZXJyb3JzID0gW107XHJcblx0XHRcdFx0XHRjaGVja1Byb3AodmFsdWUsdHlwZSxwYXRoKTtcclxuXHRcdFx0XHRcdHZhciB0aGVzZUVycm9ycyA9IGVycm9ycztcclxuXHRcdFx0XHRcdGVycm9ycyA9IHByaW9yRXJyb3JzO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoZXNlRXJyb3JzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblx0XHRpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0aWYoc2NoZW1hLnJlcXVpcmVkKXtcclxuXHRcdFx0XHRhZGRFcnJvcihcImlzIG1pc3NpbmcgYW5kIGl0IGlzIHJlcXVpcmVkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0ZXJyb3JzID0gZXJyb3JzLmNvbmNhdChjaGVja1R5cGUoZ2V0VHlwZShzY2hlbWEpLHZhbHVlKSk7XHJcblx0XHRcdGlmKHNjaGVtYS5kaXNhbGxvdyAmJiAhY2hlY2tUeXBlKHNjaGVtYS5kaXNhbGxvdyx2YWx1ZSkubGVuZ3RoKXtcclxuXHRcdFx0XHRhZGRFcnJvcihcIiBkaXNhbGxvd2VkIHZhbHVlIHdhcyBtYXRjaGVkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHZhbHVlICE9PSBudWxsKXtcclxuXHRcdFx0XHRpZih2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KXtcclxuXHRcdFx0XHRcdGlmKHNjaGVtYS5pdGVtcyl7XHJcblx0XHRcdFx0XHRcdHZhciBpdGVtc0lzQXJyYXkgPSBzY2hlbWEuaXRlbXMgaW5zdGFuY2VvZiBBcnJheTtcclxuXHRcdFx0XHRcdFx0dmFyIHByb3BEZWYgPSBzY2hlbWEuaXRlbXM7XHJcblx0XHRcdFx0XHRcdGZvciAoaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaXRlbXNJc0FycmF5KVxyXG5cdFx0XHRcdFx0XHRcdFx0cHJvcERlZiA9IHNjaGVtYS5pdGVtc1tpXTtcclxuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5jb2VyY2UpXHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZVtpXSA9IG9wdGlvbnMuY29lcmNlKHZhbHVlW2ldLCBwcm9wRGVmKTtcclxuXHRcdFx0XHRcdFx0XHRlcnJvcnMuY29uY2F0KGNoZWNrUHJvcCh2YWx1ZVtpXSxwcm9wRGVmLHBhdGgsaSkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihzY2hlbWEubWluSXRlbXMgJiYgdmFsdWUubGVuZ3RoIDwgc2NoZW1hLm1pbkl0ZW1zKXtcclxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoXCJUaGVyZSBtdXN0IGJlIGEgbWluaW11bSBvZiBcIiArIHNjaGVtYS5taW5JdGVtcyArIFwiIGluIHRoZSBhcnJheVwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKHNjaGVtYS5tYXhJdGVtcyAmJiB2YWx1ZS5sZW5ndGggPiBzY2hlbWEubWF4SXRlbXMpe1xyXG5cdFx0XHRcdFx0XHRhZGRFcnJvcihcIlRoZXJlIG11c3QgYmUgYSBtYXhpbXVtIG9mIFwiICsgc2NoZW1hLm1heEl0ZW1zICsgXCIgaW4gdGhlIGFycmF5XCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1lbHNlIGlmKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyl7XHJcblx0XHRcdFx0XHRlcnJvcnMuY29uY2F0KGNoZWNrT2JqKHZhbHVlLCBzY2hlbWEucHJvcGVydGllcywgcGF0aCwgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYS5wYXR0ZXJuICYmIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiAhdmFsdWUubWF0Y2goc2NoZW1hLnBhdHRlcm4pKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwiZG9lcyBub3QgbWF0Y2ggdGhlIHJlZ2V4IHBhdHRlcm4gXCIgKyBzY2hlbWEucGF0dGVybik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYS5tYXhMZW5ndGggJiYgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IHNjaGVtYS5tYXhMZW5ndGgpe1xyXG5cdFx0XHRcdFx0YWRkRXJyb3IoXCJtYXkgb25seSBiZSBcIiArIHNjaGVtYS5tYXhMZW5ndGggKyBcIiBjaGFyYWN0ZXJzIGxvbmdcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYS5taW5MZW5ndGggJiYgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA8IHNjaGVtYS5taW5MZW5ndGgpe1xyXG5cdFx0XHRcdFx0YWRkRXJyb3IoXCJtdXN0IGJlIGF0IGxlYXN0IFwiICsgc2NoZW1hLm1pbkxlbmd0aCArIFwiIGNoYXJhY3RlcnMgbG9uZ1wiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZW9mIHNjaGVtYS5taW5pbXVtICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdmFsdWUgPT0gdHlwZW9mIHNjaGVtYS5taW5pbXVtICYmXHJcblx0XHRcdFx0XHRcdHNjaGVtYS5taW5pbXVtID4gdmFsdWUpe1xyXG5cdFx0XHRcdFx0YWRkRXJyb3IoXCJtdXN0IGhhdmUgYSBtaW5pbXVtIHZhbHVlIG9mIFwiICsgc2NoZW1hLm1pbmltdW0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih0eXBlb2Ygc2NoZW1hLm1heGltdW0gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB2YWx1ZSA9PSB0eXBlb2Ygc2NoZW1hLm1heGltdW0gJiZcclxuXHRcdFx0XHRcdFx0c2NoZW1hLm1heGltdW0gPCB2YWx1ZSl7XHJcblx0XHRcdFx0XHRhZGRFcnJvcihcIm11c3QgaGF2ZSBhIG1heGltdW0gdmFsdWUgb2YgXCIgKyBzY2hlbWEubWF4aW11bSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYVsnZW51bSddKXtcclxuXHRcdFx0XHRcdHZhciBlbnVtZXIgPSBzY2hlbWFbJ2VudW0nXTtcclxuXHRcdFx0XHRcdGwgPSBlbnVtZXIubGVuZ3RoO1xyXG5cdFx0XHRcdFx0dmFyIGZvdW5kO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGw7IGorKyl7XHJcblx0XHRcdFx0XHRcdGlmKGVudW1lcltqXT09PXZhbHVlKXtcclxuXHRcdFx0XHRcdFx0XHRmb3VuZD0xO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZighZm91bmQpe1xyXG5cdFx0XHRcdFx0XHRhZGRFcnJvcihcImRvZXMgbm90IGhhdmUgYSB2YWx1ZSBpbiB0aGUgZW51bWVyYXRpb24gXCIgKyBlbnVtZXIuam9pbihcIiwgXCIpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZW9mIHNjaGVtYS5tYXhEZWNpbWFsID09ICdudW1iZXInICYmXHJcblx0XHRcdFx0XHQodmFsdWUudG9TdHJpbmcoKS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXC5bMC05XXtcIiArIChzY2hlbWEubWF4RGVjaW1hbCArIDEpICsgXCIsfVwiKSkpKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwibWF5IG9ubHkgaGF2ZSBcIiArIHNjaGVtYS5tYXhEZWNpbWFsICsgXCIgZGlnaXRzIG9mIGRlY2ltYWwgcGxhY2VzXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdC8vIHZhbGlkYXRlIGFuIG9iamVjdCBhZ2FpbnN0IGEgc2NoZW1hXHJcblx0ZnVuY3Rpb24gY2hlY2tPYmooaW5zdGFuY2Usb2JqVHlwZURlZixwYXRoLGFkZGl0aW9uYWxQcm9wKXtcclxuXHJcblx0XHRpZih0eXBlb2Ygb2JqVHlwZURlZiA9PSdvYmplY3QnKXtcclxuXHRcdFx0aWYodHlwZW9mIGluc3RhbmNlICE9ICdvYmplY3QnIHx8IGluc3RhbmNlIGluc3RhbmNlb2YgQXJyYXkpe1xyXG5cdFx0XHRcdGVycm9ycy5wdXNoKHtwcm9wZXJ0eTpwYXRoLG1lc3NhZ2U6XCJhbiBvYmplY3QgaXMgcmVxdWlyZWRcIn0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IodmFyIGkgaW4gb2JqVHlwZURlZil7IFxyXG5cdFx0XHRcdGlmKG9ialR5cGVEZWYuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPSAnX19wcm90b19fJyAmJiBpICE9ICdjb25zdHJ1Y3Rvcicpe1xyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gaW5zdGFuY2UuaGFzT3duUHJvcGVydHkoaSkgPyBpbnN0YW5jZVtpXSA6IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdC8vIHNraXAgX25vdF8gc3BlY2lmaWVkIHByb3BlcnRpZXNcclxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuZXhpc3RpbmdPbmx5KSBjb250aW51ZTtcclxuXHRcdFx0XHRcdHZhciBwcm9wRGVmID0gb2JqVHlwZURlZltpXTtcclxuXHRcdFx0XHRcdC8vIHNldCBkZWZhdWx0XHJcblx0XHRcdFx0XHRpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHByb3BEZWZbXCJkZWZhdWx0XCJdKXtcclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBpbnN0YW5jZVtpXSA9IHByb3BEZWZbXCJkZWZhdWx0XCJdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYob3B0aW9ucy5jb2VyY2UgJiYgaSBpbiBpbnN0YW5jZSl7XHJcblx0XHRcdFx0XHRcdHZhbHVlID0gaW5zdGFuY2VbaV0gPSBvcHRpb25zLmNvZXJjZSh2YWx1ZSwgcHJvcERlZik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjaGVja1Byb3AodmFsdWUscHJvcERlZixwYXRoLGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgaW4gaW5zdGFuY2Upe1xyXG5cdFx0XHRpZihpbnN0YW5jZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhKGkuY2hhckF0KDApID09ICdfJyAmJiBpLmNoYXJBdCgxKSA9PSAnXycpICYmIG9ialR5cGVEZWYgJiYgIW9ialR5cGVEZWZbaV0gJiYgYWRkaXRpb25hbFByb3A9PT1mYWxzZSl7XHJcblx0XHRcdFx0aWYgKG9wdGlvbnMuZmlsdGVyKSB7XHJcblx0XHRcdFx0XHRkZWxldGUgaW5zdGFuY2VbaV07XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZXJyb3JzLnB1c2goe3Byb3BlcnR5OnBhdGgsbWVzc2FnZTpcIlRoZSBwcm9wZXJ0eSBcIiArIGkgK1xyXG5cdFx0XHRcdFx0XHRcIiBpcyBub3QgZGVmaW5lZCBpbiB0aGUgc2NoZW1hIGFuZCB0aGUgc2NoZW1hIGRvZXMgbm90IGFsbG93IGFkZGl0aW9uYWwgcHJvcGVydGllc1wifSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHZhciByZXF1aXJlcyA9IG9ialR5cGVEZWYgJiYgb2JqVHlwZURlZltpXSAmJiBvYmpUeXBlRGVmW2ldLnJlcXVpcmVzO1xyXG5cdFx0XHRpZihyZXF1aXJlcyAmJiAhKHJlcXVpcmVzIGluIGluc3RhbmNlKSl7XHJcblx0XHRcdFx0ZXJyb3JzLnB1c2goe3Byb3BlcnR5OnBhdGgsbWVzc2FnZTpcInRoZSBwcmVzZW5jZSBvZiB0aGUgcHJvcGVydHkgXCIgKyBpICsgXCIgcmVxdWlyZXMgdGhhdCBcIiArIHJlcXVpcmVzICsgXCIgYWxzbyBiZSBwcmVzZW50XCJ9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldO1xyXG5cdFx0XHRpZihhZGRpdGlvbmFsUHJvcCAmJiAoIShvYmpUeXBlRGVmICYmIHR5cGVvZiBvYmpUeXBlRGVmID09ICdvYmplY3QnKSB8fCAhKGkgaW4gb2JqVHlwZURlZikpKXtcclxuXHRcdFx0XHRpZihvcHRpb25zLmNvZXJjZSl7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldID0gb3B0aW9ucy5jb2VyY2UodmFsdWUsIGFkZGl0aW9uYWxQcm9wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2hlY2tQcm9wKHZhbHVlLGFkZGl0aW9uYWxQcm9wLHBhdGgsaSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIV9jaGFuZ2luZyAmJiB2YWx1ZSAmJiB2YWx1ZS4kc2NoZW1hKXtcclxuXHRcdFx0XHRlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGNoZWNrUHJvcCh2YWx1ZSx2YWx1ZS4kc2NoZW1hLHBhdGgsaSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXJyb3JzO1xyXG5cdH1cclxuXHRpZihzY2hlbWEpe1xyXG5cdFx0Y2hlY2tQcm9wKGluc3RhbmNlLHNjaGVtYSwnJyxfY2hhbmdpbmcgfHwgJycpO1xyXG5cdH1cclxuXHRpZighX2NoYW5naW5nICYmIGluc3RhbmNlICYmIGluc3RhbmNlLiRzY2hlbWEpe1xyXG5cdFx0Y2hlY2tQcm9wKGluc3RhbmNlLGluc3RhbmNlLiRzY2hlbWEsJycsJycpO1xyXG5cdH1cclxuXHRyZXR1cm4ge3ZhbGlkOiFlcnJvcnMubGVuZ3RoLGVycm9yczplcnJvcnN9O1xyXG59O1xyXG5leHBvcnRzLm11c3RCZVZhbGlkID0gZnVuY3Rpb24ocmVzdWx0KXtcclxuXHQvL1x0c3VtbWFyeTpcclxuXHQvL1x0XHRUaGlzIGNoZWNrcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IGlzIHZhbGlkIGFuZCB3aWxsIHRocm93IGFuIGFwcHJvcHJpYXRlIGVycm9yIG1lc3NhZ2UgaWYgaXQgaXMgbm90XHJcblx0Ly8gcmVzdWx0OiB0aGUgcmVzdWx0IHJldHVybmVkIGZyb20gY2hlY2tQcm9wZXJ0eUNoYW5nZSBvciB2YWxpZGF0ZVxyXG5cdGlmKCFyZXN1bHQudmFsaWQpe1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihyZXN1bHQuZXJyb3JzLm1hcChmdW5jdGlvbihlcnJvcil7cmV0dXJuIFwiZm9yIHByb3BlcnR5IFwiICsgZXJyb3IucHJvcGVydHkgKyAnOiAnICsgZXJyb3IubWVzc2FnZTt9KS5qb2luKFwiLCBcXG5cIikpO1xyXG5cdH1cclxufVxyXG5cclxucmV0dXJuIGV4cG9ydHM7XHJcbn0pKTtcclxuIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsImpzb25TY2hlbWEiLCJ2YWxpZGF0ZSIsIkludGVnZXIiLCJ0eXBlIiwicHJpbWl0aXZlQ29uc3RydWN0b3JzIiwiU3RyaW5nIiwiQm9vbGVhbiIsIk51bWJlciIsIk9iamVjdCIsIkFycmF5IiwiRGF0ZSIsImluc3RhbmNlIiwic2NoZW1hIiwiY2hhbmdpbmciLCJjaGVja1Byb3BlcnR5Q2hhbmdlIiwidmFsdWUiLCJwcm9wZXJ0eSIsIl92YWxpZGF0ZSIsIm9wdGlvbnMiLCJfY2hhbmdpbmciLCJnZXRUeXBlIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiZXJyb3JzIiwiY2hlY2tQcm9wIiwicGF0aCIsImkiLCJsIiwiYWRkRXJyb3IiLCJtZXNzYWdlIiwicHVzaCIsInJlYWRvbmx5IiwiY2hlY2tUeXBlIiwidW5pb25FcnJvcnMiLCJqIiwibGVuZ3RoIiwicHJpb3JFcnJvcnMiLCJ0aGVzZUVycm9ycyIsInVuZGVmaW5lZCIsInJlcXVpcmVkIiwiY29uY2F0IiwiZGlzYWxsb3ciLCJpdGVtcyIsIml0ZW1zSXNBcnJheSIsInByb3BEZWYiLCJjb2VyY2UiLCJtaW5JdGVtcyIsIm1heEl0ZW1zIiwicHJvcGVydGllcyIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiY2hlY2tPYmoiLCJwYXR0ZXJuIiwibWF0Y2giLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJtaW5pbXVtIiwibWF4aW11bSIsImVudW1lciIsImZvdW5kIiwiam9pbiIsIm1heERlY2ltYWwiLCJ0b1N0cmluZyIsIlJlZ0V4cCIsIm9ialR5cGVEZWYiLCJhZGRpdGlvbmFsUHJvcCIsImhhc093blByb3BlcnR5IiwiZXhpc3RpbmdPbmx5IiwiY2hhckF0IiwiZmlsdGVyIiwicmVxdWlyZXMiLCIkc2NoZW1hIiwidmFsaWQiLCJtdXN0QmVWYWxpZCIsInJlc3VsdCIsIlR5cGVFcnJvciIsIm1hcCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-schema/lib/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/json-schema/lib/validate.js":
/*!**************************************************!*\
  !*** ./node_modules/json-schema/lib/validate.js ***!
  \**************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/**\r\n * JSONSchema Validator - Validates JavaScript objects using JSON Schemas\r\n *\t(http://www.json.com/json-schema-proposal/)\r\n * Licensed under AFL-2.1 OR BSD-3-Clause\r\nTo use the validator call the validate function with an instance object and an optional schema object.\r\nIf a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),\r\nthat schema will be used to validate and the schema parameter is not necessary (if both exist,\r\nboth validations will occur).\r\nThe validate method will return an array of validation errors. If there are no errors, then an\r\nempty list will be returned. A validation error will have two properties:\r\n\"property\" which indicates which property had the error\r\n\"message\" which indicates what the error was\r\n */ (function(root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return factory();\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    var exports = validate;\n    exports.Integer = {\n        type: \"integer\"\n    };\n    var primitiveConstructors = {\n        String: String,\n        Boolean: Boolean,\n        Number: Number,\n        Object: Object,\n        Array: Array,\n        Date: Date\n    };\n    exports.validate = validate;\n    function validate(/*Any*/ instance, /*Object*/ schema) {\n        // Summary:\n        //  \tTo use the validator call JSONSchema.validate with an instance object and an optional schema object.\n        // \t\tIf a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),\n        // \t\tthat schema will be used to validate and the schema parameter is not necessary (if both exist,\n        // \t\tboth validations will occur).\n        // \t\tThe validate method will return an object with two properties:\n        // \t\t\tvalid: A boolean indicating if the instance is valid by the schema\n        // \t\t\terrors: An array of validation errors. If there are no errors, then an\n        // \t\t\t\t\tempty list will be returned. A validation error will have two properties:\n        // \t\t\t\t\t\tproperty: which indicates which property had the error\n        // \t\t\t\t\t\tmessage: which indicates what the error was\n        //\n        return validate(instance, schema, {\n            changing: false\n        }); //, coerce: false, existingOnly: false});\n    }\n    ;\n    exports.checkPropertyChange = function(/*Any*/ value, /*Object*/ schema, /*String*/ property) {\n        // Summary:\n        // \t\tThe checkPropertyChange method will check to see if an value can legally be in property with the given schema\n        // \t\tThis is slightly different than the validate method in that it will fail if the schema is readonly and it will\n        // \t\tnot check for self-validation, it is assumed that the passed in value is already internally valid.\n        // \t\tThe checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for\n        // \t\tinformation.\n        //\n        return validate(value, schema, {\n            changing: property || \"property\"\n        });\n    };\n    var validate = exports._validate = function(/*Any*/ instance, /*Object*/ schema, /*Object*/ options) {\n        if (!options) options = {};\n        var _changing = options.changing;\n        function getType(schema) {\n            return schema.type || primitiveConstructors[schema.name] == schema && schema.name.toLowerCase();\n        }\n        var errors = [];\n        // validate a value against a property definition\n        function checkProp(value, schema, path, i) {\n            var l;\n            path += path ? typeof i == \"number\" ? \"[\" + i + \"]\" : typeof i == \"undefined\" ? \"\" : \".\" + i : i;\n            function addError(message) {\n                errors.push({\n                    property: path,\n                    message: message\n                });\n            }\n            if ((typeof schema != \"object\" || schema instanceof Array) && (path || typeof schema != \"function\") && !(schema && getType(schema))) {\n                if (typeof schema == \"function\") {\n                    if (!(value instanceof schema)) {\n                        addError(\"is not an instance of the class/constructor \" + schema.name);\n                    }\n                } else if (schema) {\n                    addError(\"Invalid schema/property definition \" + schema);\n                }\n                return null;\n            }\n            if (_changing && schema.readonly) {\n                addError(\"is a readonly field, it can not be changed\");\n            }\n            if (schema[\"extends\"]) {\n                checkProp(value, schema[\"extends\"], path, i);\n            }\n            // validate a value against a type definition\n            function checkType(type, value) {\n                if (type) {\n                    if (typeof type == \"string\" && type != \"any\" && (type == \"null\" ? value !== null : typeof value != type) && !(value instanceof Array && type == \"array\") && !(value instanceof Date && type == \"date\") && !(type == \"integer\" && value % 1 === 0)) {\n                        return [\n                            {\n                                property: path,\n                                message: value + \" - \" + typeof value + \" value found, but a \" + type + \" is required\"\n                            }\n                        ];\n                    }\n                    if (type instanceof Array) {\n                        var unionErrors = [];\n                        for(var j = 0; j < type.length; j++){\n                            if (!(unionErrors = checkType(type[j], value)).length) {\n                                break;\n                            }\n                        }\n                        if (unionErrors.length) {\n                            return unionErrors;\n                        }\n                    } else if (typeof type == \"object\") {\n                        var priorErrors = errors;\n                        errors = [];\n                        checkProp(value, type, path);\n                        var theseErrors = errors;\n                        errors = priorErrors;\n                        return theseErrors;\n                    }\n                }\n                return [];\n            }\n            if (value === undefined) {\n                if (schema.required) {\n                    addError(\"is missing and it is required\");\n                }\n            } else {\n                errors = errors.concat(checkType(getType(schema), value));\n                if (schema.disallow && !checkType(schema.disallow, value).length) {\n                    addError(\" disallowed value was matched\");\n                }\n                if (value !== null) {\n                    if (value instanceof Array) {\n                        if (schema.items) {\n                            var itemsIsArray = schema.items instanceof Array;\n                            var propDef = schema.items;\n                            for(i = 0, l = value.length; i < l; i += 1){\n                                if (itemsIsArray) propDef = schema.items[i];\n                                if (options.coerce) value[i] = options.coerce(value[i], propDef);\n                                errors.concat(checkProp(value[i], propDef, path, i));\n                            }\n                        }\n                        if (schema.minItems && value.length < schema.minItems) {\n                            addError(\"There must be a minimum of \" + schema.minItems + \" in the array\");\n                        }\n                        if (schema.maxItems && value.length > schema.maxItems) {\n                            addError(\"There must be a maximum of \" + schema.maxItems + \" in the array\");\n                        }\n                    } else if (schema.properties || schema.additionalProperties) {\n                        errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));\n                    }\n                    if (schema.pattern && typeof value == \"string\" && !value.match(schema.pattern)) {\n                        addError(\"does not match the regex pattern \" + schema.pattern);\n                    }\n                    if (schema.maxLength && typeof value == \"string\" && value.length > schema.maxLength) {\n                        addError(\"may only be \" + schema.maxLength + \" characters long\");\n                    }\n                    if (schema.minLength && typeof value == \"string\" && value.length < schema.minLength) {\n                        addError(\"must be at least \" + schema.minLength + \" characters long\");\n                    }\n                    if (typeof schema.minimum !== \"undefined\" && typeof value == typeof schema.minimum && schema.minimum > value) {\n                        addError(\"must have a minimum value of \" + schema.minimum);\n                    }\n                    if (typeof schema.maximum !== \"undefined\" && typeof value == typeof schema.maximum && schema.maximum < value) {\n                        addError(\"must have a maximum value of \" + schema.maximum);\n                    }\n                    if (schema[\"enum\"]) {\n                        var enumer = schema[\"enum\"];\n                        l = enumer.length;\n                        var found;\n                        for(var j = 0; j < l; j++){\n                            if (enumer[j] === value) {\n                                found = 1;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            addError(\"does not have a value in the enumeration \" + enumer.join(\", \"));\n                        }\n                    }\n                    if (typeof schema.maxDecimal == \"number\" && value.toString().match(new RegExp(\"\\\\.[0-9]{\" + (schema.maxDecimal + 1) + \",}\"))) {\n                        addError(\"may only have \" + schema.maxDecimal + \" digits of decimal places\");\n                    }\n                }\n            }\n            return null;\n        }\n        // validate an object against a schema\n        function checkObj(instance, objTypeDef, path, additionalProp) {\n            if (typeof objTypeDef == \"object\") {\n                if (typeof instance != \"object\" || instance instanceof Array) {\n                    errors.push({\n                        property: path,\n                        message: \"an object is required\"\n                    });\n                }\n                for(var i in objTypeDef){\n                    if (objTypeDef.hasOwnProperty(i) && i != \"__proto__\" && i != \"constructor\") {\n                        var value = instance.hasOwnProperty(i) ? instance[i] : undefined;\n                        // skip _not_ specified properties\n                        if (value === undefined && options.existingOnly) continue;\n                        var propDef = objTypeDef[i];\n                        // set default\n                        if (value === undefined && propDef[\"default\"]) {\n                            value = instance[i] = propDef[\"default\"];\n                        }\n                        if (options.coerce && i in instance) {\n                            value = instance[i] = options.coerce(value, propDef);\n                        }\n                        checkProp(value, propDef, path, i);\n                    }\n                }\n            }\n            for(i in instance){\n                if (instance.hasOwnProperty(i) && !(i.charAt(0) == \"_\" && i.charAt(1) == \"_\") && objTypeDef && !objTypeDef[i] && additionalProp === false) {\n                    if (options.filter) {\n                        delete instance[i];\n                        continue;\n                    } else {\n                        errors.push({\n                            property: path,\n                            message: \"The property \" + i + \" is not defined in the schema and the schema does not allow additional properties\"\n                        });\n                    }\n                }\n                var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;\n                if (requires && !(requires in instance)) {\n                    errors.push({\n                        property: path,\n                        message: \"the presence of the property \" + i + \" requires that \" + requires + \" also be present\"\n                    });\n                }\n                value = instance[i];\n                if (additionalProp && (!(objTypeDef && typeof objTypeDef == \"object\") || !(i in objTypeDef))) {\n                    if (options.coerce) {\n                        value = instance[i] = options.coerce(value, additionalProp);\n                    }\n                    checkProp(value, additionalProp, path, i);\n                }\n                if (!_changing && value && value.$schema) {\n                    errors = errors.concat(checkProp(value, value.$schema, path, i));\n                }\n            }\n            return errors;\n        }\n        if (schema) {\n            checkProp(instance, schema, \"\", _changing || \"\");\n        }\n        if (!_changing && instance && instance.$schema) {\n            checkProp(instance, instance.$schema, \"\", \"\");\n        }\n        return {\n            valid: !errors.length,\n            errors: errors\n        };\n    };\n    exports.mustBeValid = function(result) {\n        //\tsummary:\n        //\t\tThis checks to ensure that the result is valid and will throw an appropriate error message if it is not\n        // result: the result returned from checkPropertyChange or validate\n        if (!result.valid) {\n            throw new TypeError(result.errors.map(function(error) {\n                return \"for property \" + error.property + \": \" + error.message;\n            }).join(\", \\n\"));\n        }\n    };\n    return exports;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEvbGliL3ZhbGlkYXRlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDQSxVQUFVQSxJQUFJLEVBQUVDLE9BQU87SUFDcEIsSUFBSSxJQUEwQyxFQUFFO1FBQzVDLHdDQUF3QztRQUN4Q0MsaUNBQU8sRUFBRSxtQ0FBRTtZQUNQLE9BQU9EO1FBQ1gsQ0FBQztBQUFBLGtHQUFDO0lBQ04sT0FBTyxFQVFOO0FBQ0wsR0FBRSxRQUFNO0lBQ1IsSUFBSUksVUFBVUU7SUFDZEYsUUFBUUcsT0FBTyxHQUFHO1FBQUNDLE1BQUs7SUFBUztJQUNqQyxJQUFJQyx3QkFBd0I7UUFDM0JDLFFBQVFBO1FBQ1JDLFNBQVNBO1FBQ1RDLFFBQVFBO1FBQ1JDLFFBQVFBO1FBQ1JDLE9BQU9BO1FBQ1BDLE1BQU1BO0lBQ1A7SUFDQVgsUUFBUUUsUUFBUSxHQUFHQTtJQUNuQixTQUFTQSxTQUFTLEtBQUssR0FBRVUsUUFBUSxFQUFDLFFBQVEsR0FBRUMsTUFBTTtRQUNoRCxXQUFXO1FBQ1gseUdBQXlHO1FBQ3pHLHVIQUF1SDtRQUN2SCxtR0FBbUc7UUFDbkcsa0NBQWtDO1FBQ2xDLG1FQUFtRTtRQUNuRSx3RUFBd0U7UUFDeEUsNEVBQTRFO1FBQzVFLGlGQUFpRjtRQUNqRiwrREFBK0Q7UUFDL0Qsb0RBQW9EO1FBQ3BELEVBQUU7UUFDRixPQUFPWCxTQUFTVSxVQUFVQyxRQUFRO1lBQUNDLFVBQVU7UUFBSyxJQUFHLHlDQUF5QztJQUMvRjs7SUFDRGQsUUFBUWUsbUJBQW1CLEdBQUcsU0FBUyxLQUFLLEdBQUVDLEtBQUssRUFBQyxRQUFRLEdBQUVILE1BQU0sRUFBRSxRQUFRLEdBQUVJLFFBQVE7UUFDdEYsV0FBVztRQUNYLGtIQUFrSDtRQUNsSCxtSEFBbUg7UUFDbkgsdUdBQXVHO1FBQ3ZHLDZHQUE2RztRQUM3RyxpQkFBaUI7UUFDakIsRUFBRTtRQUNGLE9BQU9mLFNBQVNjLE9BQU9ILFFBQVE7WUFBQ0MsVUFBVUcsWUFBWTtRQUFVO0lBQ2pFO0lBQ0QsSUFBSWYsV0FBV0YsUUFBUWtCLFNBQVMsR0FBRyxTQUFTLEtBQUssR0FBRU4sUUFBUSxFQUFDLFFBQVEsR0FBRUMsTUFBTSxFQUFDLFFBQVEsR0FBRU0sT0FBTztRQUU3RixJQUFJLENBQUNBLFNBQVNBLFVBQVUsQ0FBQztRQUN6QixJQUFJQyxZQUFZRCxRQUFRTCxRQUFRO1FBRWhDLFNBQVNPLFFBQVFSLE1BQU07WUFDdEIsT0FBT0EsT0FBT1QsSUFBSSxJQUFLQyxxQkFBcUIsQ0FBQ1EsT0FBT1MsSUFBSSxDQUFDLElBQUlULFVBQVVBLE9BQU9TLElBQUksQ0FBQ0MsV0FBVztRQUMvRjtRQUNBLElBQUlDLFNBQVMsRUFBRTtRQUNmLGlEQUFpRDtRQUNqRCxTQUFTQyxVQUFVVCxLQUFLLEVBQUVILE1BQU0sRUFBRWEsSUFBSSxFQUFDQyxDQUFDO1lBRXZDLElBQUlDO1lBQ0pGLFFBQVFBLE9BQU8sT0FBT0MsS0FBSyxXQUFXLE1BQU1BLElBQUksTUFBTSxPQUFPQSxLQUFLLGNBQWMsS0FBSyxNQUFNQSxJQUFJQTtZQUMvRixTQUFTRSxTQUFTQyxPQUFPO2dCQUN4Qk4sT0FBT08sSUFBSSxDQUFDO29CQUFDZCxVQUFTUztvQkFBS0ksU0FBUUE7Z0JBQU87WUFDM0M7WUFFQSxJQUFHLENBQUMsT0FBT2pCLFVBQVUsWUFBWUEsa0JBQWtCSCxLQUFJLEtBQU9nQixDQUFBQSxRQUFRLE9BQU9iLFVBQVUsVUFBUyxLQUFNLENBQUVBLENBQUFBLFVBQVVRLFFBQVFSLE9BQU0sR0FBRztnQkFDbEksSUFBRyxPQUFPQSxVQUFVLFlBQVc7b0JBQzlCLElBQUcsQ0FBRUcsQ0FBQUEsaUJBQWlCSCxNQUFLLEdBQUc7d0JBQzdCZ0IsU0FBUyxpREFBaURoQixPQUFPUyxJQUFJO29CQUN0RTtnQkFDRCxPQUFNLElBQUdULFFBQU87b0JBQ2ZnQixTQUFTLHdDQUF3Q2hCO2dCQUNsRDtnQkFDQSxPQUFPO1lBQ1I7WUFDQSxJQUFHTyxhQUFhUCxPQUFPbUIsUUFBUSxFQUFDO2dCQUMvQkgsU0FBUztZQUNWO1lBQ0EsSUFBR2hCLE1BQU0sQ0FBQyxVQUFVLEVBQUM7Z0JBQ3BCWSxVQUFVVCxPQUFNSCxNQUFNLENBQUMsVUFBVSxFQUFDYSxNQUFLQztZQUN4QztZQUNBLDZDQUE2QztZQUM3QyxTQUFTTSxVQUFVN0IsSUFBSSxFQUFDWSxLQUFLO2dCQUM1QixJQUFHWixNQUFLO29CQUNQLElBQUcsT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFNBQ25DQSxDQUFBQSxRQUFRLFNBQVNZLFVBQVUsT0FBTyxPQUFPQSxTQUFTWixJQUFHLEtBQ3RELENBQUVZLENBQUFBLGlCQUFpQk4sU0FBU04sUUFBUSxPQUFNLEtBQzFDLENBQUVZLENBQUFBLGlCQUFpQkwsUUFBUVAsUUFBUSxNQUFLLEtBQ3hDLENBQUVBLENBQUFBLFFBQVEsYUFBYVksUUFBTSxNQUFJLElBQUc7d0JBQ3JDLE9BQU87NEJBQUM7Z0NBQUNDLFVBQVNTO2dDQUFLSSxTQUFRZCxRQUFRLFFBQVMsT0FBT0EsUUFBUyx5QkFBeUJaLE9BQU87NEJBQWM7eUJBQUU7b0JBQ2pIO29CQUNBLElBQUdBLGdCQUFnQk0sT0FBTTt3QkFDeEIsSUFBSXdCLGNBQVksRUFBRTt3QkFDbEIsSUFBSSxJQUFJQyxJQUFJLEdBQUdBLElBQUkvQixLQUFLZ0MsTUFBTSxFQUFFRCxJQUFJOzRCQUNuQyxJQUFHLENBQUMsQ0FBQ0QsY0FBWUQsVUFBVTdCLElBQUksQ0FBQytCLEVBQUUsRUFBQ25CLE1BQUssRUFBR29CLE1BQU0sRUFBQztnQ0FDakQ7NEJBQ0Q7d0JBQ0Q7d0JBQ0EsSUFBR0YsWUFBWUUsTUFBTSxFQUFDOzRCQUNyQixPQUFPRjt3QkFDUjtvQkFDRCxPQUFNLElBQUcsT0FBTzlCLFFBQVEsVUFBUzt3QkFDaEMsSUFBSWlDLGNBQWNiO3dCQUNsQkEsU0FBUyxFQUFFO3dCQUNYQyxVQUFVVCxPQUFNWixNQUFLc0I7d0JBQ3JCLElBQUlZLGNBQWNkO3dCQUNsQkEsU0FBU2E7d0JBQ1QsT0FBT0M7b0JBQ1I7Z0JBQ0Q7Z0JBQ0EsT0FBTyxFQUFFO1lBQ1Y7WUFDQSxJQUFHdEIsVUFBVXVCLFdBQVU7Z0JBQ3RCLElBQUcxQixPQUFPMkIsUUFBUSxFQUFDO29CQUNsQlgsU0FBUztnQkFDVjtZQUNELE9BQUs7Z0JBQ0pMLFNBQVNBLE9BQU9pQixNQUFNLENBQUNSLFVBQVVaLFFBQVFSLFNBQVFHO2dCQUNqRCxJQUFHSCxPQUFPNkIsUUFBUSxJQUFJLENBQUNULFVBQVVwQixPQUFPNkIsUUFBUSxFQUFDMUIsT0FBT29CLE1BQU0sRUFBQztvQkFDOURQLFNBQVM7Z0JBQ1Y7Z0JBQ0EsSUFBR2IsVUFBVSxNQUFLO29CQUNqQixJQUFHQSxpQkFBaUJOLE9BQU07d0JBQ3pCLElBQUdHLE9BQU84QixLQUFLLEVBQUM7NEJBQ2YsSUFBSUMsZUFBZS9CLE9BQU84QixLQUFLLFlBQVlqQzs0QkFDM0MsSUFBSW1DLFVBQVVoQyxPQUFPOEIsS0FBSzs0QkFDMUIsSUFBS2hCLElBQUksR0FBR0MsSUFBSVosTUFBTW9CLE1BQU0sRUFBRVQsSUFBSUMsR0FBR0QsS0FBSyxFQUFHO2dDQUM1QyxJQUFJaUIsY0FDSEMsVUFBVWhDLE9BQU84QixLQUFLLENBQUNoQixFQUFFO2dDQUMxQixJQUFJUixRQUFRMkIsTUFBTSxFQUNqQjlCLEtBQUssQ0FBQ1csRUFBRSxHQUFHUixRQUFRMkIsTUFBTSxDQUFDOUIsS0FBSyxDQUFDVyxFQUFFLEVBQUVrQjtnQ0FDckNyQixPQUFPaUIsTUFBTSxDQUFDaEIsVUFBVVQsS0FBSyxDQUFDVyxFQUFFLEVBQUNrQixTQUFRbkIsTUFBS0M7NEJBQy9DO3dCQUNEO3dCQUNBLElBQUdkLE9BQU9rQyxRQUFRLElBQUkvQixNQUFNb0IsTUFBTSxHQUFHdkIsT0FBT2tDLFFBQVEsRUFBQzs0QkFDcERsQixTQUFTLGdDQUFnQ2hCLE9BQU9rQyxRQUFRLEdBQUc7d0JBQzVEO3dCQUNBLElBQUdsQyxPQUFPbUMsUUFBUSxJQUFJaEMsTUFBTW9CLE1BQU0sR0FBR3ZCLE9BQU9tQyxRQUFRLEVBQUM7NEJBQ3BEbkIsU0FBUyxnQ0FBZ0NoQixPQUFPbUMsUUFBUSxHQUFHO3dCQUM1RDtvQkFDRCxPQUFNLElBQUduQyxPQUFPb0MsVUFBVSxJQUFJcEMsT0FBT3FDLG9CQUFvQixFQUFDO3dCQUN6RDFCLE9BQU9pQixNQUFNLENBQUNVLFNBQVNuQyxPQUFPSCxPQUFPb0MsVUFBVSxFQUFFdkIsTUFBTWIsT0FBT3FDLG9CQUFvQjtvQkFDbkY7b0JBQ0EsSUFBR3JDLE9BQU91QyxPQUFPLElBQUksT0FBT3BDLFNBQVMsWUFBWSxDQUFDQSxNQUFNcUMsS0FBSyxDQUFDeEMsT0FBT3VDLE9BQU8sR0FBRTt3QkFDN0V2QixTQUFTLHNDQUFzQ2hCLE9BQU91QyxPQUFPO29CQUM5RDtvQkFDQSxJQUFHdkMsT0FBT3lDLFNBQVMsSUFBSSxPQUFPdEMsU0FBUyxZQUFZQSxNQUFNb0IsTUFBTSxHQUFHdkIsT0FBT3lDLFNBQVMsRUFBQzt3QkFDbEZ6QixTQUFTLGlCQUFpQmhCLE9BQU95QyxTQUFTLEdBQUc7b0JBQzlDO29CQUNBLElBQUd6QyxPQUFPMEMsU0FBUyxJQUFJLE9BQU92QyxTQUFTLFlBQVlBLE1BQU1vQixNQUFNLEdBQUd2QixPQUFPMEMsU0FBUyxFQUFDO3dCQUNsRjFCLFNBQVMsc0JBQXNCaEIsT0FBTzBDLFNBQVMsR0FBRztvQkFDbkQ7b0JBQ0EsSUFBRyxPQUFPMUMsT0FBTzJDLE9BQU8sS0FBSyxlQUFlLE9BQU94QyxTQUFTLE9BQU9ILE9BQU8yQyxPQUFPLElBQy9FM0MsT0FBTzJDLE9BQU8sR0FBR3hDLE9BQU07d0JBQ3hCYSxTQUFTLGtDQUFrQ2hCLE9BQU8yQyxPQUFPO29CQUMxRDtvQkFDQSxJQUFHLE9BQU8zQyxPQUFPNEMsT0FBTyxLQUFLLGVBQWUsT0FBT3pDLFNBQVMsT0FBT0gsT0FBTzRDLE9BQU8sSUFDL0U1QyxPQUFPNEMsT0FBTyxHQUFHekMsT0FBTTt3QkFDeEJhLFNBQVMsa0NBQWtDaEIsT0FBTzRDLE9BQU87b0JBQzFEO29CQUNBLElBQUc1QyxNQUFNLENBQUMsT0FBTyxFQUFDO3dCQUNqQixJQUFJNkMsU0FBUzdDLE1BQU0sQ0FBQyxPQUFPO3dCQUMzQmUsSUFBSThCLE9BQU90QixNQUFNO3dCQUNqQixJQUFJdUI7d0JBQ0osSUFBSSxJQUFJeEIsSUFBSSxHQUFHQSxJQUFJUCxHQUFHTyxJQUFJOzRCQUN6QixJQUFHdUIsTUFBTSxDQUFDdkIsRUFBRSxLQUFHbkIsT0FBTTtnQ0FDcEIyQyxRQUFNO2dDQUNOOzRCQUNEO3dCQUNEO3dCQUNBLElBQUcsQ0FBQ0EsT0FBTTs0QkFDVDlCLFNBQVMsOENBQThDNkIsT0FBT0UsSUFBSSxDQUFDO3dCQUNwRTtvQkFDRDtvQkFDQSxJQUFHLE9BQU8vQyxPQUFPZ0QsVUFBVSxJQUFJLFlBQzdCN0MsTUFBTThDLFFBQVEsR0FBR1QsS0FBSyxDQUFDLElBQUlVLE9BQU8sY0FBZWxELENBQUFBLE9BQU9nRCxVQUFVLEdBQUcsS0FBSyxRQUFRO3dCQUNuRmhDLFNBQVMsbUJBQW1CaEIsT0FBT2dELFVBQVUsR0FBRztvQkFDakQ7Z0JBQ0Q7WUFDRDtZQUNBLE9BQU87UUFDUjtRQUNBLHNDQUFzQztRQUN0QyxTQUFTVixTQUFTdkMsUUFBUSxFQUFDb0QsVUFBVSxFQUFDdEMsSUFBSSxFQUFDdUMsY0FBYztZQUV4RCxJQUFHLE9BQU9ELGNBQWEsVUFBUztnQkFDL0IsSUFBRyxPQUFPcEQsWUFBWSxZQUFZQSxvQkFBb0JGLE9BQU07b0JBQzNEYyxPQUFPTyxJQUFJLENBQUM7d0JBQUNkLFVBQVNTO3dCQUFLSSxTQUFRO29CQUF1QjtnQkFDM0Q7Z0JBRUEsSUFBSSxJQUFJSCxLQUFLcUMsV0FBVztvQkFDdkIsSUFBR0EsV0FBV0UsY0FBYyxDQUFDdkMsTUFBTUEsS0FBSyxlQUFlQSxLQUFLLGVBQWM7d0JBQ3pFLElBQUlYLFFBQVFKLFNBQVNzRCxjQUFjLENBQUN2QyxLQUFLZixRQUFRLENBQUNlLEVBQUUsR0FBR1k7d0JBQ3ZELGtDQUFrQzt3QkFDbEMsSUFBSXZCLFVBQVV1QixhQUFhcEIsUUFBUWdELFlBQVksRUFBRTt3QkFDakQsSUFBSXRCLFVBQVVtQixVQUFVLENBQUNyQyxFQUFFO3dCQUMzQixjQUFjO3dCQUNkLElBQUdYLFVBQVV1QixhQUFhTSxPQUFPLENBQUMsVUFBVSxFQUFDOzRCQUM1QzdCLFFBQVFKLFFBQVEsQ0FBQ2UsRUFBRSxHQUFHa0IsT0FBTyxDQUFDLFVBQVU7d0JBQ3pDO3dCQUNBLElBQUcxQixRQUFRMkIsTUFBTSxJQUFJbkIsS0FBS2YsVUFBUzs0QkFDbENJLFFBQVFKLFFBQVEsQ0FBQ2UsRUFBRSxHQUFHUixRQUFRMkIsTUFBTSxDQUFDOUIsT0FBTzZCO3dCQUM3Qzt3QkFDQXBCLFVBQVVULE9BQU02QixTQUFRbkIsTUFBS0M7b0JBQzlCO2dCQUNEO1lBQ0Q7WUFDQSxJQUFJQSxLQUFLZixTQUFTO2dCQUNqQixJQUFHQSxTQUFTc0QsY0FBYyxDQUFDdkMsTUFBTSxDQUFFQSxDQUFBQSxFQUFFeUMsTUFBTSxDQUFDLE1BQU0sT0FBT3pDLEVBQUV5QyxNQUFNLENBQUMsTUFBTSxHQUFFLEtBQU1KLGNBQWMsQ0FBQ0EsVUFBVSxDQUFDckMsRUFBRSxJQUFJc0MsbUJBQWlCLE9BQU07b0JBQ3RJLElBQUk5QyxRQUFRa0QsTUFBTSxFQUFFO3dCQUNuQixPQUFPekQsUUFBUSxDQUFDZSxFQUFFO3dCQUNsQjtvQkFDRCxPQUFPO3dCQUNOSCxPQUFPTyxJQUFJLENBQUM7NEJBQUNkLFVBQVNTOzRCQUFLSSxTQUFRLGtCQUFrQkgsSUFDcEQ7d0JBQW1GO29CQUNyRjtnQkFDRDtnQkFDQSxJQUFJMkMsV0FBV04sY0FBY0EsVUFBVSxDQUFDckMsRUFBRSxJQUFJcUMsVUFBVSxDQUFDckMsRUFBRSxDQUFDMkMsUUFBUTtnQkFDcEUsSUFBR0EsWUFBWSxDQUFFQSxDQUFBQSxZQUFZMUQsUUFBTyxHQUFHO29CQUN0Q1ksT0FBT08sSUFBSSxDQUFDO3dCQUFDZCxVQUFTUzt3QkFBS0ksU0FBUSxrQ0FBa0NILElBQUksb0JBQW9CMkMsV0FBVztvQkFBa0I7Z0JBQzNIO2dCQUNBdEQsUUFBUUosUUFBUSxDQUFDZSxFQUFFO2dCQUNuQixJQUFHc0Msa0JBQW1CLEVBQUVELENBQUFBLGNBQWMsT0FBT0EsY0FBYyxRQUFPLEtBQU0sQ0FBRXJDLENBQUFBLEtBQUtxQyxVQUFTLENBQUMsR0FBRztvQkFDM0YsSUFBRzdDLFFBQVEyQixNQUFNLEVBQUM7d0JBQ2pCOUIsUUFBUUosUUFBUSxDQUFDZSxFQUFFLEdBQUdSLFFBQVEyQixNQUFNLENBQUM5QixPQUFPaUQ7b0JBQzdDO29CQUNBeEMsVUFBVVQsT0FBTWlELGdCQUFldkMsTUFBS0M7Z0JBQ3JDO2dCQUNBLElBQUcsQ0FBQ1AsYUFBYUosU0FBU0EsTUFBTXVELE9BQU8sRUFBQztvQkFDdkMvQyxTQUFTQSxPQUFPaUIsTUFBTSxDQUFDaEIsVUFBVVQsT0FBTUEsTUFBTXVELE9BQU8sRUFBQzdDLE1BQUtDO2dCQUMzRDtZQUNEO1lBQ0EsT0FBT0g7UUFDUjtRQUNBLElBQUdYLFFBQU87WUFDVFksVUFBVWIsVUFBU0MsUUFBTyxJQUFHTyxhQUFhO1FBQzNDO1FBQ0EsSUFBRyxDQUFDQSxhQUFhUixZQUFZQSxTQUFTMkQsT0FBTyxFQUFDO1lBQzdDOUMsVUFBVWIsVUFBU0EsU0FBUzJELE9BQU8sRUFBQyxJQUFHO1FBQ3hDO1FBQ0EsT0FBTztZQUFDQyxPQUFNLENBQUNoRCxPQUFPWSxNQUFNO1lBQUNaLFFBQU9BO1FBQU07SUFDM0M7SUFDQXhCLFFBQVF5RSxXQUFXLEdBQUcsU0FBU0MsTUFBTTtRQUNwQyxXQUFXO1FBQ1gsMkdBQTJHO1FBQzNHLG1FQUFtRTtRQUNuRSxJQUFHLENBQUNBLE9BQU9GLEtBQUssRUFBQztZQUNoQixNQUFNLElBQUlHLFVBQVVELE9BQU9sRCxNQUFNLENBQUNvRCxHQUFHLENBQUMsU0FBU0MsS0FBSztnQkFBRSxPQUFPLGtCQUFrQkEsTUFBTTVELFFBQVEsR0FBRyxPQUFPNEQsTUFBTS9DLE9BQU87WUFBQyxHQUFHOEIsSUFBSSxDQUFDO1FBQzlIO0lBQ0Q7SUFFQSxPQUFPNUQ7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hL2xpYi92YWxpZGF0ZS5qcz81YTJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBKU09OU2NoZW1hIFZhbGlkYXRvciAtIFZhbGlkYXRlcyBKYXZhU2NyaXB0IG9iamVjdHMgdXNpbmcgSlNPTiBTY2hlbWFzXHJcbiAqXHQoaHR0cDovL3d3dy5qc29uLmNvbS9qc29uLXNjaGVtYS1wcm9wb3NhbC8pXHJcbiAqIExpY2Vuc2VkIHVuZGVyIEFGTC0yLjEgT1IgQlNELTMtQ2xhdXNlXHJcblRvIHVzZSB0aGUgdmFsaWRhdG9yIGNhbGwgdGhlIHZhbGlkYXRlIGZ1bmN0aW9uIHdpdGggYW4gaW5zdGFuY2Ugb2JqZWN0IGFuZCBhbiBvcHRpb25hbCBzY2hlbWEgb2JqZWN0LlxyXG5JZiBhIHNjaGVtYSBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlLiBJZiB0aGUgaW5zdGFuY2Ugb2JqZWN0IHJlZmVycyB0byBhIHNjaGVtYSAoc2VsZi12YWxpZGF0aW5nKSxcclxudGhhdCBzY2hlbWEgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0aGUgc2NoZW1hIHBhcmFtZXRlciBpcyBub3QgbmVjZXNzYXJ5IChpZiBib3RoIGV4aXN0LFxyXG5ib3RoIHZhbGlkYXRpb25zIHdpbGwgb2NjdXIpLlxyXG5UaGUgdmFsaWRhdGUgbWV0aG9kIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzLiBJZiB0aGVyZSBhcmUgbm8gZXJyb3JzLCB0aGVuIGFuXHJcbmVtcHR5IGxpc3Qgd2lsbCBiZSByZXR1cm5lZC4gQSB2YWxpZGF0aW9uIGVycm9yIHdpbGwgaGF2ZSB0d28gcHJvcGVydGllczpcclxuXCJwcm9wZXJ0eVwiIHdoaWNoIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0eSBoYWQgdGhlIGVycm9yXHJcblwibWVzc2FnZVwiIHdoaWNoIGluZGljYXRlcyB3aGF0IHRoZSBlcnJvciB3YXNcclxuICovXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcclxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcclxuICAgICAgICAvLyBsaWtlIE5vZGUuXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xyXG4gICAgICAgIHJvb3QuanNvblNjaGVtYSA9IGZhY3RvcnkoKTtcclxuICAgIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7Ly8gc2V0dXAgcHJpbWl0aXZlIGNsYXNzZXMgdG8gYmUgSlNPTiBTY2hlbWEgdHlwZXNcclxudmFyIGV4cG9ydHMgPSB2YWxpZGF0ZVxyXG5leHBvcnRzLkludGVnZXIgPSB7dHlwZTpcImludGVnZXJcIn07XHJcbnZhciBwcmltaXRpdmVDb25zdHJ1Y3RvcnMgPSB7XHJcblx0U3RyaW5nOiBTdHJpbmcsXHJcblx0Qm9vbGVhbjogQm9vbGVhbixcclxuXHROdW1iZXI6IE51bWJlcixcclxuXHRPYmplY3Q6IE9iamVjdCxcclxuXHRBcnJheTogQXJyYXksXHJcblx0RGF0ZTogRGF0ZVxyXG59XHJcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcclxuZnVuY3Rpb24gdmFsaWRhdGUoLypBbnkqL2luc3RhbmNlLC8qT2JqZWN0Ki9zY2hlbWEpIHtcclxuXHRcdC8vIFN1bW1hcnk6XHJcblx0XHQvLyAgXHRUbyB1c2UgdGhlIHZhbGlkYXRvciBjYWxsIEpTT05TY2hlbWEudmFsaWRhdGUgd2l0aCBhbiBpbnN0YW5jZSBvYmplY3QgYW5kIGFuIG9wdGlvbmFsIHNjaGVtYSBvYmplY3QuXHJcblx0XHQvLyBcdFx0SWYgYSBzY2hlbWEgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZS4gSWYgdGhlIGluc3RhbmNlIG9iamVjdCByZWZlcnMgdG8gYSBzY2hlbWEgKHNlbGYtdmFsaWRhdGluZyksXHJcblx0XHQvLyBcdFx0dGhhdCBzY2hlbWEgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0aGUgc2NoZW1hIHBhcmFtZXRlciBpcyBub3QgbmVjZXNzYXJ5IChpZiBib3RoIGV4aXN0LFxyXG5cdFx0Ly8gXHRcdGJvdGggdmFsaWRhdGlvbnMgd2lsbCBvY2N1cikuXHJcblx0XHQvLyBcdFx0VGhlIHZhbGlkYXRlIG1ldGhvZCB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczpcclxuXHRcdC8vIFx0XHRcdHZhbGlkOiBBIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgaW5zdGFuY2UgaXMgdmFsaWQgYnkgdGhlIHNjaGVtYVxyXG5cdFx0Ly8gXHRcdFx0ZXJyb3JzOiBBbiBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9ycy4gSWYgdGhlcmUgYXJlIG5vIGVycm9ycywgdGhlbiBhblxyXG5cdFx0Ly8gXHRcdFx0XHRcdGVtcHR5IGxpc3Qgd2lsbCBiZSByZXR1cm5lZC4gQSB2YWxpZGF0aW9uIGVycm9yIHdpbGwgaGF2ZSB0d28gcHJvcGVydGllczpcclxuXHRcdC8vIFx0XHRcdFx0XHRcdHByb3BlcnR5OiB3aGljaCBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydHkgaGFkIHRoZSBlcnJvclxyXG5cdFx0Ly8gXHRcdFx0XHRcdFx0bWVzc2FnZTogd2hpY2ggaW5kaWNhdGVzIHdoYXQgdGhlIGVycm9yIHdhc1xyXG5cdFx0Ly9cclxuXHRcdHJldHVybiB2YWxpZGF0ZShpbnN0YW5jZSwgc2NoZW1hLCB7Y2hhbmdpbmc6IGZhbHNlfSk7Ly8sIGNvZXJjZTogZmFsc2UsIGV4aXN0aW5nT25seTogZmFsc2V9KTtcclxuXHR9O1xyXG5leHBvcnRzLmNoZWNrUHJvcGVydHlDaGFuZ2UgPSBmdW5jdGlvbigvKkFueSovdmFsdWUsLypPYmplY3QqL3NjaGVtYSwgLypTdHJpbmcqL3Byb3BlcnR5KSB7XHJcblx0XHQvLyBTdW1tYXJ5OlxyXG5cdFx0Ly8gXHRcdFRoZSBjaGVja1Byb3BlcnR5Q2hhbmdlIG1ldGhvZCB3aWxsIGNoZWNrIHRvIHNlZSBpZiBhbiB2YWx1ZSBjYW4gbGVnYWxseSBiZSBpbiBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBzY2hlbWFcclxuXHRcdC8vIFx0XHRUaGlzIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIHRoZSB2YWxpZGF0ZSBtZXRob2QgaW4gdGhhdCBpdCB3aWxsIGZhaWwgaWYgdGhlIHNjaGVtYSBpcyByZWFkb25seSBhbmQgaXQgd2lsbFxyXG5cdFx0Ly8gXHRcdG5vdCBjaGVjayBmb3Igc2VsZi12YWxpZGF0aW9uLCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHBhc3NlZCBpbiB2YWx1ZSBpcyBhbHJlYWR5IGludGVybmFsbHkgdmFsaWQuXHJcblx0XHQvLyBcdFx0VGhlIGNoZWNrUHJvcGVydHlDaGFuZ2UgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lIG9iamVjdCB0eXBlIGFzIHZhbGlkYXRlLCBzZWUgSlNPTlNjaGVtYS52YWxpZGF0ZSBmb3JcclxuXHRcdC8vIFx0XHRpbmZvcm1hdGlvbi5cclxuXHRcdC8vXHJcblx0XHRyZXR1cm4gdmFsaWRhdGUodmFsdWUsIHNjaGVtYSwge2NoYW5naW5nOiBwcm9wZXJ0eSB8fCBcInByb3BlcnR5XCJ9KTtcclxuXHR9O1xyXG52YXIgdmFsaWRhdGUgPSBleHBvcnRzLl92YWxpZGF0ZSA9IGZ1bmN0aW9uKC8qQW55Ki9pbnN0YW5jZSwvKk9iamVjdCovc2NoZW1hLC8qT2JqZWN0Ki9vcHRpb25zKSB7XHJcblxyXG5cdGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG5cdHZhciBfY2hhbmdpbmcgPSBvcHRpb25zLmNoYW5naW5nO1xyXG5cclxuXHRmdW5jdGlvbiBnZXRUeXBlKHNjaGVtYSl7XHJcblx0XHRyZXR1cm4gc2NoZW1hLnR5cGUgfHwgKHByaW1pdGl2ZUNvbnN0cnVjdG9yc1tzY2hlbWEubmFtZV0gPT0gc2NoZW1hICYmIHNjaGVtYS5uYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG5cdH1cclxuXHR2YXIgZXJyb3JzID0gW107XHJcblx0Ly8gdmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgcHJvcGVydHkgZGVmaW5pdGlvblxyXG5cdGZ1bmN0aW9uIGNoZWNrUHJvcCh2YWx1ZSwgc2NoZW1hLCBwYXRoLGkpe1xyXG5cclxuXHRcdHZhciBsO1xyXG5cdFx0cGF0aCArPSBwYXRoID8gdHlwZW9mIGkgPT0gJ251bWJlcicgPyAnWycgKyBpICsgJ10nIDogdHlwZW9mIGkgPT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICcuJyArIGkgOiBpO1xyXG5cdFx0ZnVuY3Rpb24gYWRkRXJyb3IobWVzc2FnZSl7XHJcblx0XHRcdGVycm9ycy5wdXNoKHtwcm9wZXJ0eTpwYXRoLG1lc3NhZ2U6bWVzc2FnZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCh0eXBlb2Ygc2NoZW1hICE9ICdvYmplY3QnIHx8IHNjaGVtYSBpbnN0YW5jZW9mIEFycmF5KSAmJiAocGF0aCB8fCB0eXBlb2Ygc2NoZW1hICE9ICdmdW5jdGlvbicpICYmICEoc2NoZW1hICYmIGdldFR5cGUoc2NoZW1hKSkpe1xyXG5cdFx0XHRpZih0eXBlb2Ygc2NoZW1hID09ICdmdW5jdGlvbicpe1xyXG5cdFx0XHRcdGlmKCEodmFsdWUgaW5zdGFuY2VvZiBzY2hlbWEpKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwiaXMgbm90IGFuIGluc3RhbmNlIG9mIHRoZSBjbGFzcy9jb25zdHJ1Y3RvciBcIiArIHNjaGVtYS5uYW1lKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKHNjaGVtYSl7XHJcblx0XHRcdFx0YWRkRXJyb3IoXCJJbnZhbGlkIHNjaGVtYS9wcm9wZXJ0eSBkZWZpbml0aW9uIFwiICsgc2NoZW1hKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdGlmKF9jaGFuZ2luZyAmJiBzY2hlbWEucmVhZG9ubHkpe1xyXG5cdFx0XHRhZGRFcnJvcihcImlzIGEgcmVhZG9ubHkgZmllbGQsIGl0IGNhbiBub3QgYmUgY2hhbmdlZFwiKTtcclxuXHRcdH1cclxuXHRcdGlmKHNjaGVtYVsnZXh0ZW5kcyddKXsgLy8gaWYgaXQgZXh0ZW5kcyBhbm90aGVyIHNjaGVtYSwgaXQgbXVzdCBwYXNzIHRoYXQgc2NoZW1hIGFzIHdlbGxcclxuXHRcdFx0Y2hlY2tQcm9wKHZhbHVlLHNjaGVtYVsnZXh0ZW5kcyddLHBhdGgsaSk7XHJcblx0XHR9XHJcblx0XHQvLyB2YWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSB0eXBlIGRlZmluaXRpb25cclxuXHRcdGZ1bmN0aW9uIGNoZWNrVHlwZSh0eXBlLHZhbHVlKXtcclxuXHRcdFx0aWYodHlwZSl7XHJcblx0XHRcdFx0aWYodHlwZW9mIHR5cGUgPT0gJ3N0cmluZycgJiYgdHlwZSAhPSAnYW55JyAmJlxyXG5cdFx0XHRcdFx0XHQodHlwZSA9PSAnbnVsbCcgPyB2YWx1ZSAhPT0gbnVsbCA6IHR5cGVvZiB2YWx1ZSAhPSB0eXBlKSAmJlxyXG5cdFx0XHRcdFx0XHQhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdHlwZSA9PSAnYXJyYXknKSAmJlxyXG5cdFx0XHRcdFx0XHQhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiB0eXBlID09ICdkYXRlJykgJiZcclxuXHRcdFx0XHRcdFx0ISh0eXBlID09ICdpbnRlZ2VyJyAmJiB2YWx1ZSUxPT09MCkpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIFt7cHJvcGVydHk6cGF0aCxtZXNzYWdlOnZhbHVlICsgXCIgLSBcIiArICh0eXBlb2YgdmFsdWUpICsgXCIgdmFsdWUgZm91bmQsIGJ1dCBhIFwiICsgdHlwZSArIFwiIGlzIHJlcXVpcmVkXCJ9XTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZSBpbnN0YW5jZW9mIEFycmF5KXtcclxuXHRcdFx0XHRcdHZhciB1bmlvbkVycm9ycz1bXTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCB0eXBlLmxlbmd0aDsgaisrKXsgLy8gYSB1bmlvbiB0eXBlXHJcblx0XHRcdFx0XHRcdGlmKCEodW5pb25FcnJvcnM9Y2hlY2tUeXBlKHR5cGVbal0sdmFsdWUpKS5sZW5ndGgpe1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZih1bmlvbkVycm9ycy5sZW5ndGgpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5pb25FcnJvcnM7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fWVsc2UgaWYodHlwZW9mIHR5cGUgPT0gJ29iamVjdCcpe1xyXG5cdFx0XHRcdFx0dmFyIHByaW9yRXJyb3JzID0gZXJyb3JzO1xyXG5cdFx0XHRcdFx0ZXJyb3JzID0gW107XHJcblx0XHRcdFx0XHRjaGVja1Byb3AodmFsdWUsdHlwZSxwYXRoKTtcclxuXHRcdFx0XHRcdHZhciB0aGVzZUVycm9ycyA9IGVycm9ycztcclxuXHRcdFx0XHRcdGVycm9ycyA9IHByaW9yRXJyb3JzO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoZXNlRXJyb3JzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblx0XHRpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0aWYoc2NoZW1hLnJlcXVpcmVkKXtcclxuXHRcdFx0XHRhZGRFcnJvcihcImlzIG1pc3NpbmcgYW5kIGl0IGlzIHJlcXVpcmVkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0ZXJyb3JzID0gZXJyb3JzLmNvbmNhdChjaGVja1R5cGUoZ2V0VHlwZShzY2hlbWEpLHZhbHVlKSk7XHJcblx0XHRcdGlmKHNjaGVtYS5kaXNhbGxvdyAmJiAhY2hlY2tUeXBlKHNjaGVtYS5kaXNhbGxvdyx2YWx1ZSkubGVuZ3RoKXtcclxuXHRcdFx0XHRhZGRFcnJvcihcIiBkaXNhbGxvd2VkIHZhbHVlIHdhcyBtYXRjaGVkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHZhbHVlICE9PSBudWxsKXtcclxuXHRcdFx0XHRpZih2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KXtcclxuXHRcdFx0XHRcdGlmKHNjaGVtYS5pdGVtcyl7XHJcblx0XHRcdFx0XHRcdHZhciBpdGVtc0lzQXJyYXkgPSBzY2hlbWEuaXRlbXMgaW5zdGFuY2VvZiBBcnJheTtcclxuXHRcdFx0XHRcdFx0dmFyIHByb3BEZWYgPSBzY2hlbWEuaXRlbXM7XHJcblx0XHRcdFx0XHRcdGZvciAoaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaXRlbXNJc0FycmF5KVxyXG5cdFx0XHRcdFx0XHRcdFx0cHJvcERlZiA9IHNjaGVtYS5pdGVtc1tpXTtcclxuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5jb2VyY2UpXHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZVtpXSA9IG9wdGlvbnMuY29lcmNlKHZhbHVlW2ldLCBwcm9wRGVmKTtcclxuXHRcdFx0XHRcdFx0XHRlcnJvcnMuY29uY2F0KGNoZWNrUHJvcCh2YWx1ZVtpXSxwcm9wRGVmLHBhdGgsaSkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihzY2hlbWEubWluSXRlbXMgJiYgdmFsdWUubGVuZ3RoIDwgc2NoZW1hLm1pbkl0ZW1zKXtcclxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoXCJUaGVyZSBtdXN0IGJlIGEgbWluaW11bSBvZiBcIiArIHNjaGVtYS5taW5JdGVtcyArIFwiIGluIHRoZSBhcnJheVwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKHNjaGVtYS5tYXhJdGVtcyAmJiB2YWx1ZS5sZW5ndGggPiBzY2hlbWEubWF4SXRlbXMpe1xyXG5cdFx0XHRcdFx0XHRhZGRFcnJvcihcIlRoZXJlIG11c3QgYmUgYSBtYXhpbXVtIG9mIFwiICsgc2NoZW1hLm1heEl0ZW1zICsgXCIgaW4gdGhlIGFycmF5XCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1lbHNlIGlmKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyl7XHJcblx0XHRcdFx0XHRlcnJvcnMuY29uY2F0KGNoZWNrT2JqKHZhbHVlLCBzY2hlbWEucHJvcGVydGllcywgcGF0aCwgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYS5wYXR0ZXJuICYmIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiAhdmFsdWUubWF0Y2goc2NoZW1hLnBhdHRlcm4pKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwiZG9lcyBub3QgbWF0Y2ggdGhlIHJlZ2V4IHBhdHRlcm4gXCIgKyBzY2hlbWEucGF0dGVybik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYS5tYXhMZW5ndGggJiYgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IHNjaGVtYS5tYXhMZW5ndGgpe1xyXG5cdFx0XHRcdFx0YWRkRXJyb3IoXCJtYXkgb25seSBiZSBcIiArIHNjaGVtYS5tYXhMZW5ndGggKyBcIiBjaGFyYWN0ZXJzIGxvbmdcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYS5taW5MZW5ndGggJiYgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA8IHNjaGVtYS5taW5MZW5ndGgpe1xyXG5cdFx0XHRcdFx0YWRkRXJyb3IoXCJtdXN0IGJlIGF0IGxlYXN0IFwiICsgc2NoZW1hLm1pbkxlbmd0aCArIFwiIGNoYXJhY3RlcnMgbG9uZ1wiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZW9mIHNjaGVtYS5taW5pbXVtICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdmFsdWUgPT0gdHlwZW9mIHNjaGVtYS5taW5pbXVtICYmXHJcblx0XHRcdFx0XHRcdHNjaGVtYS5taW5pbXVtID4gdmFsdWUpe1xyXG5cdFx0XHRcdFx0YWRkRXJyb3IoXCJtdXN0IGhhdmUgYSBtaW5pbXVtIHZhbHVlIG9mIFwiICsgc2NoZW1hLm1pbmltdW0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih0eXBlb2Ygc2NoZW1hLm1heGltdW0gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB2YWx1ZSA9PSB0eXBlb2Ygc2NoZW1hLm1heGltdW0gJiZcclxuXHRcdFx0XHRcdFx0c2NoZW1hLm1heGltdW0gPCB2YWx1ZSl7XHJcblx0XHRcdFx0XHRhZGRFcnJvcihcIm11c3QgaGF2ZSBhIG1heGltdW0gdmFsdWUgb2YgXCIgKyBzY2hlbWEubWF4aW11bSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYVsnZW51bSddKXtcclxuXHRcdFx0XHRcdHZhciBlbnVtZXIgPSBzY2hlbWFbJ2VudW0nXTtcclxuXHRcdFx0XHRcdGwgPSBlbnVtZXIubGVuZ3RoO1xyXG5cdFx0XHRcdFx0dmFyIGZvdW5kO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGw7IGorKyl7XHJcblx0XHRcdFx0XHRcdGlmKGVudW1lcltqXT09PXZhbHVlKXtcclxuXHRcdFx0XHRcdFx0XHRmb3VuZD0xO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZighZm91bmQpe1xyXG5cdFx0XHRcdFx0XHRhZGRFcnJvcihcImRvZXMgbm90IGhhdmUgYSB2YWx1ZSBpbiB0aGUgZW51bWVyYXRpb24gXCIgKyBlbnVtZXIuam9pbihcIiwgXCIpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZW9mIHNjaGVtYS5tYXhEZWNpbWFsID09ICdudW1iZXInICYmXHJcblx0XHRcdFx0XHQodmFsdWUudG9TdHJpbmcoKS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXC5bMC05XXtcIiArIChzY2hlbWEubWF4RGVjaW1hbCArIDEpICsgXCIsfVwiKSkpKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwibWF5IG9ubHkgaGF2ZSBcIiArIHNjaGVtYS5tYXhEZWNpbWFsICsgXCIgZGlnaXRzIG9mIGRlY2ltYWwgcGxhY2VzXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdC8vIHZhbGlkYXRlIGFuIG9iamVjdCBhZ2FpbnN0IGEgc2NoZW1hXHJcblx0ZnVuY3Rpb24gY2hlY2tPYmooaW5zdGFuY2Usb2JqVHlwZURlZixwYXRoLGFkZGl0aW9uYWxQcm9wKXtcclxuXHJcblx0XHRpZih0eXBlb2Ygb2JqVHlwZURlZiA9PSdvYmplY3QnKXtcclxuXHRcdFx0aWYodHlwZW9mIGluc3RhbmNlICE9ICdvYmplY3QnIHx8IGluc3RhbmNlIGluc3RhbmNlb2YgQXJyYXkpe1xyXG5cdFx0XHRcdGVycm9ycy5wdXNoKHtwcm9wZXJ0eTpwYXRoLG1lc3NhZ2U6XCJhbiBvYmplY3QgaXMgcmVxdWlyZWRcIn0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IodmFyIGkgaW4gb2JqVHlwZURlZil7IFxyXG5cdFx0XHRcdGlmKG9ialR5cGVEZWYuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPSAnX19wcm90b19fJyAmJiBpICE9ICdjb25zdHJ1Y3Rvcicpe1xyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gaW5zdGFuY2UuaGFzT3duUHJvcGVydHkoaSkgPyBpbnN0YW5jZVtpXSA6IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdC8vIHNraXAgX25vdF8gc3BlY2lmaWVkIHByb3BlcnRpZXNcclxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuZXhpc3RpbmdPbmx5KSBjb250aW51ZTtcclxuXHRcdFx0XHRcdHZhciBwcm9wRGVmID0gb2JqVHlwZURlZltpXTtcclxuXHRcdFx0XHRcdC8vIHNldCBkZWZhdWx0XHJcblx0XHRcdFx0XHRpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHByb3BEZWZbXCJkZWZhdWx0XCJdKXtcclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBpbnN0YW5jZVtpXSA9IHByb3BEZWZbXCJkZWZhdWx0XCJdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYob3B0aW9ucy5jb2VyY2UgJiYgaSBpbiBpbnN0YW5jZSl7XHJcblx0XHRcdFx0XHRcdHZhbHVlID0gaW5zdGFuY2VbaV0gPSBvcHRpb25zLmNvZXJjZSh2YWx1ZSwgcHJvcERlZik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjaGVja1Byb3AodmFsdWUscHJvcERlZixwYXRoLGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgaW4gaW5zdGFuY2Upe1xyXG5cdFx0XHRpZihpbnN0YW5jZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhKGkuY2hhckF0KDApID09ICdfJyAmJiBpLmNoYXJBdCgxKSA9PSAnXycpICYmIG9ialR5cGVEZWYgJiYgIW9ialR5cGVEZWZbaV0gJiYgYWRkaXRpb25hbFByb3A9PT1mYWxzZSl7XHJcblx0XHRcdFx0aWYgKG9wdGlvbnMuZmlsdGVyKSB7XHJcblx0XHRcdFx0XHRkZWxldGUgaW5zdGFuY2VbaV07XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZXJyb3JzLnB1c2goe3Byb3BlcnR5OnBhdGgsbWVzc2FnZTpcIlRoZSBwcm9wZXJ0eSBcIiArIGkgK1xyXG5cdFx0XHRcdFx0XHRcIiBpcyBub3QgZGVmaW5lZCBpbiB0aGUgc2NoZW1hIGFuZCB0aGUgc2NoZW1hIGRvZXMgbm90IGFsbG93IGFkZGl0aW9uYWwgcHJvcGVydGllc1wifSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHZhciByZXF1aXJlcyA9IG9ialR5cGVEZWYgJiYgb2JqVHlwZURlZltpXSAmJiBvYmpUeXBlRGVmW2ldLnJlcXVpcmVzO1xyXG5cdFx0XHRpZihyZXF1aXJlcyAmJiAhKHJlcXVpcmVzIGluIGluc3RhbmNlKSl7XHJcblx0XHRcdFx0ZXJyb3JzLnB1c2goe3Byb3BlcnR5OnBhdGgsbWVzc2FnZTpcInRoZSBwcmVzZW5jZSBvZiB0aGUgcHJvcGVydHkgXCIgKyBpICsgXCIgcmVxdWlyZXMgdGhhdCBcIiArIHJlcXVpcmVzICsgXCIgYWxzbyBiZSBwcmVzZW50XCJ9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldO1xyXG5cdFx0XHRpZihhZGRpdGlvbmFsUHJvcCAmJiAoIShvYmpUeXBlRGVmICYmIHR5cGVvZiBvYmpUeXBlRGVmID09ICdvYmplY3QnKSB8fCAhKGkgaW4gb2JqVHlwZURlZikpKXtcclxuXHRcdFx0XHRpZihvcHRpb25zLmNvZXJjZSl7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldID0gb3B0aW9ucy5jb2VyY2UodmFsdWUsIGFkZGl0aW9uYWxQcm9wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2hlY2tQcm9wKHZhbHVlLGFkZGl0aW9uYWxQcm9wLHBhdGgsaSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIV9jaGFuZ2luZyAmJiB2YWx1ZSAmJiB2YWx1ZS4kc2NoZW1hKXtcclxuXHRcdFx0XHRlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGNoZWNrUHJvcCh2YWx1ZSx2YWx1ZS4kc2NoZW1hLHBhdGgsaSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXJyb3JzO1xyXG5cdH1cclxuXHRpZihzY2hlbWEpe1xyXG5cdFx0Y2hlY2tQcm9wKGluc3RhbmNlLHNjaGVtYSwnJyxfY2hhbmdpbmcgfHwgJycpO1xyXG5cdH1cclxuXHRpZighX2NoYW5naW5nICYmIGluc3RhbmNlICYmIGluc3RhbmNlLiRzY2hlbWEpe1xyXG5cdFx0Y2hlY2tQcm9wKGluc3RhbmNlLGluc3RhbmNlLiRzY2hlbWEsJycsJycpO1xyXG5cdH1cclxuXHRyZXR1cm4ge3ZhbGlkOiFlcnJvcnMubGVuZ3RoLGVycm9yczplcnJvcnN9O1xyXG59O1xyXG5leHBvcnRzLm11c3RCZVZhbGlkID0gZnVuY3Rpb24ocmVzdWx0KXtcclxuXHQvL1x0c3VtbWFyeTpcclxuXHQvL1x0XHRUaGlzIGNoZWNrcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IGlzIHZhbGlkIGFuZCB3aWxsIHRocm93IGFuIGFwcHJvcHJpYXRlIGVycm9yIG1lc3NhZ2UgaWYgaXQgaXMgbm90XHJcblx0Ly8gcmVzdWx0OiB0aGUgcmVzdWx0IHJldHVybmVkIGZyb20gY2hlY2tQcm9wZXJ0eUNoYW5nZSBvciB2YWxpZGF0ZVxyXG5cdGlmKCFyZXN1bHQudmFsaWQpe1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihyZXN1bHQuZXJyb3JzLm1hcChmdW5jdGlvbihlcnJvcil7cmV0dXJuIFwiZm9yIHByb3BlcnR5IFwiICsgZXJyb3IucHJvcGVydHkgKyAnOiAnICsgZXJyb3IubWVzc2FnZTt9KS5qb2luKFwiLCBcXG5cIikpO1xyXG5cdH1cclxufVxyXG5cclxucmV0dXJuIGV4cG9ydHM7XHJcbn0pKTtcclxuIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsImpzb25TY2hlbWEiLCJ2YWxpZGF0ZSIsIkludGVnZXIiLCJ0eXBlIiwicHJpbWl0aXZlQ29uc3RydWN0b3JzIiwiU3RyaW5nIiwiQm9vbGVhbiIsIk51bWJlciIsIk9iamVjdCIsIkFycmF5IiwiRGF0ZSIsImluc3RhbmNlIiwic2NoZW1hIiwiY2hhbmdpbmciLCJjaGVja1Byb3BlcnR5Q2hhbmdlIiwidmFsdWUiLCJwcm9wZXJ0eSIsIl92YWxpZGF0ZSIsIm9wdGlvbnMiLCJfY2hhbmdpbmciLCJnZXRUeXBlIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiZXJyb3JzIiwiY2hlY2tQcm9wIiwicGF0aCIsImkiLCJsIiwiYWRkRXJyb3IiLCJtZXNzYWdlIiwicHVzaCIsInJlYWRvbmx5IiwiY2hlY2tUeXBlIiwidW5pb25FcnJvcnMiLCJqIiwibGVuZ3RoIiwicHJpb3JFcnJvcnMiLCJ0aGVzZUVycm9ycyIsInVuZGVmaW5lZCIsInJlcXVpcmVkIiwiY29uY2F0IiwiZGlzYWxsb3ciLCJpdGVtcyIsIml0ZW1zSXNBcnJheSIsInByb3BEZWYiLCJjb2VyY2UiLCJtaW5JdGVtcyIsIm1heEl0ZW1zIiwicHJvcGVydGllcyIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiY2hlY2tPYmoiLCJwYXR0ZXJuIiwibWF0Y2giLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJtaW5pbXVtIiwibWF4aW11bSIsImVudW1lciIsImZvdW5kIiwiam9pbiIsIm1heERlY2ltYWwiLCJ0b1N0cmluZyIsIlJlZ0V4cCIsIm9ialR5cGVEZWYiLCJhZGRpdGlvbmFsUHJvcCIsImhhc093blByb3BlcnR5IiwiZXhpc3RpbmdPbmx5IiwiY2hhckF0IiwiZmlsdGVyIiwicmVxdWlyZXMiLCIkc2NoZW1hIiwidmFsaWQiLCJtdXN0QmVWYWxpZCIsInJlc3VsdCIsIlR5cGVFcnJvciIsIm1hcCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/json-schema/lib/validate.js\n");

/***/ })

};
;